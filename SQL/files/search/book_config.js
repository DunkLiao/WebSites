var textForPages =["","","","Anthony Molinaro and Robert de Graaf\u000d\u000aSQL Cookbook\u000d\u000aQuery Solutions and Techniques\u000d\u000afor All SQL Users\u000d\u000aSECOND EDITION","978-1-098-10014-8\u000d\u000a[LSI]\u000d\u000aSQL Cookbook\u000d\u000aby Anthony Molinaro and Robert de Graaf\u000d\u000aCopyright \u00a9 2021 Robert de Graaf. All rights reserved.\u000d\u000aPrinted in the United States of America.\u000d\u000aPublished by O\u2019Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\u000d\u000aO\u2019Reilly books may be purchased for educational, business, or sales promotional use. Online editions are\u000d\u000aalso available for most titles (http://oreilly.com). For more information, contact our corporate/institutional\u000d\u000asales department: 800-998-9938 or corporate@oreilly.com.\u000d\u000aAcquisitions Editor: Jessica Haberman\u000d\u000aDevelopment Editor: Virginia Wilson\u000d\u000aProduction Editor: Kate Galloway\u000d\u000aCopyeditor: Kim Wimpsett\u000d\u000aProofreader: nSight, Inc.\u000d\u000aIndexer: WordCo Indexing Services, Inc.\u000d\u000aInterior Designer: David Futato\u000d\u000aCover Designer: Karen Montgomery\u000d\u000aIllustrator: O\u2019Reilly Media\u000d\u000aDecember 2005: First Edition\u000d\u000aDecember 2020: Second Edition\u000d\u000aRevision History for the Second Edition\u000d\u000a2020-11-03: First Release\u000d\u000aSee http://oreilly.com/catalog/errata.csp?isbn=9781492077442 for release details.\u000d\u000aThe O\u2019Reilly logo is a registered trademark of O\u2019Reilly Media, Inc. SQL Cookbook, the cover image, and\u000d\u000arelated trade dress are trademarks of O\u2019Reilly Media, Inc.\u000d\u000aThe views expressed in this work are those of the authors, and do not represent the publisher\u2019s views.\u000d\u000aWhile the publisher and the authors have used good faith efforts to ensure that the information and\u000d\u000ainstructions contained in this work are accurate, the publisher and the authors disclaim all responsibility\u000d\u000afor errors or omissions, including without limitation responsibility for damages resulting from the use of\u000d\u000aor reliance on this work. Use of the information and instructions contained in this work is at your own\u000d\u000arisk. If any code samples or other technology this work contains or describes is subject to open source\u000d\u000alicenses or the intellectual property rights of others, it is your responsibility to ensure that your use\u000d\u000athereof complies with such licenses and/or rights.\u000d\u000aThis work is part of a collaboration between O\u2019Reilly and Yugabyte. See our statement of editorial inde\u2010\u000d\u000apendence.","To my mom: You\u2019re the best! \u0081ank you for everything.\u000d\u000a\u2014Anthony\u000d\u000aTo Clare, Maya, and Leda.\u000d\u000a\u2014Robert","","Table of Contents\u000d\u000aPreface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii\u000d\u000a1. Retrieving Records. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\u000d\u000a1.1 Retrieving All Rows and Columns from a Table 1\u000d\u000a1.2 Retrieving a Subset of Rows from a Table 2\u000d\u000a1.3 Finding Rows That Satisfy Multiple Conditions 2\u000d\u000a1.4 Retrieving a Subset of Columns from a Table 3\u000d\u000a1.5 Providing Meaningful Names for Columns 4\u000d\u000a1.6 Referencing an Aliased Column in the WHERE Clause 5\u000d\u000a1.7 Concatenating Column Values 6\u000d\u000a1.8 Using Conditional Logic in a SELECT Statement 7\u000d\u000a1.9 Limiting the Number of Rows Returned 8\u000d\u000a1.10 Returning n Random Records from a Table 10\u000d\u000a1.11 Finding Null Values 11\u000d\u000a1.12 Transforming Nulls into Real Values 12\u000d\u000a1.13 Searching for Patterns 13\u000d\u000a1.14 Summing Up 14\u000d\u000a2. Sorting Query Results. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\u000d\u000a2.1 Returning Query Results in a Specified Order 15\u000d\u000a2.2 Sorting by Multiple Fields 16\u000d\u000a2.3 Sorting by Substrings 17\u000d\u000a2.4 Sorting Mixed Alphanumeric Data 18\u000d\u000a2.5 Dealing with Nulls When Sorting 21\u000d\u000a2.6 Sorting on a Data-Dependent Key 27\u000d\u000a2.7 Summing Up 28\u000d\u000avii","3. Working with Multiple Tables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\u000d\u000a3.1 Stacking One Rowset atop Another 29\u000d\u000a3.2 Combining Related Rows 31\u000d\u000a3.3 Finding Rows in Common Between Two Tables 33\u000d\u000a3.4 Retrieving Values from One Table That Do Not Exist in Another 34\u000d\u000a3.5 Retrieving Rows from One Table That Do Not Correspond to Rows in\u000d\u000aAnother 40\u000d\u000a3.6 Adding Joins to a Query Without Interfering with Other Joins 42\u000d\u000a3.7 Determining Whether Two Tables Have the Same Data 44\u000d\u000a3.8 Identifying and Avoiding Cartesian Products 51\u000d\u000a3.9 Performing Joins When Using Aggregates 52\u000d\u000a3.10 Performing Outer Joins When Using Aggregates 57\u000d\u000a3.11 Returning Missing Data from Multiple Tables 60\u000d\u000a3.12 Using NULLs in Operations and Comparisons 64\u000d\u000a3.13 Summing Up 65\u000d\u000a4. Inserting, Updating, and Deleting. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67\u000d\u000a4.1 Inserting a New Record 68\u000d\u000a4.2 Inserting Default Values 68\u000d\u000a4.3 Overriding a Default Value with NULL 70\u000d\u000a4.4 Copying Rows from One Table into Another 70\u000d\u000a4.5 Copying a Table Definition 71\u000d\u000a4.6 Inserting into Multiple Tables at Once 72\u000d\u000a4.7 Blocking Inserts to Certain Columns 74\u000d\u000a4.8 Modifying Records in a Table 75\u000d\u000a4.9 Updating When Corresponding Rows Exist 77\u000d\u000a4.10 Updating with Values from Another Table 78\u000d\u000a4.11 Merging Records 81\u000d\u000a4.12 Deleting All Records from a Table 83\u000d\u000a4.13 Deleting Specific Records 83\u000d\u000a4.14 Deleting a Single Record 84\u000d\u000a4.15 Deleting Referential Integrity Violations 85\u000d\u000a4.16 Deleting Duplicate Records 85\u000d\u000a4.17 Deleting Records Referenced from Another Table 87\u000d\u000a4.18 Summing Up 89\u000d\u000a5. Metadata Queries. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91\u000d\u000a5.1 Listing Tables in a Schema 91\u000d\u000a5.2 Listing a Table\u2019s Columns 93\u000d\u000a5.3 Listing Indexed Columns for a Table 94\u000d\u000a5.4 Listing Constraints on a Table 95\u000d\u000a5.5 Listing Foreign Keys Without Corresponding Indexes 97\u000d\u000aviii | Table of Contents","5.6 Using SQL to Generate SQL 100\u000d\u000a5.7 Describing the Data Dictionary Views in an Oracle Database 102\u000d\u000a5.8 Summing Up 103\u000d\u000a6. Working with Strings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105\u000d\u000a6.1 Walking a String 106\u000d\u000a6.2 Embedding Quotes Within String Literals 108\u000d\u000a6.3 Counting the Occurrences of a Character in a String 109\u000d\u000a6.4 Removing Unwanted Characters from a String 110\u000d\u000a6.5 Separating Numeric and Character Data 112\u000d\u000a6.6 Determining Whether a String Is Alphanumeric 116\u000d\u000a6.7 Extracting Initials from a Name 120\u000d\u000a6.8 Ordering by Parts of a String 125\u000d\u000a6.9 Ordering by a Number in a String 126\u000d\u000a6.10 Creating a Delimited List from Table Rows 132\u000d\u000a6.11 Converting Delimited Data into a Multivalued IN-List 136\u000d\u000a6.12 Alphabetizing a String 141\u000d\u000a6.13 Identifying Strings That Can Be Treated as Numbers 147\u000d\u000a6.14 Extracting the nth Delimited Substring 153\u000d\u000a6.15 Parsing an IP Address 160\u000d\u000a6.16 Comparing Strings by Sound 162\u000d\u000a6.17 Finding Text Not Matching a Pattern 164\u000d\u000a6.18 Summing Up 167\u000d\u000a7. Working with Numbers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169\u000d\u000a7.1 Computing an Average 169\u000d\u000a7.2 Finding the Min/Max Value in a Column 171\u000d\u000a7.3 Summing the Values in a Column 173\u000d\u000a7.4 Counting Rows in a Table 175\u000d\u000a7.5 Counting Values in a Column 177\u000d\u000a7.6 Generating a Running Total 178\u000d\u000a7.7 Generating a Running Product 179\u000d\u000a7.8 Smoothing a Series of Values 181\u000d\u000a7.9 Calculating a Mode 182\u000d\u000a7.10 Calculating a Median 185\u000d\u000a7.11 Determining the Percentage of a Total 187\u000d\u000a7.12 Aggregating Nullable Columns 190\u000d\u000a7.13 Computing Averages Without High and Low Values 191\u000d\u000a7.14 Converting Alphanumeric Strings into Numbers 193\u000d\u000a7.15 Changing Values in a Running Total 196\u000d\u000a7.16 Finding Outliers Using the Median Absolute Deviation 197\u000d\u000a7.17 Finding Anomalies Using Benford\u2019s Law 201\u000d\u000aTable of Contents | ix","7.18 Summing Up 203\u000d\u000a8. Date Arithmetic. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205\u000d\u000a8.1 Adding and Subtracting Days, Months, and Years 205\u000d\u000a8.2 Determining the Number of Days Between Two Dates 208\u000d\u000a8.3 Determining the Number of Business Days Between Two Dates 210\u000d\u000a8.4 Determining the Number of Months or Years Between Two Dates 215\u000d\u000a8.5 Determining the Number of Seconds, Minutes, or Hours Between Two\u000d\u000aDates 218\u000d\u000a8.6 Counting the Occurrences of Weekdays in a Year 220\u000d\u000a8.7 Determining the Date Difference Between the Current Record and the\u000d\u000aNext Record 231\u000d\u000a8.8 Summing Up 237\u000d\u000a9. Date Manipulation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239\u000d\u000a9.1 Determining Whether a Year Is a Leap Year 240\u000d\u000a9.2 Determining the Number of Days in a Year 246\u000d\u000a9.3 Extracting Units of Time from a Date 249\u000d\u000a9.4 Determining the First and Last Days of a Month 252\u000d\u000a9.5 Determining All Dates for a Particular Weekday Throughout a Year 255\u000d\u000a9.6 Determining the Date of the First and Last Occurrences of a Specific\u000d\u000aWeekday in a Month 261\u000d\u000a9.7 Creating a Calendar 268\u000d\u000a9.8 Listing Quarter Start and End Dates for the Year 281\u000d\u000a9.9 Determining Quarter Start and End Dates for a Given Quarter 286\u000d\u000a9.10 Filling in Missing Dates 293\u000d\u000a9.11 Searching on Specific Units of Time 301\u000d\u000a9.12 Comparing Records Using Specific Parts of a Date 302\u000d\u000a9.13 Identifying Overlapping Date Ranges 305\u000d\u000a9.14 Summing Up 311\u000d\u000a10. Working with Ranges. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\u000d\u000a10.1 Locating a Range of Consecutive Values 313\u000d\u000a10.2 Finding Differences Between Rows in the Same Group or Partition 317\u000d\u000a10.3 Locating the Beginning and End of a Range of Consecutive Values 323\u000d\u000a10.4 Filling in Missing Values in a Range of Values 326\u000d\u000a10.5 Generating Consecutive Numeric Values 330\u000d\u000a10.6 Summing Up 333\u000d\u000a11. Advanced Searching. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335\u000d\u000a11.1 Paginating Through a Result Set 335\u000d\u000a11.2 Skipping n Rows from a Table 338\u000d\u000ax | Table of Contents","11.3 Incorporating OR Logic When Using Outer Joins 339\u000d\u000a11.4 Determining Which Rows Are Reciprocals 341\u000d\u000a11.5 Selecting the Top n Records 343\u000d\u000a11.6 Finding Records with the Highest and Lowest Values 344\u000d\u000a11.7 Investigating Future Rows 345\u000d\u000a11.8 Shifting Row Values 347\u000d\u000a11.9 Ranking Results 350\u000d\u000a11.10 Suppressing Duplicates 351\u000d\u000a11.11 Finding Knight Values 353\u000d\u000a11.12 Generating Simple Forecasts 359\u000d\u000a11.13 Summing Up 367\u000d\u000a12. Reporting and Reshaping. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369\u000d\u000a12.1 Pivoting a Result Set into One Row 369\u000d\u000a12.2 Pivoting a Result Set into Multiple Rows 372\u000d\u000a12.3 Reverse Pivoting a Result Set 377\u000d\u000a12.4 Reverse Pivoting a Result Set into One Column 379\u000d\u000a12.5 Suppressing Repeating Values from a Result Set 382\u000d\u000a12.6 Pivoting a Result Set to Facilitate Inter-Row Calculations 384\u000d\u000a12.7 Creating Buckets of Data, of a Fixed Size 386\u000d\u000a12.8 Creating a Predefined Number of Buckets 388\u000d\u000a12.9 Creating Horizontal Histograms 390\u000d\u000a12.10 Creating Vertical Histograms 392\u000d\u000a12.11 Returning Non-GROUP BY Columns 394\u000d\u000a12.12 Calculating Simple Subtotals 397\u000d\u000a12.13 Calculating Subtotals for All Possible Expression Combinations 400\u000d\u000a12.14 Identifying Rows That Are Not Subtotals 410\u000d\u000a12.15 Using Case Expressions to Flag Rows 412\u000d\u000a12.16 Creating a Sparse Matrix 414\u000d\u000a12.17 Grouping Rows by Units of Time 416\u000d\u000a12.18 Performing Aggregations over Different Groups/Partitions\u000d\u000aSimultaneously 420\u000d\u000a12.19 Performing Aggregations over a Moving Range of Values 422\u000d\u000a12.20 Pivoting a Result Set with Subtotals 429\u000d\u000a12.21 Summing Up 434\u000d\u000a13. Hierarchical Queries. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\u000d\u000a13.1 Expressing a Parent-Child Relationship 436\u000d\u000a13.2 Expressing a Child-Parent-Grandparent Relationship 440\u000d\u000a13.3 Creating a Hierarchical View of a Table 444\u000d\u000a13.4 Finding All Child Rows for a Given Parent Row 449\u000d\u000a13.5 Determining Which Rows Are Leaf, Branch, or Root Nodes 450\u000d\u000aTable of Contents | xi","13.6 Summing Up 458\u000d\u000a14. Odds \u2019n\u2019 Ends. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459\u000d\u000a14.1 Creating Cross-Tab Reports Using SQL Server\u2019s PIVOT Operator 459\u000d\u000a14.2 Unpivoting a Cross-Tab Report Using SQL Server\u2019s UNPIVOT Operator 461\u000d\u000a14.3 Transposing a Result Set Using Oracle\u2019s MODEL Clause 463\u000d\u000a14.4 Extracting Elements of a String from Unfixed Locations 467\u000d\u000a14.5 Finding the Number of Days in a Year (an Alternate Solution for Oracle) 470\u000d\u000a14.6 Searching for Mixed Alphanumeric Strings 472\u000d\u000a14.7 Converting Whole Numbers to Binary Using Oracle 474\u000d\u000a14.8 Pivoting a Ranked Result Set 477\u000d\u000a14.9 Adding a Column Header into a Double Pivoted Result Set 481\u000d\u000a14.10 Converting a Scalar Subquery to a Composite Subquery in Oracle 493\u000d\u000a14.11 Parsing Serialized Data into Rows 495\u000d\u000a14.12 Calculating Percent Relative to Total 500\u000d\u000a14.13 Testing for Existence of a Value Within a Group 502\u000d\u000a14.14 Summing Up 505\u000d\u000aA. Window Function Refresher. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507\u000d\u000aB. Common Table Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535\u000d\u000aIndex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\u000d\u000axii | Table of Contents","Preface\u000d\u000aSQL is the lingua franca of the data professional. At the same time, it doesn\u2019t always\u000d\u000aget the attention it deserves compared to the hot tool du jour. As result, it\u2019s common\u000d\u000ato find people who use SQL frequently but rarely or never go beyond the simplest\u000d\u000aqueries, often enough because they believe that\u2019s all there is.\u000d\u000aThis book shows how much SQL can do, expanding users\u2019 tool boxes. By the end of\u000d\u000athe book you will have seen how SQL can be used for statistical analysis; to do report\u2010\u000d\u000aing in a manner similar to Business Intelligence tools; to match text data; to perform\u000d\u000asophisticated analysis on date data; and much more.\u000d\u000aThe first edition of SQL Cookbook has been a popular choice as the \u201csecond book on\u000d\u000aSQL\u201d\u2014the book people read after they learn the basics\u2014since its original release. It\u000d\u000ahas many strengths, such as its wide range of topics and its friendly style.\u000d\u000aHowever, computing is known to move fast, even when it comes to something as\u000d\u000amature as SQL, which has roots going back to the 1970s. While this new edition\u000d\u000adoesn\u2019t cover brand new language features, an important change is that features that\u000d\u000awere novel at the time of the first edition, and found in some implementations and\u000d\u000anot in others, are now stabilized and standardized. As a result, we have a lot more\u000d\u000ascope for developing standard solutions than was possible earlier.\u000d\u000aThere are two key examples that are important to highlight. Common table expres\u2010\u000d\u000asions (CTEs), including recursive CTEs, were available in a couple of implementa\u2010\u000d\u000ations at the time the first edition was released, but are now available in all five. They\u000d\u000awere introduced to solve some practical limitations of SQL, some of which can be\u000d\u000aseen directly in these recipes. A new appendix on recursive CTEs in this edition\u000d\u000aunderlines their importance and explains their relevance.\u000d\u000aWindow functions were also new enough at the time of the first edition\u2019s release that\u000d\u000athey weren\u2019t available in every implementation. They were also new enough that a\u000d\u000aspecial appendix was written to explain them, which remains. Now, however, window\u000d\u000afunctions are in all implementations in this book. They are also in every other SQL\u000d\u000axiii","implementation that we\u2019re aware of, although there are so many databases out there,\u000d\u000ait\u2019s impossible to guarantee there isn\u2019t one that neglects window functions and/or\u000d\u000aCTEs.\u000d\u000aIn addition to standardizing queries where possible, we\u2019ve brought new material into\u000d\u000aChapters 6 and 7. The material in Chapter 7 unlocks new data analysis applications in\u000d\u000arecipes about the median absolute deviation and Benford\u2019s law. In Chapter 6, we have\u000d\u000aa new recipe to help match data by the sound of the text, and we have moved material\u000d\u000aon regular expressions to Chapter 6 from Chapter 14.\u000d\u000aWho This Book Is For\u000d\u000aThis book is meant to be for any SQL user who wants to take their queries further. In\u000d\u000aterms of ability, it\u2019s meant for someone who knows at least some SQL\u2014you might\u000d\u000ahave read Alan Beaulieu\u2019s Learning SQL, for example\u2014and ideally you\u2019ve had to write\u000d\u000aqueries on data in the wild to answer a real-life problem.\u000d\u000aOther than those loose parameters, this is a book for all SQL users, including data\u000d\u000aengineers, data scientists, data visualization folk, BI people, etc. Some of these users\u000d\u000amay never or rarely access databases directly, but use their data visualization, BI, or\u000d\u000astatistical tool to query and fetch data. The emphasis is on practical queries that can\u000d\u000asolve real-world problems. Where a small amount of theory appears, it\u2019s there to\u000d\u000adirectly support the practical elements.\u000d\u000aWhat\u2019s Missing from This Book\u000d\u000aThis is a practical book, chiefly about using SQL to understand data. It doesn\u2019t cover\u000d\u000atheoretical aspects of databases, database design, or the theory behind SQL except\u000d\u000awhere needed to explain specific recipes or techniques.\u000d\u000aIt also doesn\u2019t cover extensions to databases to handle data types such as XML and\u000d\u000aJSON. There are other resources available for those specialist topics.\u000d\u000aPlatform and Version\u000d\u000aSQL is a moving target. Vendors are constantly pumping new features and function\u2010\u000d\u000aality into their products. Thus, you should know up front which versions of the vari\u2010\u000d\u000aous platforms were used in the preparation of this text:\u000d\u000a\u2022 DB2 11.5\u000d\u000a\u2022 Oracle Database 19c\u000d\u000a\u2022 PostgreSQL 12\u000d\u000axiv | Preface","\u2022 SQL Server 2017\u000d\u000a\u2022 MySQL 8.0\u000d\u000aTables Used in This Book\u000d\u000aThe majority of the examples in this book involve the use of two tables, EMP and\u000d\u000aDEPT. The EMP table is a simple 14-row table with only numeric, string, and date\u000d\u000afields. The DEPT table is a simple four-row table with only numeric and string fields.\u000d\u000aThese tables appear in many old database texts, and the many-to-one relationship\u000d\u000abetween departments and employees is well understood.\u000d\u000aAll but a very few solutions in this book run against these tables. Nowhere do we\u000d\u000atweak the example data to set up a solution that you would be unlikely to have a\u000d\u000achance of implementing in the real world, as some books do.\u000d\u000aThe contents of EMP and DEPT are shown here, respectively:\u000d\u000a select * from emp;\u000d\u000aEMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO\u000d\u000a----- ------ --------- ---- ----------- ---- ---- -------\u000d\u000a 7369 SMITH CLERK 7902 17-DEC-2005 800 20\u000d\u000a 7499 ALLEN SALESMAN 7698 20-FEB-2006 1600 300 30\u000d\u000a 7521 WARD SALESMAN 7698 22-FEB-2006 1250 500 30\u000d\u000a 7566 JONES MANAGER 7839 02-APR-2006 2975 20\u000d\u000a 7654 MARTIN SALESMAN 7698 28-SEP-2006 1250 1400 30\u000d\u000a 7698 BLAKE MANAGER 7839 01-MAY-2006 2850 30\u000d\u000a 7782 CLARK MANAGER 7839 09-JUN-2006 2450 10\u000d\u000a 7788 SCOTT ANALYST 7566 09-DEC-2007 3000 20\u000d\u000a 7839 KING PRESIDENT 17-NOV-2006 5000 10\u000d\u000a 7844 TURNER SALESMAN 7698 08-SEP-2006 1500 0 30\u000d\u000a 7876 ADAMS CLERK 7788 12-JAN-2008 1100 20\u000d\u000a 7900 JAMES CLERK 7698 03-DEC-2006 950 30\u000d\u000a 7902 FORD ANALYST 7566 03-DEC-2006 3000 20\u000d\u000a 7934 MILLER CLERK 7782 23-JAN-2007 1300 10\u000d\u000a select * from dept;\u000d\u000aDEPTNO DNAME LOC\u000d\u000a------ -------------- ---------\u000d\u000a 10 ACCOUNTING NEW YORK\u000d\u000a 20 RESEARCH DALLAS\u000d\u000a 30 SALES CHICAGO\u000d\u000a 40 OPERATIONS BOSTON\u000d\u000aPreface | xv","Additionally, you will find four pivot tables used in this book: T1, T10, T100, and\u000d\u000aT500. Because these tables exist only to facilitate pivots, we didn\u2019t give them clever\u000d\u000anames. The number following the \u201cT\u201d in each of the pivot tables signifies the number\u000d\u000aof rows in each table, starting from 1. For example, here are the values for T1 and\u000d\u000aT10:\u000d\u000aselect id from t1;\u000d\u000a ID\u000d\u000a----------\u000d\u000a 1\u000d\u000aselect id from t10;\u000d\u000a ID\u000d\u000a----------\u000d\u000a 1\u000d\u000a 2\u000d\u000a 3\u000d\u000a 4\u000d\u000a 5\u000d\u000a 6\u000d\u000a 7\u000d\u000a 8\u000d\u000a 9\u000d\u000a 10\u000d\u000aThe pivot tables are a useful shortcut when we need to create a series of rows to facili\u2010\u000d\u000atate a query.\u000d\u000aAs an aside, some vendors allow partial SELECT statements. For example, you can\u000d\u000ahave SELECT without a FROM clause. Sometimes in this book we will use a support\u000d\u000atable, T1, with a single row, rather than using partial queries for clarity. This is similar\u000d\u000ain usage to Oracle\u2019s DUAL table, but by using the T1 table, we do the same thing in a\u000d\u000astandardized way across all the implementations we are looking at.\u000d\u000aAny other tables are specific to particular recipes and chapters and will be introduced\u000d\u000ain the text when appropriate.\u000d\u000aConventions Used in This Book\u000d\u000aWe use a number of typographical and coding conventions in this book. Take time to\u000d\u000abecome familiar with them. Doing so will enhance your understanding of the text.\u000d\u000aCoding conventions in particular are important, because we can\u2019t repeat them for\u000d\u000aeach recipe in the book. Instead, we list the important conventions here.\u000d\u000axvi | Preface","Typographical Conventions\u000d\u000aThe following typographical conventions are used in this book:\u000d\u000aUPPERCASE\u000d\u000aUsed to indicate SQL keywords within text.\u000d\u000alowercase\u000d\u000aUsed for all queries in code examples. Other languages such as C and Java use\u000d\u000alowercase for most keywords, and we find it far more readable than uppercase.\u000d\u000aThus, all queries will be lowercase.\u000d\u000aConstant width bold\u000d\u000aIndicates user input in examples showing an interaction.\u000d\u000aIndicates a tip, suggestion, or general note.\u000d\u000aIndicates a warning or caution.\u000d\u000aCoding Conventions\u000d\u000aOur preference for case in SQL statements is to always use lowercase, for both key\u2010\u000d\u000awords and user-specified identifiers. For example:\u000d\u000aselect empno, ename\u000d\u000a from emp;\u000d\u000aYour preference may be otherwise. For example, many prefer to uppercase SQL key\u2010\u000d\u000awords. Use whatever coding style you prefer, or whatever your project requires.\u000d\u000aDespite the use of lowercase in code examples, we consistently use uppercase for SQL\u000d\u000akeywords and identifiers in the text. We do this to make those items stand out as\u000d\u000asomething other than regular prose. For example:\u000d\u000aThe preceding query represents a SELECT against the EMP table.\u000d\u000aWhile this book covers databases from five different vendors, we\u2019ve decided to use\u000d\u000aone format for all the output:\u000d\u000aPreface | xvii","EMPNO ENAME\u000d\u000a----- ------\u000d\u000a 7369 SMITH\u000d\u000a 7499 ALLEN\u000d\u000a \u2026\u000d\u000aMany solutions make use of inline views, or subqueries in the FROM clause. The\u000d\u000aANSI SQL standard requires that such views be given table aliases. (Oracle is the only\u000d\u000avendor that lets you get away without specifying such aliases.) Thus, our solutions use\u000d\u000aaliases such as X and Y to identify the result sets from inline views:\u000d\u000a select job, sal\u000d\u000afrom (select job, max(sal) sal\u000d\u000a from emp\u000d\u000a group by job)x;\u000d\u000aNotice the letter X following the final, closing parenthesis. That letter X becomes the\u000d\u000aname of the \u201ctable\u201d returned by the subquery in the FROM clause. While column\u000d\u000aaliases are a valuable tool for writing self-documenting code, aliases on inline views\u000d\u000a(for most recipes in this book) are simply formalities. They are typically given trivial\u000d\u000anames such as X, Y, Z, TMP1, and TMP2. In cases where a better alias might provide\u000d\u000amore understanding, we use them.\u000d\u000aYou will notice that the SQL in the \u201cSolution\u201d section of the recipes is typically num\u2010\u000d\u000abered, for example:\u000d\u000a1 select ename\u000d\u000a2 from emp\u000d\u000a3 where deptno = 10\u000d\u000aThe number is not part of the syntax; it is just to reference parts of the query by num\u2010\u000d\u000aber in the \u201cDiscussion\u201d section.\u000d\u000aO\u2019Reilly Online Learning\u000d\u000aFor more than 40 years, O\u2019Reilly Media has provided technol\u2010\u000d\u000aogy and business training, knowledge, and insight to help\u000d\u000acompanies succeed.\u000d\u000aOur unique network of experts and innovators share their knowledge and expertise\u000d\u000athrough books, articles, and our online learning platform. O\u2019Reilly\u2019s online learning\u000d\u000aplatform gives you on-demand access to live training courses, in-depth learning\u000d\u000apaths, interactive coding environments, and a vast collection of text and video from\u000d\u000aO\u2019Reilly and 200+ other publishers. For more information, visit http://oreilly.com.\u000d\u000axviii | Preface","How to Contact Us\u000d\u000aPlease address comments and questions concerning this book to the publisher:\u000d\u000aO\u2019Reilly Media, Inc.\u000d\u000a1005 Gravenstein Highway North\u000d\u000aSebastopol, CA 95472\u000d\u000a800-998-9938 (in the United States or Canada)\u000d\u000a707-829-0515 (international or local)\u000d\u000a707-829-0104 (fax)\u000d\u000aWe have a web page for this book, where we list errata, examples, and any additional\u000d\u000ainformation. You can access this page at https://oreil.ly/sql-ckbk-2e.\u000d\u000aEmail bookquestions@oreilly.com to comment or ask technical questions about this\u000d\u000abook.\u000d\u000aFor news and information about our books and courses, visit http://oreilly.com.\u000d\u000aFind us on Facebook: http://facebook.com/oreilly\u000d\u000aFollow us on Twitter: http://twitter.com/oreillymedia\u000d\u000aWatch us on YouTube: http://www.youtube.com/oreillymedia\u000d\u000aSecond Edition Acknowledgments\u000d\u000aA bunch of great people have helped with this second edition. Thanks to Jess Haber\u2010\u000d\u000aman, Virginia Wilson, Kate Galloway, and Gary O\u2019Brien at O\u2019Reilly. Thanks to Nicho\u2010\u000d\u000alas Adams for repeatedly saving the day in Atlas. Many thanks to the tech reviewers:\u000d\u000aAlan Beaulieu, Scott Haines, and Thomas Nield.\u000d\u000aFinally, many thanks to my family\u2014Clare, Maya, and Leda\u2014for graciously bearing\u000d\u000alosing me to another book for a while.\u000d\u000a\u2014Robert de Graaf\u000d\u000aFirst Edition Acknowledgments\u000d\u000aThis book would not exist without all the support we\u2019ve received from a great many\u000d\u000apeople. I would like to thank my mother, Connie, to whom this book is dedicated.\u000d\u000aWithout your hard work and sacrifice, I would not be where I am today. Thank you\u000d\u000afor everything, Mom. I am thankful and appreciative of everything you\u2019ve done for\u000d\u000amy brother and me. I have been blessed to have you as my mother.\u000d\u000aPreface | xix","To my brother, Joe: Every time I came home from Baltimore to take a break from\u000d\u000awriting, you were there to remind me how great things are when we\u2019re not working,\u000d\u000aand how I should finish writing so I can get back to the more important things in life.\u000d\u000aYou\u2019re a good man, and I respect you. I am extremely proud of you, and proud to call\u000d\u000ayou my brother.\u000d\u000aTo my wonderful fianc\u00e9e, Georgia: Without your support I would not have made it\u000d\u000athrough all 600-plus pages of this book. You were here sharing this experience with\u000d\u000ame, day after day. I know it was just as hard on you as it was on me. I spent all day\u000d\u000aworking and all night writing, but you were great through it all. You were under\u2010\u000d\u000astanding and supportive, and I am forever grateful. Thank you. I love you.\u000d\u000aTo my future in-laws: To my mother-in-law and father-in-law, Kiki and George, thank\u000d\u000ayou for your support throughout this whole experience. You always made me feel at\u000d\u000ahome whenever I took a break and came to visit, and you made sure Georgia and I\u000d\u000awere always well fed. To my sister-in-laws, Anna and Kathy, it was always fun coming\u000d\u000ahome and hanging out with you guys, giving Georgia and I a much needed break\u000d\u000afrom the book and from Baltimore.\u000d\u000aTo my editor, Jonathan Gennick, without whom this book would not exist: Jonathan,\u000d\u000ayou deserve a tremendous amount of credit for this book. You went above and\u000d\u000abeyond what an editor would normally do, and for that you deserve much thanks.\u000d\u000aFrom supplying recipes to tons of rewrites to keeping things humorous despite\u000d\u000aoncoming deadlines, I could not have done it without you. I am grateful to have had\u000d\u000ayou as my editor and grateful for the opportunity you have given me. An experienced\u000d\u000aDBA and author yourself, it was a pleasure to work with someone of your technical\u000d\u000alevel and expertise. I can\u2019t imagine there are too many editors out there who can, if\u000d\u000athey decided to, stop editing and work practically anywhere as a database administra\u2010\u000d\u000ator (DBA); Jonathan can. Being a DBA certainly gives you an edge as an editor as you\u000d\u000ausually know what I want to say even when I\u2019m having trouble expressing it. O\u2019Reilly\u000d\u000ais lucky to have you on staff, and I am lucky to have you as an editor.\u000d\u000aI would like to thank Ales Spetic and Jonathan Gennick for Transact-SQL Cookbook.\u000d\u000aIsaac Newton famously said, \u201cIf I have seen a little further it is by standing on the\u000d\u000ashoulders of giants.\u201d In the acknowledgments section of the Transact-SQL Cookbook,\u000d\u000aAles Spetic wrote something that is a testament to this famous quote, and I feel\u000d\u000ashould be in every SQL book. I include his words here:\u000d\u000aI hope that this book will complement the exiting opuses of outstanding authors like\u000d\u000aJoe Celko, David Rozenshtein, Anatoly Abramovich, Eugine Berger, Iztik Ben-Gan,\u000d\u000aRichard Snodgrass, and others. I spent many nights studying their work, and I learned\u000d\u000aalmost everything I know from their books. As I am writing these lines, I\u2019m aware that\u000d\u000afor every night I spent discovering their secrets, they must have spent 10 nights putting\u000d\u000atheir knowledge into a consistent and readable form. It is an honor to be able to give\u000d\u000asomething back to the SQL community.\u000d\u000axx | Preface","I would like to thank Sanjay Mishra for his excellent Mastering Oracle SQL book, and\u000d\u000aalso for putting me in touch with Jonathan. If not for Sanjay, I may have never met\u000d\u000aJonathan and never would have written this book. Amazing how a simple email can\u000d\u000achange your life. I would like to thank David Rozenshtein, especially, for his Essence\u000d\u000aof SQL book, which provided me with a solid understanding of how to think and\u000d\u000aproblem solve in sets/SQL. I would like to thank David Rozenshtein, Anatoly Abra\u2010\u000d\u000amovich, and Eugene Birger for their book Optimizing Transact-SQL, from which I\u000d\u000alearned many of the advanced SQL techniques I use today.\u000d\u000aI would like to thank the whole team at Wireless Generation, a great company with\u000d\u000agreat people. A big thank-you to all of the people who took the time to review, cri\u2010\u000d\u000atique, or offer advice to help me complete this book: Jesse Davis, Joel Patterson, Philip\u000d\u000aZee, Kevin Marshall, Doug Daniels, Otis Gospodnetic, Ken Gunn, John Stewart, Jim\u000d\u000aAbramson, Adam Mayer, Susan Lau, Alexis Le-Quoc, and Paul Feuer. I would like to\u000d\u000athank Maggie Ho for her careful review of my work and extremely useful feedback\u000d\u000aregarding the window function refresher. I would like to thank Chuck Van Buren and\u000d\u000aGillian Gutenberg for their great advice about running. Early morning workouts hel\u2010\u000d\u000aped me clear my mind and unwind. I don\u2019t think I would have been able to finish this\u000d\u000abook without getting out a bit. I would like to thank Steve Kang and Chad Levinson\u000d\u000afor putting up with all my incessant talk about different SQL techniques on the nights\u000d\u000awhen all they wanted was to head to Union Square to get a beer and a burger at\u000d\u000aHeartland Brewery after a long day of work. I would like to thank Aaron Boyd for all\u000d\u000ahis support, kind words, and, most importantly, good advice. Aaron is honest, hard\u2010\u000d\u000aworking, and a very straightforward guy; people like him make a company better. I\u000d\u000awould like to thank Olivier Pomel for his support and help in writing this book, in\u000d\u000aparticular for the DB2 solution for creating delimited lists from rows. Olivier contrib\u2010\u000d\u000auted that solution without even having a DB2 system to test it! I explained to him\u000d\u000ahow the WITH clause worked, and minutes later he came up with the solution you\u000d\u000asee in this book.\u000d\u000aJonah Harris and David Rozenshtein also provided helpful technical review feedback\u000d\u000aon the manuscript. And Arun Marathe, Nuno Pinto do Souto, and Andrew Odewahn\u000d\u000aweighed in on the outline and choice of recipes while this book was in its formative\u000d\u000astages. Thanks, very much, to all of you.\u000d\u000aI want to thank John Haydu and the MODEL clause development team at Oracle\u000d\u000aCorporation for taking the time to review the MODEL clause article I wrote for\u000d\u000aO\u2019Reilly, and for ultimately giving me a better understanding of how that clause\u000d\u000aworks. I would like to thank Tom Kyte of Oracle Corporation for allowing me to\u000d\u000aadapt his TO_BASE function into a SQL-only solution. Bruno Denuit of Microsoft\u000d\u000aanswered questions I had regarding the functionality of the window functions intro\u2010\u000d\u000aduced in SQL Server 2005. Simon Riggs of PostgreSQL kept me up-to-date about new\u000d\u000aSQL features in PostgreSQL (very big thanks: Simon, by knowing what was coming\u000d\u000aout and when, I was able to incorporate some new SQL features such as the ever-soPreface | xxi","cool GENERATE_SERIES function, which I think made for more elegant solutions\u000d\u000acompared to pivot tables).\u000d\u000aLast but certainly not least, I\u2019d like to thank Kay Young. When you are talented and\u000d\u000apassionate about what you do, it is great to be able to work with people who are like\u2010\u000d\u000awise as talented and passionate. Many of the recipes you see in this text have come\u000d\u000afrom working with Kay and coming up with SQL solutions for everyday problems at\u000d\u000aWireless Generation. I want to thank you and let you know I absolutely appreciate all\u000d\u000athe help you have given me throughout all of this; from advice to grammar correc\u2010\u000d\u000ations to code, you played an integral role in the writing of this book. It\u2019s been great\u000d\u000aworking with you, and Wireless Generation is a better company because you are\u000d\u000athere.\u000d\u000a\u2014Anthony Molinaro\u000d\u000axxii | Preface","CHAPTER 1\u000d\u000aRetrieving Records\u000d\u000aThis chapter focuses on basic SELECT statements. It is important to have a solid\u000d\u000aunderstanding of the basics as many of the topics covered here are not only present in\u000d\u000amore difficult recipes but are also found in everyday SQL.\u000d\u000a1.1 Retrieving All Rows and Columns from a Table\u000d\u000aProblem\u000d\u000aYou have a table and want to see all of the data in it.\u000d\u000aSolution\u000d\u000aUse the special * character and issue a SELECT against the table:\u000d\u000a1 select *\u000d\u000a2 from emp\u000d\u000aDiscussion\u000d\u000aThe character * has special meaning in SQL. Using it will return every column for the\u000d\u000atable specified. Since there is no WHERE clause specified, every row will be returned\u000d\u000aas well. The alternative would be to list each column individually:\u000d\u000aselect empno,ename,job,sal,mgr,hiredate,comm,deptno\u000d\u000a from emp\u000d\u000aIn ad hoc queries that you execute interactively, it\u2019s easier to use SELECT *. However,\u000d\u000awhen writing program code, it\u2019s better to specify each column individually. The per\u2010\u000d\u000aformance will be the same, but by being explicit you will always know what columns\u000d\u000ayou are returning from the query. Likewise, such queries are easier to understand by\u000d\u000a1","people other than yourself (who may or may not know all the columns in the tables in\u000d\u000athe query). Problems with SELECT * can also arise if your query is within code, and\u000d\u000athe program gets a different set of columns from the query than was expected. At\u000d\u000aleast, if you specify all columns and one or more is missing, any error thrown is more\u000d\u000alikely to be traceable to the specific missing column(s).\u000d\u000a1.2 Retrieving a Subset of Rows from a Table\u000d\u000aProblem\u000d\u000aYou have a table and want to see only rows that satisfy a specific condition.\u000d\u000aSolution\u000d\u000aUse the WHERE clause to specify which rows to keep. For example, to view all\u000d\u000aemployees assigned to department number 10:\u000d\u000a1 select *\u000d\u000a2 from emp\u000d\u000a3 where deptno = 10\u000d\u000aDiscussion\u000d\u000aThe WHERE clause allows you to retrieve only rows you are interested in. If the\u000d\u000aexpression in the WHERE clause is true for any row, then that row is returned.\u000d\u000aMost vendors support common operators such as =, <, >, <=, >=, !, and <>. Addi\u2010\u000d\u000ationally, you may want rows that satisfy multiple conditions; this can be done by spec\u2010\u000d\u000aifying AND, OR, and parentheses, as shown in the next recipe.\u000d\u000a1.3 Finding Rows That Satisfy Multiple Conditions\u000d\u000aProblem\u000d\u000aYou want to return rows that satisfy multiple conditions.\u000d\u000aSolution\u000d\u000aUse the WHERE clause along with the OR and AND clauses. For example, if you\u000d\u000awould like to find all the employees in department 10, along with any employees who\u000d\u000aearn a commission, along with any employees in department 20 who earn at most\u000d\u000a$2,000:\u000d\u000a2 | Chapter 1: Retrieving Records","1 select *\u000d\u000a2 from emp\u000d\u000a3 where deptno = 10\u000d\u000a4 or comm is not null\u000d\u000a5 or sal <= 2000 and deptno=20\u000d\u000aDiscussion\u000d\u000aYou can use a combination of AND, OR, and parentheses to return rows that satisfy\u000d\u000amultiple conditions. In the solution example, the WHERE clause finds rows such\u000d\u000athat:\u000d\u000a\u2022 The DEPTNO is 10\u000d\u000a\u2022 The COMM is not NULL\u000d\u000a\u2022 The salary is $2,000 or less for any employee in DEPTNO 20.\u000d\u000aThe presence of parentheses causes conditions within them to be evaluated together.\u000d\u000aFor example, consider how the result set changes if the query was written with the\u000d\u000aparentheses as shown here:\u000d\u000aselect *\u000d\u000a from emp\u000d\u000awhere ( deptno = 10\u000d\u000a or comm is not null\u000d\u000a or sal <= 2000\u000d\u000a )\u000d\u000a and deptno=20\u000d\u000aEMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO\u000d\u000a----- ------ ----- ----- ----------- ----- ---------- ------\u000d\u000a 7369 SMITH CLERK 7902 17-DEC-1980 800 20\u000d\u000a 7876 ADAMS CLERK 7788 12-JAN-1983 1100 20\u000d\u000a1.4 Retrieving a Subset of Columns from a Table\u000d\u000aProblem\u000d\u000aYou have a table and want to see values for specific columns rather than for all the\u000d\u000acolumns.\u000d\u000aSolution\u000d\u000aSpecify the columns you are interested in. For example, to see only name, department\u000d\u000anumber, and salary for employees:\u000d\u000a1 select ename,deptno,sal\u000d\u000a2 from emp\u000d\u000a1.4 Retrieving a Subset of Columns from a Table | 3","Discussion\u000d\u000aBy specifying the columns in the SELECT clause, you ensure that no extraneous data\u000d\u000ais returned. This can be especially important when retrieving data across a network,\u000d\u000aas it avoids the waste of time inherent in retrieving data that you do not need.\u000d\u000a1.5 Providing Meaningful Names for Columns\u000d\u000aProblem\u000d\u000aYou would like to change the names of the columns that are returned by your query\u000d\u000aso they are more readable and understandable. Consider this query that returns the\u000d\u000asalaries and commissions for each employee:\u000d\u000a1 select sal,comm\u000d\u000a2 from emp\u000d\u000aWhat\u2019s SAL? Is it short for sale? Is it someone\u2019s name? What\u2019s COMM? Is it communi\u2010\u000d\u000acation? You want the results to have more meaningful labels.\u000d\u000aSolution\u000d\u000aTo change the names of your query results, use the AS keyword in the form\u000d\u000aoriginal_name AS new_name. Some databases do not require AS, but all accept it:\u000d\u000a 1 select sal as salary, comm as commission\u000d\u000a 2 from emp\u000d\u000aSALARY COMMISSION\u000d\u000a------- ----------\u000d\u000a 800\u000d\u000a 1600 300\u000d\u000a 1250 500\u000d\u000a 2975\u000d\u000a 1250 1400\u000d\u000a 2850\u000d\u000a 2450\u000d\u000a 3000\u000d\u000a 5000\u000d\u000a 1500 0\u000d\u000a 1100\u000d\u000a 950\u000d\u000a 3000\u000d\u000a 1300\u000d\u000aDiscussion\u000d\u000aUsing the AS keyword to give new names to columns returned by your query is\u000d\u000aknown as aliasing those columns. The new names that you give are known as aliases.\u000d\u000a4 | Chapter 1: Retrieving Records","Creating good aliases can go a long way toward making a query and its results under\u2010\u000d\u000astandable to others.\u000d\u000a1.6 Referencing an Aliased Column in the WHERE Clause\u000d\u000aProblem\u000d\u000aYou have used aliases to provide more meaningful column names for your result set\u000d\u000aand would like to exclude some of the rows using the WHERE clause. However, your\u000d\u000aattempt to reference alias names in the WHERE clause fails:\u000d\u000aselect sal as salary, comm as commission\u000d\u000a from emp\u000d\u000a where salary < 5000\u000d\u000aSolution\u000d\u000aBy wrapping your query as an inline view, you can reference the aliased columns:\u000d\u000a1 select *\u000d\u000a2 from (\u000d\u000a3 select sal as salary, comm as commission\u000d\u000a4 from emp\u000d\u000a5 ) x\u000d\u000a6 where salary < 5000\u000d\u000aDiscussion\u000d\u000aIn this simple example, you can avoid the inline view and reference COMM or SAL\u000d\u000adirectly in the WHERE clause to achieve the same result. This solution introduces\u000d\u000ayou to what you would need to do when attempting to reference any of the following\u000d\u000ain a WHERE clause:\u000d\u000a\u2022 Aggregate functions\u000d\u000a\u2022 Scalar subqueries\u000d\u000a\u2022 Windowing functions\u000d\u000a\u2022 Aliases\u000d\u000aPlacing your query, the one giving aliases, in an inline view gives you the ability to\u000d\u000areference the aliased columns in your outer query. Why do you need to do this? The\u000d\u000aWHERE clause is evaluated before the SELECT; thus, SALARY and COMMISSION\u000d\u000ado not yet exist when the \u201cProblem\u201d query\u2019s WHERE clause is evaluated. Those\u000d\u000aaliases are not applied until after the WHERE clause processing is complete. How\u2010\u000d\u000aever, the FROM clause is evaluated before the WHERE. By placing the original query\u000d\u000ain a FROM clause, the results from that query are generated before the outermost\u000d\u000a1.6 Referencing an Aliased Column in the WHERE Clause | 5","WHERE clause, and your outermost WHERE clause \u201csees\u201d the alias names. This tech\u2010\u000d\u000anique is particularly useful when the columns in a table are not named particularly\u000d\u000awell.\u000d\u000aThe inline view in this solution is aliased X. Not all databases\u000d\u000arequire an inline view to be explicitly aliased, but some do. All of\u000d\u000athem accept it.\u000d\u000a1.7 Concatenating Column Values\u000d\u000aProblem\u000d\u000aYou want to return values in multiple columns as one column. For example, you\u000d\u000awould like to produce this result set from a query against the EMP table:\u000d\u000aCLARK WORKS AS A MANAGER\u000d\u000aKING WORKS AS A PRESIDENT\u000d\u000aMILLER WORKS AS A CLERK\u000d\u000aHowever, the data that you need to generate this result set comes from two different\u000d\u000acolumns, the ENAME and JOB columns in the EMP table:\u000d\u000a select ename, job\u000d\u000a from emp\u000d\u000a where deptno = 10\u000d\u000aENAME JOB\u000d\u000a---------- ---------\u000d\u000aCLARK MANAGER\u000d\u000aKING PRESIDENT\u000d\u000aMILLER CLERK\u000d\u000aSolution\u000d\u000aFind and use the built-in function provided by your DBMS to concatenate values\u000d\u000afrom multiple columns.\u000d\u000aDB2, Oracle, PostgreSQL\u000d\u000aThese databases use the double vertical bar as the concatenation operator:\u000d\u000a1 select ename||' WORKS AS A '||job as msg\u000d\u000a2 from emp\u000d\u000a3 where deptno=10\u000d\u000a6 | Chapter 1: Retrieving Records","MySQL\u000d\u000aThis database supports a function called CONCAT:\u000d\u000a1 select concat(ename, ' WORKS AS A ',job) as msg\u000d\u000a2 from emp\u000d\u000a3 where deptno=10\u000d\u000aSQL Server\u000d\u000aUse the + operator for concatenation:\u000d\u000a1 select ename + ' WORKS AS A ' + job as msg\u000d\u000a2 from emp\u000d\u000a3 where deptno=10\u000d\u000aDiscussion\u000d\u000aUse the CONCAT function to concatenate values from multiple columns. The || is a\u000d\u000ashortcut for the CONCAT function in DB2, Oracle, and PostgreSQL, while + is the\u000d\u000ashortcut for SQL Server.\u000d\u000a1.8 Using Conditional Logic in a SELECT Statement\u000d\u000aProblem\u000d\u000aYou want to perform IF-ELSE operations on values in your SELECT statement. For\u000d\u000aexample, you would like to produce a result set such that if an employee is paid\u000d\u000a$2,000 or less, a message of \u201cUNDERPAID\u201d is returned; if an employee is paid $4,000\u000d\u000aor more, a message of \u201cOVERPAID\u201d is returned; and if they make somewhere in\u000d\u000abetween, then \u201cOK\u201d is returned. The result set should look like this:\u000d\u000a ENAME SAL STATUS\u000d\u000a---------- ---------- ---------\u000d\u000aSMITH 800 UNDERPAID\u000d\u000aALLEN 1600 UNDERPAID\u000d\u000aWARD 1250 UNDERPAID\u000d\u000aJONES 2975 OK\u000d\u000aMARTIN 1250 UNDERPAID\u000d\u000aBLAKE 2850 OK\u000d\u000aCLARK 2450 OK\u000d\u000aSCOTT 3000 OK\u000d\u000aKING 5000 OVERPAID\u000d\u000aTURNER 1500 UNDERPAID\u000d\u000aADAMS 1100 UNDERPAID\u000d\u000aJAMES 950 UNDERPAID\u000d\u000aFORD 3000 OK\u000d\u000aMILLER 1300 UNDERPAID\u000d\u000a1.8 Using Conditional Logic in a SELECT Statement | 7","Solution\u000d\u000aUse the CASE expression to perform conditional logic directly in your SELECT\u000d\u000astatement:\u000d\u000a1 select ename,sal,\u000d\u000a2 case when sal <= 2000 then 'UNDERPAID'\u000d\u000a3 when sal >= 4000 then 'OVERPAID'\u000d\u000a4 else 'OK'\u000d\u000a5 end as status\u000d\u000a6 from emp\u000d\u000aDiscussion\u000d\u000aThe CASE expression allows you to perform condition logic on values returned by a\u000d\u000aquery. You can provide an alias for a CASE expression to return a more readable\u000d\u000aresult set. In the solution, you\u2019ll see the alias STATUS given to the result of the CASE\u000d\u000aexpression. The ELSE clause is optional. Omit the ELSE, and the CASE expression\u000d\u000awill return NULL for any row that does not satisfy the test condition.\u000d\u000a1.9 Limiting the Number of Rows Returned\u000d\u000aProblem\u000d\u000aYou want to limit the number of rows returned in your query. You are not concerned\u000d\u000awith order; any n rows will do.\u000d\u000aSolution\u000d\u000aUse the built-in function provided by your database to control the number of rows\u000d\u000areturned.\u000d\u000aDB2\u000d\u000aIn DB2 use the FETCH FIRST clause:\u000d\u000a1 select *\u000d\u000a2 from emp fetch first 5 rows only\u000d\u000aMySQL and PostgreSQL\u000d\u000aDo the same thing in MySQL and PostgreSQL using LIMIT:\u000d\u000a1 select *\u000d\u000a2 from emp limit 5\u000d\u000a8 | Chapter 1: Retrieving Records","Oracle\u000d\u000aIn Oracle, place a restriction on the number of rows returned by restricting ROW\u2010\u000d\u000aNUM in the WHERE clause:\u000d\u000a1 select *\u000d\u000a2 from emp\u000d\u000a3 where rownum <= 5\u000d\u000aSQL Server\u000d\u000aUse the TOP keyword to restrict the number of rows returned:\u000d\u000a1 select top 5 *\u000d\u000a2 from emp\u000d\u000aDiscussion\u000d\u000aMany vendors provide clauses such as FETCH FIRST and LIMIT that let you specify\u000d\u000athe number of rows to be returned from a query. Oracle is different, in that you must\u000d\u000amake use of a function called ROWNUM that returns a number for each row\u000d\u000areturned (an increasing value starting from one).\u000d\u000aHere is what happens when you use ROWNUM <= 5 to return the first five rows:\u000d\u000a1. Oracle executes your query.\u000d\u000a2. Oracle fetches the first row and calls it row number one.\u000d\u000a3. Have we gotten past row number five yet? If no, then Oracle returns the row,\u000d\u000abecause it meets the criteria of being numbered less than or equal to five. If yes,\u000d\u000athen Oracle does not return the row.\u000d\u000a4. Oracle fetches the next row and advances the row number (to two, then to three,\u000d\u000athen to four, and so forth).\u000d\u000a5. Go to step 3.\u000d\u000aAs this process shows, values from Oracle\u2019s ROWNUM are assigned a\u0083er each row is\u000d\u000afetched. This is an important and key point. Many Oracle developers attempt to\u000d\u000areturn only, say, the fifth row returned by a query by specifying ROWNUM = 5.\u000d\u000aUsing an equality condition in conjunction with ROWNUM is a bad idea. Here is\u000d\u000awhat happens when you try to return, say, the fifth row using ROWNUM = 5:\u000d\u000a1. Oracle executes your query.\u000d\u000a2. Oracle fetches the first row and calls it row number one.\u000d\u000a3. Have we gotten to row number five yet? If no, then Oracle discards the row,\u000d\u000abecause it doesn\u2019t meet the criteria. If yes, then Oracle returns the row. But the\u000d\u000aanswer will never be yes!\u000d\u000a1.9 Limiting the Number of Rows Returned | 9","4. Oracle fetches the next row and calls it row number one. This is because the first\u000d\u000arow to be returned from the query must be numbered as one.\u000d\u000a5. Go to step 3.\u000d\u000aStudy this process closely, and you can see why the use of ROWNUM = 5 to return\u000d\u000athe fifth row fails. You can\u2019t have a fifth row if you don\u2019t first return rows one through\u000d\u000afour!\u000d\u000aYou may notice that ROWNUM = 1 does, in fact, work to return the first row, which\u000d\u000amay seem to contradict the explanation thus far. The reason ROWNUM = 1 works to\u000d\u000areturn the first row is that, to determine whether there are any rows in the table, Ora\u2010\u000d\u000acle has to attempt to fetch at least once. Read the preceding process carefully, substi\u2010\u000d\u000atuting one for five, and you\u2019ll understand why it\u2019s OK to specify ROWNUM = 1 as a\u000d\u000acondition (for returning one row).\u000d\u000a1.10 Returning n Random Records from a Table\u000d\u000aProblem\u000d\u000aYou want to return a specific number of random records from a table. You want to\u000d\u000amodify the following statement such that successive executions will produce a differ\u2010\u000d\u000aent set of five rows:\u000d\u000aselect ename, job\u000d\u000a from emp\u000d\u000aSolution\u000d\u000aTake any built-in function supported by your DBMS for returning random values.\u000d\u000aUse that function in an ORDER BY clause to sort rows randomly. Then, use the pre\u2010\u000d\u000avious recipe\u2019s technique to limit the number of randomly sorted rows to return.\u000d\u000aDB2\u000d\u000aUse the built-in function RAND in conjunction with ORDER BY and FETCH:\u000d\u000a1 select ename,job\u000d\u000a2 from emp\u000d\u000a3 order by rand() fetch first 5 rows only\u000d\u000aMySQL\u000d\u000aUse the built-in RAND function in conjunction with LIMIT and ORDER BY:\u000d\u000a1 select ename,job\u000d\u000a2 from emp\u000d\u000a3 order by rand() limit 5\u000d\u000a10 | Chapter 1: Retrieving Records","PostgreSQL\u000d\u000aUse the built-in RANDOM function in conjunction with LIMIT and ORDER BY:\u000d\u000a 1 select ename,job\u000d\u000a2 from emp\u000d\u000a3 order by random() limit 5\u000d\u000aOracle\u000d\u000aUse the built-in function VALUE, found in the built-in package DBMS_RANDOM,\u000d\u000ain conjunction with ORDER BY and the built-in function ROWNUM:\u000d\u000a1 select *\u000d\u000a2 from (\u000d\u000a3 select ename, job\u000d\u000a4 from emp\u000d\u000a6 order by dbms_random.value()\u000d\u000a7 )\u000d\u000a8 where rownum <= 5\u000d\u000aSQL Server\u000d\u000aUse the built-in function NEWID in conjunction with TOP and ORDER BY to\u000d\u000areturn a random result set:\u000d\u000a1 select top 5 ename,job\u000d\u000a2 from emp\u000d\u000a3 order by newid()\u000d\u000aDiscussion\u000d\u000aThe ORDER BY clause can accept a function\u2019s return value and use it to change the\u000d\u000aorder of the result set. These solutions all restrict the number of rows to return a\u0083er\u000d\u000athe function in the ORDER BY clause is executed. Non-Oracle users may find it help\u2010\u000d\u000aful to look at the Oracle solution as it shows (conceptually) what is happening under\u000d\u000athe covers of the other solutions.\u000d\u000aIt is important that you don\u2019t confuse using a function in the ORDER BY clause with\u000d\u000ausing a numeric constant. When specifying a numeric constant in the ORDER BY\u000d\u000aclause, you are requesting that the sort be done according the column in that ordinal\u000d\u000aposition in the SELECT list. When you specify a function in the ORDER BY clause,\u000d\u000athe sort is performed on the result from the function as it is evaluated for each row.\u000d\u000a1.11 Finding Null Values\u000d\u000aProblem\u000d\u000aYou want to find all rows that are null for a particular column.\u000d\u000a1.11 Finding Null Values | 11","Solution\u000d\u000aTo determine whether a value is null, you must use IS NULL:\u000d\u000a1 select *\u000d\u000a2 from emp\u000d\u000a3 where comm is null\u000d\u000aDiscussion\u000d\u000aNULL is never equal/not equal to anything, not even itself; therefore, you cannot use\u000d\u000a= or != for testing whether a column is NULL. To determine whether a row has\u000d\u000aNULL values, you must use IS NULL. You can also use IS NOT NULL to find rows\u000d\u000awithout a null in a given column.\u000d\u000a1.12 Transforming Nulls into Real Values\u000d\u000aProblem\u000d\u000aYou have rows that contain nulls and would like to return non-null values in place of\u000d\u000athose nulls.\u000d\u000aSolution\u000d\u000aUse the function COALESCE to substitute real values for nulls:\u000d\u000a1 select coalesce(comm,0)\u000d\u000a2 from emp\u000d\u000aDiscussion\u000d\u000aThe COALESCE function takes one or more values as arguments. The function\u000d\u000areturns the first non-null value in the list. In the solution, the value of COMM is\u000d\u000areturned whenever COMM is not null. Otherwise, a zero is returned.\u000d\u000aWhen working with nulls, it\u2019s best to take advantage of the built-in functionality pro\u2010\u000d\u000avided by your DBMS; in many cases you\u2019ll find several functions work equally as well\u000d\u000afor this task. COALESCE happens to work for all DBMSs. Additionally, CASE can be\u000d\u000aused for all DBMSs as well:\u000d\u000aselect case\u000d\u000a when comm is not null then comm\u000d\u000a else 0\u000d\u000a end\u000d\u000a from emp\u000d\u000aWhile you can use CASE to translate nulls into values, you can see that it\u2019s much eas\u2010\u000d\u000aier and more succinct to use COALESCE.\u000d\u000a12 | Chapter 1: Retrieving Records","1.13 Searching for Patterns\u000d\u000aProblem\u000d\u000aYou want to return rows that match a particular substring or pattern. Consider the\u000d\u000afollowing query and result set:\u000d\u000aselect ename, job\u000d\u000a from emp\u000d\u000a where deptno in (10,20)\u000d\u000aENAME JOB\u000d\u000a---------- ---------\u000d\u000aSMITH CLERK\u000d\u000aJONES MANAGER\u000d\u000aCLARK MANAGER\u000d\u000aSCOTT ANALYST\u000d\u000aKING PRESIDENT\u000d\u000aADAMS CLERK\u000d\u000aFORD ANALYST\u000d\u000aMILLER CLERK\u000d\u000aOf the employees in departments 10 and 20, you want to return only those that have\u000d\u000aeither an \u201cI\u201d somewhere in their name or a job title ending with \u201cER\u201d:\u000d\u000aENAME JOB\u000d\u000a---------- ---------\u000d\u000aSMITH CLERK\u000d\u000aJONES MANAGER\u000d\u000aCLARK MANAGER\u000d\u000aKING PRESIDENT\u000d\u000aMILLER CLERK\u000d\u000aSolution\u000d\u000aUse the LIKE operator in conjunction with the SQL wildcard operator (%):\u000d\u000a1 select ename, job\u000d\u000a2 from emp\u000d\u000a3 where deptno in (10,20)\u000d\u000a4 and (ename like '%I%' or job like '%ER')\u000d\u000aDiscussion\u000d\u000aWhen used in a LIKE pattern-match operation, the percent (%) operator matches any\u000d\u000asequence of characters. Most SQL implementations also provide the underscore (\u201c_\u201d)\u000d\u000aoperator to match a single character. By enclosing the search pattern \u201cI\u201d with % oper\u2010\u000d\u000aators, any string that contains an \u201cI\u201d (at any position) will be returned. If you do not\u000d\u000aenclose the search pattern with %, then where you place the operator will affect the\u000d\u000aresults of the query. For example, to find job titles that end in \u201cER,\u201d prefix the %\u000d\u000a1.13 Searching for Patterns | 13","operator to \u201cER\u201d; if the requirement is to search for all job titles beginning with \u201cER,\u201d\u000d\u000athen append the % operator to \u201cER.\u201d\u000d\u000a1.14 Summing Up\u000d\u000aThese recipes may be simple, but they are also fundamental. Information retrieval is\u000d\u000athe core of database querying, and that means these recipes are at the heart of virtu\u2010\u000d\u000aally everything that is discussed throughout the rest of the book.\u000d\u000a14 | Chapter 1: Retrieving Records","CHAPTER 2\u000d\u000aSorting Query Results\u000d\u000aThis chapter focuses on customizing how your query results look. By understanding\u000d\u000ahow to control how your result set is organized, you can provide more readable and\u000d\u000ameaningful data.\u000d\u000a2.1 Returning Query Results in a Specified Order\u000d\u000aProblem\u000d\u000aYou want to display the names, jobs, and salaries of employees in department 10 in\u000d\u000aorder based on their salary (from lowest to highest). You want to return the following\u000d\u000aresult set:\u000d\u000aENAME JOB SAL\u000d\u000a---------- --------- ----------\u000d\u000aMILLER CLERK 1300\u000d\u000aCLARK MANAGER 2450\u000d\u000aKING PRESIDENT 5000\u000d\u000aSolution\u000d\u000aUse the ORDER BY clause:\u000d\u000a1 select ename,job,sal\u000d\u000a2 from emp\u000d\u000a3 where deptno = 10\u000d\u000a4 order by sal asc\u000d\u000aDiscussion\u000d\u000aThe ORDER BY clause allows you to order the rows of your result set. The solution\u000d\u000asorts the rows based on SAL in ascending order. By default, ORDER BY will sort in\u000d\u000a15","ascending order, and the ASC clause is therefore optional. Alternatively, specify\u000d\u000aDESC to sort in descending order:\u000d\u000aselect ename,job,sal\u000d\u000a from emp\u000d\u000a where deptno = 10\u000d\u000a order by sal desc\u000d\u000aENAME JOB SAL\u000d\u000a---------- --------- ----------\u000d\u000aKING PRESIDENT 5000\u000d\u000aCLARK MANAGER 2450\u000d\u000aMILLER CLERK 1300\u000d\u000aYou need not specify the name of the column on which to sort. You can instead spec\u2010\u000d\u000aify a number representing the column. The number starts at 1 and matches the items\u000d\u000ain the SELECT list from left to right. For example:\u000d\u000aselect ename,job,sal\u000d\u000a from emp\u000d\u000a where deptno = 10\u000d\u000a order by 3 desc\u000d\u000aENAME JOB SAL\u000d\u000a---------- --------- ----------\u000d\u000aKING PRESIDENT 5000\u000d\u000aCLARK MANAGER 2450\u000d\u000aMILLER CLERK 1300\u000d\u000aThe number 3 in this example\u2019s ORDER BY clause corresponds to the third column\u000d\u000ain the SELECT list, which is SAL.\u000d\u000a2.2 Sorting by Multiple Fields\u000d\u000aProblem\u000d\u000aYou want to sort the rows from EMP first by DEPTNO ascending, then by salary\u000d\u000adescending. You want to return the following result set:\u000d\u000a EMPNO DEPTNO SAL ENAME JOB\u000d\u000a---------- ---------- ---------- ---------- ---------\u000d\u000a 7839 10 5000 KING PRESIDENT\u000d\u000a 7782 10 2450 CLARK MANAGER\u000d\u000a 7934 10 1300 MILLER CLERK\u000d\u000a 7788 20 3000 SCOTT ANALYST\u000d\u000a 7902 20 3000 FORD ANALYST\u000d\u000a 7566 20 2975 JONES MANAGER\u000d\u000a 7876 20 1100 ADAMS CLERK\u000d\u000a 7369 20 800 SMITH CLERK\u000d\u000a 7698 30 2850 BLAKE MANAGER\u000d\u000a 7499 30 1600 ALLEN SALESMAN\u000d\u000a16 | Chapter 2: Sorting Query Results"," 7844 30 1500 TURNER SALESMAN\u000d\u000a 7521 30 1250 WARD SALESMAN\u000d\u000a 7654 30 1250 MARTIN SALESMAN\u000d\u000a 7900 30 950 JAMES CLERK\u000d\u000aSolution\u000d\u000aList the different sort columns in the ORDER BY clause, separated by commas:\u000d\u000a1 select empno,deptno,sal,ename,job\u000d\u000a2 from emp\u000d\u000a3 order by deptno, sal desc\u000d\u000aDiscussion\u000d\u000aThe order of precedence in ORDER BY is from left to right. If you are ordering using\u000d\u000athe numeric position of a column in the SELECT list, then that number must not be\u000d\u000agreater than the number of items in the SELECT list. You are generally permitted to\u000d\u000aorder by a column not in the SELECT list, but to do so you must explicitly name the\u000d\u000acolumn. However, if you are using GROUP BY or DISTINCT in your query, you can\u2010\u000d\u000anot order by columns that are not in the SELECT list.\u000d\u000a2.3 Sorting by Substrings\u000d\u000aProblem\u000d\u000aYou want to sort the results of a query by specific parts of a string. For example, you\u000d\u000awant to return employee names and jobs from table EMP and sort by the last two\u000d\u000acharacters in the JOB field. The result set should look like the following:\u000d\u000aENAME JOB\u000d\u000a---------- ---------\u000d\u000aKING PRESIDENT\u000d\u000aSMITH CLERK\u000d\u000aADAMS CLERK\u000d\u000aJAMES CLERK\u000d\u000aMILLER CLERK\u000d\u000aJONES MANAGER\u000d\u000aCLARK MANAGER\u000d\u000aBLAKE MANAGER\u000d\u000aALLEN SALESMAN\u000d\u000aMARTIN SALESMAN\u000d\u000aWARD SALESMAN\u000d\u000aTURNER SALESMAN\u000d\u000aSCOTT ANALYST\u000d\u000aFORD ANALYST\u000d\u000a2.3 Sorting by Substrings | 17","Solution\u000d\u000aDB2, MySQL, Oracle, and PostgreSQL\u000d\u000aUse the SUBSTR function in the ORDER BY clause:\u000d\u000aselect ename,job\u000d\u000a from emp\u000d\u000a order by substr(job,length(job)-1)\u000d\u000aSQL Server\u000d\u000aUse the SUBSTRING function in the ORDER BY clause:\u000d\u000aselect ename,job\u000d\u000a from emp\u000d\u000a order by substring(job,len(job)-1,2)\u000d\u000aDiscussion\u000d\u000aUsing your DBMS\u2019s substring function, you can easily sort by any part of a string. To\u000d\u000asort by the last two characters of a string, find the end of the string (which is the\u000d\u000alength of the string) and subtract two. The start position will be the second to last\u000d\u000acharacter in the string. You then take all characters after that start position. SQL Serv\u2010\u000d\u000aer\u2019s SUBSTRING is different from the SUBSTR function as it requires a third parame\u2010\u000d\u000ater that specifies how many characters to take. In this example, any number greater\u000d\u000athan or equal to two will work.\u000d\u000a2.4 Sorting Mixed Alphanumeric Data\u000d\u000aProblem\u000d\u000aYou have mixed alphanumeric data and want to sort by either the numeric or charac\u2010\u000d\u000ater portion of the data. Consider this view, created from the EMP table:\u000d\u000acreate view V\u000d\u000aas\u000d\u000aselect ename||' '||deptno as data\u000d\u000a from emp\u000d\u000aselect * from V\u000d\u000aDATA\u000d\u000a-------------\u000d\u000aSMITH 20\u000d\u000aALLEN 30\u000d\u000aWARD 30\u000d\u000aJONES 20\u000d\u000aMARTIN 30\u000d\u000a18 | Chapter 2: Sorting Query Results","BLAKE 30\u000d\u000aCLARK 10\u000d\u000aSCOTT 20\u000d\u000aKING 10\u000d\u000aTURNER 30\u000d\u000aADAMS 20\u000d\u000aJAMES 30\u000d\u000aFORD 20\u000d\u000aMILLER 10\u000d\u000aYou want to sort the results by DEPTNO or ENAME. Sorting by DEPTNO produces\u000d\u000athe following result set:\u000d\u000aDATA\u000d\u000a----------\u000d\u000aCLARK 10\u000d\u000aKING 10\u000d\u000aMILLER 10\u000d\u000aSMITH 20\u000d\u000aADAMS 20\u000d\u000aFORD 20\u000d\u000aSCOTT 20\u000d\u000aJONES 20\u000d\u000aALLEN 30\u000d\u000aBLAKE 30\u000d\u000aMARTIN 30\u000d\u000aJAMES 30\u000d\u000aTURNER 30\u000d\u000aWARD 30\u000d\u000aSorting by ENAME produces the following result set:\u000d\u000aDATA\u000d\u000a---------\u000d\u000aADAMS 20\u000d\u000aALLEN 30\u000d\u000aBLAKE 30\u000d\u000aCLARK 10\u000d\u000aFORD 20\u000d\u000aJAMES 30\u000d\u000aJONES 20\u000d\u000aKING 10\u000d\u000aMARTIN 30\u000d\u000aMILLER 10\u000d\u000aSCOTT 20\u000d\u000aSMITH 20\u000d\u000aTURNER 30\u000d\u000aWARD 30\u000d\u000a2.4 Sorting Mixed Alphanumeric Data | 19","Solution\u000d\u000aOracle, SQL Server, and PostgreSQL\u000d\u000aUse the functions REPLACE and TRANSLATE to modify the string for sorting:\u000d\u000a/* ORDER BY DEPTNO */\u000d\u000a1 select data\u000d\u000a2 from V\u000d\u000a3 order by replace(data,\u000d\u000a4 replace(\u000d\u000a5 translate(data,'0123456789','##########'),'#',''),'')\u000d\u000a/* ORDER BY ENAME */\u000d\u000a1 select data\u000d\u000a2 from V\u000d\u000a3 order by replace(\u000d\u000a4 translate(data,'0123456789','##########'),'#','')\u000d\u000aDB2\u000d\u000aImplicit type conversion is more strict in DB2 than in Oracle or PostgreSQL, so you\u000d\u000awill need to cast DEPTNO to a CHAR for view V to be valid. Rather than re-create\u000d\u000aview V, this solution will simply use an inline view. The solution uses REPLACE and\u000d\u000aTRANSLATE in the same way as the Oracle and PostrgreSQL solution, but the order\u000d\u000aof arguments for TRANSLATE is slightly different for DB2:\u000d\u000a/* ORDER BY DEPTNO */\u000d\u000a1 select *\u000d\u000a2 from (\u000d\u000a3 select ename||' '||cast(deptno as char(2)) as data\u000d\u000a4 from emp\u000d\u000a5 ) v\u000d\u000a6 order by replace(data,\u000d\u000a7 replace(\u000d\u000a8 translate(data,'##########','0123456789'),'#',''),'')\u000d\u000a/* ORDER BY ENAME */\u000d\u000a1 select *\u000d\u000a2 from (\u000d\u000a3 select ename||' '||cast(deptno as char(2)) as data\u000d\u000a4 from emp\u000d\u000a5 ) v\u000d\u000a6 order by replace(\u000d\u000a7 translate(data,'##########','0123456789'),'#','')\u000d\u000a20 | Chapter 2: Sorting Query Results","MySQL\u000d\u000aThe TRANSLATE function is not currently supported by these platforms; thus, a sol\u2010\u000d\u000aution for this problem will not be provided.\u000d\u000aDiscussion\u000d\u000aThe TRANSLATE and REPLACE functions remove either the numbers or characters\u000d\u000afrom each row, allowing you to easily sort by one or the other. The values passed to\u000d\u000aORDER BY are shown in the following query results (using the Oracle solution as the\u000d\u000aexample, as the same technique applies to all three vendors; only the order of param\u2010\u000d\u000aeters passed to TRANSLATE is what sets DB2 apart):\u000d\u000aselect data,\u000d\u000a replace(data,\u000d\u000a replace(\u000d\u000a translate(data,'0123456789','##########'),'#',''),'') nums,\u000d\u000a replace(\u000d\u000a translate(data,'0123456789','##########'),'#','') chars\u000d\u000a from V\u000d\u000aDATA NUMS CHARS\u000d\u000a------------ ------ ----------\u000d\u000aSMITH 20 20 SMITH\u000d\u000aALLEN 30 30 ALLEN\u000d\u000aWARD 30 30 WARD\u000d\u000aJONES 20 20 JONES\u000d\u000aMARTIN 30 30 MARTIN\u000d\u000aBLAKE 30 30 BLAKE\u000d\u000aCLARK 10 10 CLARK\u000d\u000aSCOTT 20 20 SCOTT\u000d\u000aKING 10 10 KING\u000d\u000aTURNER 30 30 TURNER\u000d\u000aADAMS 20 20 ADAMS\u000d\u000aJAMES 30 30 JAMES\u000d\u000aFORD 20 20 FORD\u000d\u000aMILLER 10 10 MILLER\u000d\u000a2.5 Dealing with Nulls When Sorting\u000d\u000aProblem\u000d\u000aYou want to sort results from EMP by COMM, but the field is nullable. You need a\u000d\u000away to specify whether nulls sort last:\u000d\u000aENAME SAL COMM\u000d\u000a---------- ---------- ----------\u000d\u000aTURNER 1500 0\u000d\u000aALLEN 1600 300\u000d\u000aWARD 1250 500\u000d\u000a2.5 Dealing with Nulls When Sorting | 21","MARTIN 1250 1400\u000d\u000aSMITH 800\u000d\u000aJONES 2975\u000d\u000aJAMES 950\u000d\u000aMILLER 1300\u000d\u000aFORD 3000\u000d\u000aADAMS 1100\u000d\u000aBLAKE 2850\u000d\u000aCLARK 2450\u000d\u000aSCOTT 3000\u000d\u000aKING 5000\u000d\u000aor whether they sort first:\u000d\u000aENAME SAL COMM\u000d\u000a---------- ---------- ----------\u000d\u000aSMITH 800\u000d\u000aJONES 2975\u000d\u000aCLARK 2450\u000d\u000aBLAKE 2850\u000d\u000aSCOTT 3000\u000d\u000aKING 5000\u000d\u000aJAMES 950\u000d\u000aMILLER 1300\u000d\u000aFORD 3000\u000d\u000aADAMS 1100\u000d\u000aMARTIN 1250 1400\u000d\u000aWARD 1250 500\u000d\u000aALLEN 1600 300\u000d\u000aTURNER 1500 0\u000d\u000aSolution\u000d\u000aDepending on how you want the data to look and how your particular RDBMS sorts\u000d\u000aNULL values, you can sort the nullable column in ascending or descending order:\u000d\u000a1 select ename,sal,comm\u000d\u000a2 from emp\u000d\u000a3 order by 3\u000d\u000a1 select ename,sal,comm\u000d\u000a2 from emp\u000d\u000a3 order by 3 desc\u000d\u000aThis solution puts you in a position such that if the nullable column contains nonNULL values, they will be sorted in ascending or descending order as well, according\u000d\u000ato what you ask for; this may or may not be what you have in mind. If instead you\u000d\u000awould like to sort NULL values differently than non-NULL values, for example, you\u000d\u000awant to sort non-NULL values in ascending or descending order and all NULL values\u000d\u000alast, you can use a CASE expression to conditionally sort the column.\u000d\u000a22 | Chapter 2: Sorting Query Results","DB2, MySQL, PostgreSQL, and SQL Server\u000d\u000aUse a CASE expression to \u201cflag\u201d when a value is NULL. The idea is to have a flag with\u000d\u000atwo values: one to represent NULLs, the other to represent non-NULLs. Once you\u000d\u000ahave that, simply add this flag column to the ORDER BY clause. You\u2019ll easily be able\u000d\u000ato control whether NULL values are sorted first or last without interfering with nonNULL values:\u000d\u000a/* NON-NULL COMM SORTED ASCENDING, ALL NULLS LAST */\u000d\u000a1 select ename,sal,comm\u000d\u000a2 from (\u000d\u000a3 select ename,sal,comm,\u000d\u000a4 case when comm is null then 0 else 1 end as is_null\u000d\u000a5 from emp\u000d\u000a6 ) x\u000d\u000a7 order by is_null desc,comm\u000d\u000aENAME SAL COMM\u000d\u000a------ ----- ----------\u000d\u000aTURNER 1500 0\u000d\u000aALLEN 1600 300\u000d\u000aWARD 1250 500\u000d\u000aMARTIN 1250 1400\u000d\u000aSMITH 800\u000d\u000aJONES 2975\u000d\u000aJAMES 950\u000d\u000aMILLER 1300\u000d\u000aFORD 3000\u000d\u000aADAMS 1100\u000d\u000aBLAKE 2850\u000d\u000aCLARK 2450\u000d\u000aSCOTT 3000\u000d\u000aKING 5000\u000d\u000a/* NON-NULL COMM SORTED DESCENDING, ALL NULLS LAST */\u000d\u000a1 select ename,sal,comm\u000d\u000a2 from (\u000d\u000a3 select ename,sal,comm,\u000d\u000a4 case when comm is null then 0 else 1 end as is_null\u000d\u000a5 from emp\u000d\u000a6 ) x\u000d\u000a7 order by is_null desc,comm desc\u000d\u000aENAME SAL COMM\u000d\u000a------ ----- ----------\u000d\u000aMARTIN 1250 1400\u000d\u000aWARD 1250 500\u000d\u000aALLEN 1600 300\u000d\u000aTURNER 1500 0\u000d\u000aSMITH 800\u000d\u000a2.5 Dealing with Nulls When Sorting | 23","JONES 2975\u000d\u000aJAMES 950\u000d\u000aMILLER 1300\u000d\u000aFORD 3000\u000d\u000aADAMS 1100\u000d\u000aBLAKE 2850\u000d\u000aCLARK 2450\u000d\u000aSCOTT 3000\u000d\u000aKING 5000\u000d\u000a/* NON-NULL COMM SORTED ASCENDING, ALL NULLS FIRST */\u000d\u000a1 select ename,sal,comm\u000d\u000a2 from (\u000d\u000a3 select ename,sal,comm,\u000d\u000a4 case when comm is null then 0 else 1 end as is_null\u000d\u000a5 from emp\u000d\u000a6 ) x\u000d\u000a7 order by is_null,comm\u000d\u000aENAME SAL COMM\u000d\u000a------ ----- ----------\u000d\u000aSMITH 800\u000d\u000aJONES 2975\u000d\u000aCLARK 2450\u000d\u000aBLAKE 2850\u000d\u000aSCOTT 3000\u000d\u000aKING 5000\u000d\u000aJAMES 950\u000d\u000aMILLER 1300\u000d\u000aFORD 3000\u000d\u000aADAMS 1100\u000d\u000aTURNER 1500 0\u000d\u000aALLEN 1600 300\u000d\u000aWARD 1250 500\u000d\u000aMARTIN 1250 1400\u000d\u000a/* NON-NULL COMM SORTED DESCENDING, ALL NULLS FIRST */\u000d\u000a1 select ename,sal,comm\u000d\u000a2 from (\u000d\u000a3 select ename,sal,comm,\u000d\u000a4 case when comm is null then 0 else 1 end as is_null\u000d\u000a5 from emp\u000d\u000a6 ) x\u000d\u000a7 order by is_null,comm desc\u000d\u000aENAME SAL COMM\u000d\u000a------ ----- ----------\u000d\u000aSMITH 800\u000d\u000aJONES 2975\u000d\u000aCLARK 2450\u000d\u000a24 | Chapter 2: Sorting Query Results","BLAKE 2850\u000d\u000aSCOTT 3000\u000d\u000aKING 5000\u000d\u000aJAMES 950\u000d\u000aMILLER 1300\u000d\u000aFORD 3000\u000d\u000aADAMS 1100\u000d\u000aMARTIN 1250 1400\u000d\u000aWARD 1250 500\u000d\u000aALLEN 1600 300\u000d\u000aTURNER 1500 0\u000d\u000aOracle\u000d\u000aOracle users can use the solution for the other platforms. They can also use the fol\u2010\u000d\u000alowing Oracle-only solution, taking advantage of the NULLS FIRST and NULLS\u000d\u000aLAST extension to the ORDER BY clause to ensure NULLs are sorted first or last\u000d\u000aregardless of how non-NULL values are sorted:\u000d\u000a/* NON-NULL COMM SORTED ASCENDING, ALL NULLS LAST */\u000d\u000a1 select ename,sal,comm\u000d\u000a2 from emp\u000d\u000a3 order by comm nulls last\u000d\u000aENAME SAL COMM\u000d\u000a------ ----- ---------\u000d\u000aTURNER 1500 0\u000d\u000aALLEN 1600 300\u000d\u000aWARD 1250 500\u000d\u000aMARTIN 1250 1400\u000d\u000aSMITH 800\u000d\u000aJONES 2975\u000d\u000aJAMES 950\u000d\u000aMILLER 1300\u000d\u000aFORD 3000\u000d\u000aADAMS 1100\u000d\u000aBLAKE 2850\u000d\u000aCLARK 2450\u000d\u000aSCOTT 3000\u000d\u000aKING 5000\u000d\u000a/* NON-NULL COMM SORTED ASCENDING, ALL NULLS FIRST */\u000d\u000a1 select ename,sal,comm\u000d\u000a2 from emp\u000d\u000a3 order by comm nulls first\u000d\u000aENAME SAL COMM\u000d\u000a------ ----- ----------\u000d\u000aSMITH 800\u000d\u000aJONES 2975\u000d\u000a2.5 Dealing with Nulls When Sorting | 25","CLARK 2450\u000d\u000aBLAKE 2850\u000d\u000aSCOTT 3000\u000d\u000aKING 5000\u000d\u000aJAMES 950\u000d\u000aMILLER 1300\u000d\u000aFORD 3000\u000d\u000aADAMS 1100\u000d\u000aTURNER 1500 0\u000d\u000aALLEN 1600 300\u000d\u000aWARD 1250 500\u000d\u000aMARTIN 1250 1400\u000d\u000a/* NON-NULL COMM SORTED DESCENDING, ALL NULLS FIRST */\u000d\u000a1 select ename,sal,comm\u000d\u000a2 from emp\u000d\u000a3 order by comm desc nulls first\u000d\u000aENAME SAL COMM\u000d\u000a------ ----- ----------\u000d\u000aSMITH 800\u000d\u000aJONES 2975\u000d\u000aCLARK 2450\u000d\u000aBLAKE 2850\u000d\u000aSCOTT 3000\u000d\u000aKING 5000\u000d\u000aJAMES 950\u000d\u000aMILLER 1300\u000d\u000aFORD 3000\u000d\u000aADAMS 1100\u000d\u000aMARTIN 1250 1400\u000d\u000aWARD 1250 500\u000d\u000aALLEN 1600 300\u000d\u000aTURNER 1500 0\u000d\u000aDiscussion\u000d\u000aUnless your RDBMS provides you with a way to easily sort NULL values first or last\u000d\u000awithout modifying non-NULL values in the same column (as Oracle does), you\u2019ll\u000d\u000aneed an auxiliary column.\u000d\u000aAs of the time of this writing, DB2 users can use NULLS FIRST\u000d\u000aand NULLS LAST in the ORDER BY subclause of the OVER clause\u000d\u000ain window functions but not in the ORDER BY clause for the\u000d\u000aentire result set.\u000d\u000a26 | Chapter 2: Sorting Query Results","The purpose of this extra column (in the query only, not in the table) is to allow you\u000d\u000ato identify NULL values and sort them altogether, first or last. The following query\u000d\u000areturns the result set for inline view X for the non-Oracle solution:\u000d\u000aselect ename,sal,comm,\u000d\u000a case when comm is null then 0 else 1 end as is_null\u000d\u000a from emp\u000d\u000aENAME SAL COMM IS_NULL\u000d\u000a------ ----- ---------- ----------\u000d\u000aSMITH 800 0\u000d\u000aALLEN 1600 300 1\u000d\u000aWARD 1250 500 1\u000d\u000aJONES 2975 0\u000d\u000aMARTIN 1250 1400 1\u000d\u000aBLAKE 2850 0\u000d\u000aCLARK 2450 0\u000d\u000aSCOTT 3000 0\u000d\u000aKING 5000 0\u000d\u000aTURNER 1500 0 1\u000d\u000aADAMS 1100 0\u000d\u000aJAMES 950 0\u000d\u000aFORD 3000 0\u000d\u000aMILLER 1300 0\u000d\u000aBy using the values returned by IS_NULL, you can easily sort NULLS first or last\u000d\u000awithout interfering with the sorting of COMM.\u000d\u000a2.6 Sorting on a Data-Dependent Key\u000d\u000aProblem\u000d\u000aYou want to sort based on some conditional logic. For example, if JOB is SALES\u2010\u000d\u000aMAN, you want to sort on COMM; otherwise, you want to sort by SAL. You want to\u000d\u000areturn the following result set:\u000d\u000aENAME SAL JOB COMM\u000d\u000a---------- ---------- --------- ----------\u000d\u000aTURNER 1500 SALESMAN 0\u000d\u000aALLEN 1600 SALESMAN 300\u000d\u000aWARD 1250 SALESMAN 500\u000d\u000aSMITH 800 CLERK\u000d\u000aJAMES 950 CLERK\u000d\u000aADAMS 1100 CLERK\u000d\u000aMILLER 1300 CLERK\u000d\u000aMARTIN 1250 SALESMAN 1400\u000d\u000aCLARK 2450 MANAGER\u000d\u000aBLAKE 2850 MANAGER\u000d\u000aJONES 2975 MANAGER\u000d\u000a2.6 Sorting on a Data-Dependent Key | 27","SCOTT 3000 ANALYST\u000d\u000aFORD 3000 ANALYST\u000d\u000aKING 5000 PRESIDENT\u000d\u000aSolution\u000d\u000aUse a CASE expression in the ORDER BY clause:\u000d\u000a1 select ename,sal,job,comm\u000d\u000a2 from emp\u000d\u000a3 order by case when job = 'SALESMAN' then comm else sal end\u000d\u000aDiscussion\u000d\u000aYou can use the CASE expression to dynamically change how results are sorted. The\u000d\u000avalues passed to the ORDER BY look as follows:\u000d\u000aselect ename,sal,job,comm,\u000d\u000a case when job = 'SALESMAN' then comm else sal end as ordered\u000d\u000a from emp\u000d\u000a order by 5\u000d\u000aENAME SAL JOB COMM ORDERED\u000d\u000a---------- ---------- --------- ---------- ----------\u000d\u000aTURNER 1500 SALESMAN 0 0\u000d\u000aALLEN 1600 SALESMAN 300 300\u000d\u000aWARD1 250 SALESMAN 500 500\u000d\u000aSMITH 800 CLERK 800\u000d\u000aJAMES 950 CLERK 950\u000d\u000aADAMS 1100 CLERK 1100\u000d\u000aMILLER 1300 CLERK 1300\u000d\u000aMARTIN 1250 SALESMAN 1400 1400\u000d\u000aCLARK2 450 MANAGER 2450\u000d\u000aBLAKE2 850 MANAGER 2850\u000d\u000aJONES2 975 MANAGER 2975\u000d\u000aSCOTT 3000 ANALYST 3000\u000d\u000aFORD 3000 ANALYST 3000\u000d\u000aKING 5000 PRESIDENT 5000\u000d\u000a2.7 Summing Up\u000d\u000aSorting query results is one of the core skills for any user of SQL. The ORDER BY\u000d\u000aclause can be very powerful, but as we have seen in this chapter, still often requires\u000d\u000asome nuance to use effectively. It\u2019s important to master its use, as many of the recipes\u000d\u000ain the later chapters depend on it.\u000d\u000a28 | Chapter 2: Sorting Query Results","CHAPTER 3\u000d\u000aWorking with Multiple Tables\u000d\u000aThis chapter introduces the use of joins and set operations to combine data from\u000d\u000amultiple tables. Joins are the foundation of SQL. Set operations are also important. If\u000d\u000ayou want to master the complex queries found in the later chapters of this book, you\u000d\u000amust start here, with joins and set operations.\u000d\u000a3.1 Stacking One Rowset atop Another\u000d\u000aProblem\u000d\u000aYou want to return data stored in more than one table, conceptually stacking one\u000d\u000aresult set atop the other. The tables do not necessarily have a common key, but their\u000d\u000acolumns do have the same data types. For example, you want to display the name and\u000d\u000adepartment number of the employees in department 10 in table EMP, along with the\u000d\u000aname and department number of each department in table DEPT. You want the result\u000d\u000aset to look like the following:\u000d\u000aENAME_AND_DNAME DEPTNO\u000d\u000a--------------- ----------\u000d\u000aCLARK 10\u000d\u000aKING 10\u000d\u000aMILLER 10\u000d\u000a----------\u000d\u000aACCOUNTING 10\u000d\u000aRESEARCH 20\u000d\u000aSALES 30\u000d\u000aOPERATIONS 40\u000d\u000aSolution\u000d\u000aUse the set operation UNION ALL to combine rows from multiple tables:\u000d\u000a29","1 select ename as ename_and_dname, deptno\u000d\u000a2 from emp\u000d\u000a3 where deptno = 10\u000d\u000a4 union all\u000d\u000a5 select '----------', null\u000d\u000a6 from t1\u000d\u000a7 union all\u000d\u000a8 select dname, deptno\u000d\u000a9 from dept\u000d\u000aDiscussion\u000d\u000aUNION ALL combines rows from multiple row sources into one result set. As with\u000d\u000aall set operations, the items in all the SELECT lists must match in number and data\u000d\u000atype. For example, both of the following queries will fail:\u000d\u000aselect deptno | select deptno, dname\u000d\u000a from dept | from dept\u000d\u000a union all | union all\u000d\u000aselect ename | select deptno\u000d\u000a from emp | from emp\u000d\u000aIt is important to note, UNION ALL will include duplicates if they exist. If you want\u000d\u000ato filter out duplicates, use the UNION operator. For example, a UNION between\u000d\u000aEMP.DEPTNO and DEPT.DEPTNO returns only four rows:\u000d\u000aselect deptno\u000d\u000a from emp\u000d\u000a union\u000d\u000aselect deptno\u000d\u000a from dept\u000d\u000a DEPTNO\u000d\u000a---------\u000d\u000a 10\u000d\u000a 20\u000d\u000a 30\u000d\u000a 40\u000d\u000aSpecifying UNION rather than UNION ALL will most likely result in a sort opera\u2010\u000d\u000ation to eliminate duplicates. Keep this in mind when working with large result sets.\u000d\u000aUsing UNION is roughly equivalent to the following query, which applies DISTINCT\u000d\u000ato the output from a UNION ALL:\u000d\u000aselect distinct deptno\u000d\u000a from (\u000d\u000aselect deptno\u000d\u000a from emp\u000d\u000a union all\u000d\u000aselect deptno\u000d\u000a from dept\u000d\u000a )\u000d\u000a30 | Chapter 3: Working with Multiple Tables"," DEPTNO\u000d\u000a---------\u000d\u000a 10\u000d\u000a 20\u000d\u000a 30\u000d\u000a 40\u000d\u000aYou wouldn\u2019t use DISTINCT in a query unless you had to, and the same rule applies\u000d\u000afor UNION: don\u2019t use it instead of UNION ALL unless you have to. For example,\u000d\u000aalthough in this book we have limited the number of tables for teaching purposes, in\u000d\u000areal life if you are querying one table, there may be a more suitable way to query a\u000d\u000asingle table.\u000d\u000a3.2 Combining Related Rows\u000d\u000aProblem\u000d\u000aYou want to return rows from multiple tables by joining on a known common col\u2010\u000d\u000aumn or joining on columns that share common values. For example, you want to dis\u2010\u000d\u000aplay the names of all employees in department 10 along with the location of each\u000d\u000aemployee\u2019s department, but that data is stored in two separate tables. You want the\u000d\u000aresult set to be the following:\u000d\u000aENAME LOC\u000d\u000a---------- ----------\u000d\u000aCLARK NEW YORK\u000d\u000aKING NEW YORK\u000d\u000aMILLER NEW YORK\u000d\u000aSolution\u000d\u000aJoin table EMP to table DEPT on DEPTNO:\u000d\u000a1 select e.ename, d.loc\u000d\u000a2 from emp e, dept d\u000d\u000a3 where e.deptno = d.deptno\u000d\u000a4 and e.deptno = 10\u000d\u000aDiscussion\u000d\u000aThe solution is an example of a join, or more accurately an equi-join, which is a type\u000d\u000aof inner join. A join is an operation that combines rows from two tables into one. An\u000d\u000aequi-join is one in which the join condition is based on an equality condition (e.g.,\u000d\u000awhere one department number equals another). An inner join is the original type of\u000d\u000ajoin; each row returned contains data from each table.\u000d\u000a3.2 Combining Related Rows | 31","Conceptually, the result set from a join is produced by first creating a Cartesian prod\u2010\u000d\u000auct (all possible combinations of rows) from the tables listed in the FROM clause, as\u000d\u000ashown here:\u000d\u000aselect e.ename, d.loc,\u000d\u000a e.deptno as emp_deptno,\u000d\u000a d.deptno as dept_deptno\u000d\u000a from emp e, dept d\u000d\u000a where e.deptno = 10\u000d\u000aENAME LOC EMP_DEPTNO DEPT_DEPTNO\u000d\u000a---------- ------------- ---------- -----------\u000d\u000aCLARK NEW YORK 10 10\u000d\u000aKING NEW YORK 10 10\u000d\u000aMILLER NEW YORK 10 10\u000d\u000aCLARK DALLAS 10 20\u000d\u000aKING DALLAS 10 20\u000d\u000aMILLER DALLAS 10 20\u000d\u000aCLARK CHICAGO 10 30\u000d\u000aKING CHICAGO 10 30\u000d\u000aMILLER CHICAGO 10 30\u000d\u000aCLARK BOSTON 10 40\u000d\u000aKING BOSTON 10 40\u000d\u000aMILLER BOSTON 10 40\u000d\u000aEvery employee in table EMP (in department 10) is returned along with every depart\u2010\u000d\u000ament in table DEPT. Then, the expression in the WHERE clause involving e.deptno\u000d\u000aand d.deptno (the join) restricts the result set such that the only rows returned are the\u000d\u000aones where EMP.DEPTNO and DEPT.DEPTNO are equal:\u000d\u000aselect e.ename, d.loc,\u000d\u000a e.deptno as emp_deptno,\u000d\u000a d.deptno as dept_deptno\u000d\u000a from emp e, dept d\u000d\u000a where e.deptno = d.deptno\u000d\u000a and e.deptno = 10\u000d\u000aENAME LOC EMP_DEPTNO DEPT_DEPTNO\u000d\u000a---------- -------------- ---------- -----------\u000d\u000aCLARK NEW YORK 10 10\u000d\u000aKING NEW YORK 10 10\u000d\u000aMILLER NEW YORK 10 10\u000d\u000aAn alternative solution makes use of an explicit JOIN clause (the INNER keyword is\u000d\u000aoptional):\u000d\u000aselect e.ename, d.loc\u000d\u000a from emp e inner join dept d\u000d\u000a on (e.deptno = d.deptno)\u000d\u000a where e.deptno = 10\u000d\u000a32 | Chapter 3: Working with Multiple Tables","Use the JOIN clause if you prefer to have the join logic in the FROM clause rather\u000d\u000athan the WHERE clause. Both styles are ANSI compliant and work on all the latest\u000d\u000aversions of the RDBMSs in this book.\u000d\u000a3.3 Finding Rows in Common Between Two Tables\u000d\u000aProblem\u000d\u000aYou want to find common rows between two tables, but there are multiple columns\u000d\u000aon which you can join. For example, consider the following view V created from the\u000d\u000aEMP table for teaching purposes:\u000d\u000acreate view V\u000d\u000aas\u000d\u000aselect ename,job,sal\u000d\u000a from emp\u000d\u000a where job = 'CLERK'\u000d\u000a select * from V\u000d\u000aENAME JOB SAL\u000d\u000a---------- --------- ----------\u000d\u000aSMITH CLERK 800\u000d\u000aADAMS CLERK 1100\u000d\u000aJAMES CLERK 950\u000d\u000aMILLER CLERK 1300\u000d\u000aOnly clerks are returned from view V. However, the view does not show all possible\u000d\u000aEMP columns. You want to return the EMPNO, ENAME, JOB, SAL, and DEPTNO of\u000d\u000aall employees in EMP that match the rows from view V. You want the result set to be\u000d\u000athe following:\u000d\u000a EMPNO ENAME JOB SAL DEPTNO\u000d\u000a-------- ---------- --------- ---------- ---------\u000d\u000a 7369 SMITH CLERK 800 20\u000d\u000a 7876 ADAMS CLERK 1100 20\u000d\u000a 7900 JAMES CLERK 950 30\u000d\u000a 7934 MILLER CLERK 1300 10\u000d\u000aSolution\u000d\u000aJoin the tables on all the columns necessary to return the correct result. Alternatively,\u000d\u000ause the set operation INTERSECT to avoid performing a join and instead return the\u000d\u000aintersection (common rows) of the two tables.\u000d\u000aMySQL and SQL Server\u000d\u000aJoin table EMP to view V using multiple join conditions:\u000d\u000a3.3 Finding Rows in Common Between Two Tables | 33","1 select e.empno,e.ename,e.job,e.sal,e.deptno\u000d\u000a2 from emp e, V\u000d\u000a3 where e.ename = v.ename\u000d\u000a4 and e.job = v.job\u000d\u000a5 and e.sal = v.sal\u000d\u000aAlternatively, you can perform the same join via the JOIN clause:\u000d\u000a1 select e.empno,e.ename,e.job,e.sal,e.deptno\u000d\u000a2 from emp e join V\u000d\u000a3 on ( e.ename = v.ename\u000d\u000a4 and e.job = v.job\u000d\u000a5 and e.sal = v.sal )\u000d\u000aDB2, Oracle, and PostgreSQL\u000d\u000aThe MySQL and SQL Server solution also works for DB2, Oracle, and PostgreSQL.\u000d\u000aIt\u2019s the solution you should use if you need to return values from view V.\u000d\u000aIf you do not actually need to return columns from view V, you may use the set oper\u2010\u000d\u000aation INTERSECT along with an IN predicate:\u000d\u000a1 select empno,ename,job,sal,deptno\u000d\u000a2 from emp\u000d\u000a3 where (ename,job,sal) in (\u000d\u000a4 select ename,job,sal from emp\u000d\u000a5 intersect\u000d\u000a6 select ename,job,sal from V\u000d\u000a7 )\u000d\u000aDiscussion\u000d\u000aWhen performing joins, you must consider the proper columns to join in order to\u000d\u000areturn correct results. This is especially important when rows can have common val\u2010\u000d\u000aues for some columns while having different values for others.\u000d\u000aThe set operation INTERSECT will return rows common to both row sources. When\u000d\u000ausing INTERSECT, you are required to compare the same number of items, having\u000d\u000athe same data type, from two tables. When working with set operations, keep in mind\u000d\u000athat, by default, duplicate rows will not be returned.\u000d\u000a3.4 Retrieving Values from One Table That Do Not Exist in\u000d\u000aAnother\u000d\u000aProblem\u000d\u000aYou want to find those values in one table, call it the source table, that do not also\u000d\u000aexist in some target table. For example, you want to find which departments (if any)\u000d\u000a34 | Chapter 3: Working with Multiple Tables","in table DEPT do not exist in table EMP. In the example data, DEPTNO 40 from table\u000d\u000aDEPT does not exist in table EMP, so the result set should be the following:\u000d\u000a DEPTNO\u000d\u000a----------\u000d\u000a 40\u000d\u000aSolution\u000d\u000aHaving functions that perform set difference is particularly useful for this problem.\u000d\u000aDB2, PostgreSQL, SQL Server, and Oracle all support set difference operations. If\u000d\u000ayour DBMS does not support a set difference function, use a subquery as shown for\u000d\u000aMySQL.\u000d\u000aDB2, PostgreSQL, and SQL Server\u000d\u000aUse the set operation EXCEPT:\u000d\u000a1 select deptno from dept\u000d\u000a2 except\u000d\u000a3 select deptno from emp\u000d\u000aOracle\u000d\u000aUse the set operation MINUS:\u000d\u000a1 select deptno from dept\u000d\u000a2 minus\u000d\u000a3 select deptno from emp\u000d\u000aMySQL\u000d\u000aUse a subquery to return all DEPTNOs from table EMP into an outer query that\u000d\u000asearches table DEPT for rows that are not among the rows returned from the\u000d\u000asubquery:\u000d\u000a1 select deptno\u000d\u000a2 from dept\u000d\u000a3 where deptno not in (select deptno from emp)\u000d\u000aDiscussion\u000d\u000aDB2, PostgreSQL, and SQL Server\u000d\u000aSet difference functions make this operation easy. The EXCEPT operator takes the\u000d\u000afirst result set and removes from it all rows found in the second result set. The opera\u2010\u000d\u000ation is very much like a subtraction.\u000d\u000aThere are restrictions on the use of set operators, including EXCEPT. Data types and\u000d\u000anumber of values to compare must match in both SELECT lists. Additionally,\u000d\u000a3.4 Retrieving Values from One Table That Do Not Exist in Another | 35","EXCEPT will not return duplicates and, unlike a subquery using NOT IN, NULLs do\u000d\u000anot present a problem (see the discussion for MySQL). The EXCEPT operator will\u000d\u000areturn rows from the upper query (the query before the EXCEPT) that do not exist in\u000d\u000athe lower query (the query after the EXCEPT).\u000d\u000aOracle\u000d\u000aThe Oracle solution is identical to the solution using the EXCEPT operator; however, \u000d\u000aOracle calls its set difference operator MINUS instead of EXCEPT. Otherwise, the\u000d\u000apreceding explanation applies to Oracle as well.\u000d\u000aMySQL\u000d\u000aThe subquery will return all DEPTNOs from table EMP. The outer query returns all\u000d\u000aDEPTNOs from table DEPT that are \u201cnot in\u201d or \u201cnot included in\u201d the result set\u000d\u000areturned from the subquery.\u000d\u000aDuplicate elimination is something you\u2019ll want to consider when using the MySQL\u000d\u000asolutions. The EXCEPT- and MINUS-based solutions used for the other platforms\u000d\u000aeliminate duplicate rows from the result set, ensuring that each DEPTNO is reported\u000d\u000aonly one time. Of course, that can only be the case anyway, as DEPTNO is a key field\u000d\u000ain my example data. Were DEPTNO not a key field, you could use DISTINCT as fol\u2010\u000d\u000alows to ensure that each DEPTNO value missing from EMP is reported only once:\u000d\u000aselect distinct deptno\u000d\u000a from dept\u000d\u000a where deptno not in (select deptno from emp)\u000d\u000aBe mindful of NULLs when using NOT IN. Consider the following table,\u000d\u000aNEW_DEPT:\u000d\u000acreate table new_dept(deptno integer)\u000d\u000ainsert into new_deptvalues (10)\u000d\u000ainsert into new_dept values (50)\u000d\u000ainsert into new_dept values (null)\u000d\u000aIf you try to find the DEPTNOs in table DEPT that do not exist in table NEW_DEPT\u000d\u000aand use a subquery with NOT IN, you\u2019ll find that the query returns no rows:\u000d\u000aselect *\u000d\u000a from dept\u000d\u000a where deptno not in (select deptno from new_dept)\u000d\u000aDEPTNOs 20, 30, and 40 are not in table NEW_DEPT, yet were not returned by the\u000d\u000aquery. Why? The reason is the NULL value present in table NEW_DEPT. Three rows\u000d\u000aare returned by the subquery, with DEPTNOs of 10, 50, and NULL. IN and NOT IN\u000d\u000aare essentially OR operations and will yield different results because of how NULL\u000d\u000avalues are treated by logical OR evaluations.\u000d\u000a36 | Chapter 3: Working with Multiple Tables","To understand this, examine these truth tables (Let T=true, F=false, N=null):\u000d\u000a OR | T | F | N |\u000d\u000a+----+---+---+----+\u000d\u000a| T | T | T | T |\u000d\u000a| F | T | F | N |\u000d\u000a| N | T | N | N |\u000d\u000a+----+---+---+----+\u000d\u000a NOT |\u000d\u000a+-----+---+\u000d\u000a| T | F |\u000d\u000a| F | T |\u000d\u000a| N | N |\u000d\u000a+-----+---+\u000d\u000a AND | T | F | N |\u000d\u000a+-----+---+---+---+\u000d\u000a| T | T | F | N |\u000d\u000a| F | F | F | F |\u000d\u000a| N | N | F | N |\u000d\u000a+-----+---+---+---+\u000d\u000aNow consider the following example using IN and its equivalent using OR:\u000d\u000aselect deptno\u000d\u000a from dept\u000d\u000a where deptno in ( 10,50,null )\u000d\u000a DEPTNO\u000d\u000a-------\u000d\u000a 10\u000d\u000aselect deptno\u000d\u000a from dept\u000d\u000a where (deptno=10 or deptno=50 or deptno=null)\u000d\u000aDEPTNO\u000d\u000a-------\u000d\u000a 10\u000d\u000aWhy was only DEPTNO 10 returned? There are four DEPTNOs in DEPT, (10, 20, 30,\u000d\u000a40), and each one is evaluated against the predicate (deptno=10 or deptno=50 or\u000d\u000adeptno=null). According to the preceding truth tables, for each DEPTNO (10, 20, 30,\u000d\u000a40), the predicate yields:\u000d\u000aDEPTNO=10\u000d\u000a(deptno=10 or deptno=50 or deptno=null)\u000d\u000a= (10=10 or 10=50 or 10=null)\u000d\u000a= (T or F or N)\u000d\u000a= (T or N)\u000d\u000a= (T)\u000d\u000a3.4 Retrieving Values from One Table That Do Not Exist in Another | 37","DEPTNO=20\u000d\u000a(deptno=10 or deptno=50 or deptno=null)\u000d\u000a= (20=10 or 20=50 or 20=null)\u000d\u000a= (F or F or N)\u000d\u000a= (F or N)\u000d\u000a= (N)\u000d\u000aDEPTNO=30\u000d\u000a(deptno=10 or deptno=50 or deptno=null)\u000d\u000a= (30=10 or 30=50 or 30=null)\u000d\u000a= (F or F or N)\u000d\u000a= (F or N)\u000d\u000a= (N)\u000d\u000aDEPTNO=40\u000d\u000a(deptno=10 or deptno=50 or deptno=null)\u000d\u000a= (40=10 or 40=50 or 40=null)\u000d\u000a= (F or F or N)\u000d\u000a= (F or N)\u000d\u000a= (N)\u000d\u000aNow it is obvious why only DEPTNO 10 was returned when using IN and OR. Next,\u000d\u000aconsider the same example using NOT IN and NOT OR:\u000d\u000aselect deptno\u000d\u000a from dept\u000d\u000a where deptno not in ( 10,50,null )\u000d\u000a( no rows )\u000d\u000aselect deptno\u000d\u000a from dept\u000d\u000a where not (deptno=10 or deptno=50 or deptno=null)\u000d\u000a( no rows )\u000d\u000aWhy are no rows returned? Let\u2019s check the truth tables:\u000d\u000aDEPTNO=10\u000d\u000aNOT (deptno=10 or deptno=50 or deptno=null)\u000d\u000a= NOT (10=10 or 10=50 or 10=null)\u000d\u000a= NOT (T or F or N)\u000d\u000a= NOT (T or N)\u000d\u000a= NOT (T)\u000d\u000a= (F)\u000d\u000aDEPTNO=20\u000d\u000aNOT (deptno=10 or deptno=50 or deptno=null)\u000d\u000a= NOT (20=10 or 20=50 or 20=null)\u000d\u000a= NOT (F or F or N)\u000d\u000a= NOT (F or N)\u000d\u000a= NOT (N)\u000d\u000a= (N)\u000d\u000a38 | Chapter 3: Working with Multiple Tables","DEPTNO=30\u000d\u000aNOT (deptno=10 or deptno=50 or deptno=null)\u000d\u000a= NOT (30=10 or 30=50 or 30=null)\u000d\u000a= NOT (F or F or N)\u000d\u000a= NOT (F or N)\u000d\u000a= NOT (N)\u000d\u000a= (N)\u000d\u000aDEPTNO=40\u000d\u000aNOT (deptno=10 or deptno=50 or deptno=null)\u000d\u000a= NOT (40=10 or 40=50 or 40=null)\u000d\u000a= NOT (F or F or N)\u000d\u000a= NOT (F or N)\u000d\u000a= NOT (N)\u000d\u000a= (N)\u000d\u000aIn SQL, \u201cTRUE or NULL\u201d is TRUE, but \u201cFALSE or NULL\u201d is NULL! You must keep\u000d\u000athis in mind when using IN predicates, and when performing logical OR evaluations\u000d\u000aand NULL values are involved.\u000d\u000aTo avoid the problem with NOT IN and NULLs, use a correlated subquery in con\u2010\u000d\u000ajunction with NOT EXISTS. The term correlated subquery is used because rows from\u000d\u000athe outer query are referenced in the subquery. The following example is an alterna\u2010\u000d\u000ative solution that will not be affected by NULL rows (going back to the original query\u000d\u000afrom the \u201cProblem\u201d section):\u000d\u000aselect d.deptno\u000d\u000a from dept d\u000d\u000a where not exists (\u000d\u000a select 1\u000d\u000a from emp e\u000d\u000a where d.deptno = e.deptno\u000d\u000a)\u000d\u000aDEPTNO\u000d\u000a----------\u000d\u000a40\u000d\u000aselect d.deptno\u000d\u000a from dept d\u000d\u000a where not exists (\u000d\u000a select 1\u000d\u000a from new_dept nd\u000d\u000a where d.deptno = nd.deptno\u000d\u000a)\u000d\u000aDEPTNO\u000d\u000a----------\u000d\u000a30\u000d\u000a40\u000d\u000a20\u000d\u000a3.4 Retrieving Values from One Table That Do Not Exist in Another | 39","Conceptually, the outer query in this solution considers each row in the DEPT table.\u000d\u000aFor each DEPT row, the following happens:\u000d\u000a1. The subquery is executed to see whether the department number exists in the\u000d\u000aEMP table. Note the condition D.DEPTNO = E.DEPTNO, which brings together\u000d\u000athe department numbers from the two tables.\u000d\u000a2. If the subquery returns results, then EXISTS (\u2026) evaluates to true and NOT\u000d\u000aEXISTS (\u2026) thus evaluates to FALSE, and the row being considered by the outer\u000d\u000aquery is discarded.\u000d\u000a3. If the subquery returns no results, then NOT EXISTS (\u2026) evaluates to TRUE,\u000d\u000aand the row being considered by the outer query is returned (because it is for a\u000d\u000adepartment not represented in the EMP table).\u000d\u000aThe items in the SELECT list of the subquery are unimportant when using a correla\u2010\u000d\u000ated subquery with EXISTS/NOT EXISTS, which is why we chose to select NULL, to\u000d\u000aforce you to focus on the join in the subquery rather than the items in the SELECT\u000d\u000alist.\u000d\u000a3.5 Retrieving Rows from One Table That Do Not\u000d\u000aCorrespond to Rows in Another\u000d\u000aProblem\u000d\u000aYou want to find rows that are in one table that do not have a match in another table,\u000d\u000afor two tables that have common keys. For example, you want to find which depart\u2010\u000d\u000aments have no employees. The result set should be the following:\u000d\u000a DEPTNO DNAME LOC\u000d\u000a---------- -------------- -------------\u000d\u000a 40 OPERATIONS BOSTON\u000d\u000aFinding the department each employee works in requires an equi-join on DEPTNO\u000d\u000afrom EMP to DEPT. The DEPTNO column represents the common value between\u000d\u000atables. Unfortunately, an equi-join will not show you which department has no\u000d\u000aemployees. That\u2019s because by equi-joining EMP and DEPT you are returning all rows\u000d\u000athat satisfy the join condition. Instead, you want only those rows from DEPT that do\u000d\u000anot satisfy the join condition.\u000d\u000aThis is a subtly different problem than in the preceding recipe, though at first glance\u000d\u000athey may seem the same. The difference is that the preceding recipe yields only a list\u000d\u000aof department numbers not represented in table EMP. Using this recipe, however, you\u000d\u000acan easily return other columns from the DEPT table; you can return more than just\u000d\u000adepartment numbers.\u000d\u000a40 | Chapter 3: Working with Multiple Tables","Solution\u000d\u000aReturn all rows from one table along with rows from another that may or may not\u000d\u000ahave a match on the common column. Then, keep only those rows with no match.\u000d\u000aDB2, MySQL, PostgreSQL, and SQL Server\u000d\u000aUse an outer join and filter for NULLs (keyword OUTER is optional):\u000d\u000a1 select d.*\u000d\u000a2 from dept d left outer join emp e\u000d\u000a3 on (d.deptno = e.deptno)\u000d\u000a4 where e.deptno is null\u000d\u000aDiscussion\u000d\u000aThis solution works by outer joining and then keeping only rows that have no match.\u000d\u000aThis sort of operation is sometimes called an anti-join. To get a better idea of how an\u000d\u000aanti-join works, first examine the result set without filtering for NULLs:\u000d\u000aselect e.ename, e.deptno as emp_deptno, d.*\u000d\u000a from dept d left join emp e\u000d\u000a on (d.deptno = e.deptno)\u000d\u000aENAME EMP_DEPTNO DEPTNO DNAME LOC\u000d\u000a---------- ---------- ---------- -------------- -------------\u000d\u000aSMITH 20 20 RESEARCH DALLAS\u000d\u000aALLEN 30 30 SALES CHICAGO\u000d\u000aWARD 30 30 SALES CHICAGO\u000d\u000aJONES 20 20 RESEARCH DALLAS\u000d\u000aMARTIN 30 30 SALES CHICAGO\u000d\u000aBLAKE 30 30 SALES CHICAGO\u000d\u000aCLARK 10 10 ACCOUNTING NEW YORK\u000d\u000aSCOTT 20 20 RESEARCH DALLAS\u000d\u000aKING 10 10 ACCOUNTING NEW YORK\u000d\u000aTURNER 30 30 SALES CHICAGO\u000d\u000aADAMS 20 20 RESEARCH DALLAS\u000d\u000aJAMES 30 30 SALES CHICAGO\u000d\u000aFORD 20 20 RESEARCH DALLAS\u000d\u000aMILLER 10 10 ACCOUNTING NEW YORK\u000d\u000a 40 OPERATIONS BOSTON\u000d\u000aNotice, the last row has a NULL value for EMP.ENAME and EMP_DEPTNO. That\u2019s\u000d\u000abecause no employees work in department 40. The solution uses the WHERE clause\u000d\u000ato keep only rows where EMP_DEPTNO is NULL (thus keeping only rows from\u000d\u000aDEPT that have no match in EMP).\u000d\u000a3.5 Retrieving Rows from One Table That Do Not Correspond to Rows in Another | 41","3.6 Adding Joins to a Query Without Interfering with\u000d\u000aOther Joins\u000d\u000aProblem\u000d\u000aYou have a query that returns the results you want. You need additional information,\u000d\u000abut when trying to get it, you lose data from the original result set. For example, you\u000d\u000awant to return all employees, the location of the department in which they work, and\u000d\u000athe date they received a bonus. For this problem, the EMP_BONUS table contains the\u000d\u000afollowing data:\u000d\u000aselect * from emp_bonus\u000d\u000a EMPNO RECEIVED TYPE\u000d\u000a ---------- ----------- ----------\u000d\u000a 7369 14-MAR-2005 1\u000d\u000a 7900 14-MAR-2005 2\u000d\u000a 7788 14-MAR-2005 3\u000d\u000aThe query you start with looks like this:\u000d\u000aselect e.ename, d.loc\u000d\u000a from emp e, dept d\u000d\u000a where e.deptno=d.deptno\u000d\u000a ENAME LOC\u000d\u000a ---------- -------------\u000d\u000a SMITH DALLAS\u000d\u000a ALLEN CHICAGO\u000d\u000a WARD CHICAGO\u000d\u000a JONES DALLAS\u000d\u000a MARTIN CHICAGO\u000d\u000a BLAKE CHICAGO\u000d\u000a CLARK NEW YORK\u000d\u000a SCOTT DALLAS\u000d\u000a KING NEW YORK\u000d\u000a TURNER CHICAGO\u000d\u000a ADAMS DALLAS\u000d\u000a JAMES CHICAGO\u000d\u000a FORD DALLAS\u000d\u000a MILLER NEW YORK\u000d\u000aYou want to add to these results the date a bonus was given to an employee, but join\u2010\u000d\u000aing to the EMP_BONUS table returns fewer rows than you want because not every\u000d\u000aemployee has a bonus:\u000d\u000aselect e.ename, d.loc,eb.received\u000d\u000a from emp e, dept d, emp_bonus eb\u000d\u000a where e.deptno=d.deptno\u000d\u000a and e.empno=eb.empno\u000d\u000a42 | Chapter 3: Working with Multiple Tables","ENAME LOC RECEIVED\u000d\u000a---------- ------------- -----------\u000d\u000aSCOTT DALLAS 14-MAR-2005\u000d\u000aSMITH DALLAS 14-MAR-2005\u000d\u000aJAMES CHICAGO 14-MAR-2005\u000d\u000aYour desired result set is the following:\u000d\u000aENAME LOC RECEIVED\u000d\u000a---------- ------------- -----------\u000d\u000aALLEN CHICAGO\u000d\u000aWARD CHICAGO\u000d\u000aMARTIN CHICAGO\u000d\u000aJAMES CHICAGO 14-MAR-2005\u000d\u000aTURNER CHICAGO\u000d\u000aBLAKE CHICAGO\u000d\u000aSMITH DALLAS 14-MAR-2005\u000d\u000aFORD DALLAS\u000d\u000aADAMS DALLAS\u000d\u000aJONES DALLAS\u000d\u000aSCOTT DALLAS 14-MAR-2005\u000d\u000aCLARK NEW YORK\u000d\u000aKING NEW YORK\u000d\u000aMILLER NEW YORK\u000d\u000aSolution\u000d\u000aYou can use an outer join to obtain the additional information without losing the data\u000d\u000afrom the original query. First join table EMP to table DEPT to get all employees and\u000d\u000athe location of the department they work, then outer join to table EMP_ BONUS to\u000d\u000areturn the date of the bonus if there is one. The following is the DB2, MySQL, Post\u2010\u000d\u000agreSQL, and SQL server syntax:\u000d\u000a1 select e.ename, d.loc, eb.received\u000d\u000a2 from emp e join dept d\u000d\u000a3 on (e.deptno=d.deptno)\u000d\u000a4 left join emp_bonus eb\u000d\u000a5 on (e.empno=eb.empno)\u000d\u000a6 order by 2\u000d\u000aYou can also use a scalar subquery (a subquery placed in the SELECT list) to mimic\u000d\u000aan outer join:\u000d\u000a1 select e.ename, d.loc,\u000d\u000a2 (select eb.received from emp_bonus eb\u000d\u000a3 where eb.empno=e.empno) as received\u000d\u000a4 from emp e, dept d\u000d\u000a5 where e.deptno=d.deptno\u000d\u000a6 order by 2\u000d\u000aThe scalar subquery solution will work across all platforms.\u000d\u000a3.6 Adding Joins to a Query Without Interfering with Other Joins | 43","Discussion\u000d\u000aAn outer join will return all rows from one table and matching rows from another.\u000d\u000aSee the previous recipe for another example of such a join. The reason an outer join\u000d\u000aworks to solve this problem is that it does not result in any rows being eliminated that\u000d\u000awould otherwise be returned. The query will return all the rows it would return\u000d\u000awithout the outer join. And it also returns the received date, if one exists.\u000d\u000aUse of a scalar subquery is also a convenient technique for this sort of problem, as it\u000d\u000adoes not require you to modify already correct joins in your main query. Using a\u000d\u000ascalar subquery is an easy way to tack on extra data to a query without compromising\u000d\u000athe current result set. When working with scalar subqueries, you must ensure they\u000d\u000areturn a scalar (single) value. If a subquery in the SELECT list returns more than one\u000d\u000arow, you will receive an error.\u000d\u000aSee Also\u000d\u000aSee Recipe 14.10 for a workaround to the problem of not being able to return multi\u2010\u000d\u000aple rows from a SELECT-list subquery.\u000d\u000a3.7 Determining Whether Two Tables Have the Same Data\u000d\u000aProblem\u000d\u000aYou want to know whether two tables or views have the same data (cardinality and\u000d\u000avalues). Consider the following view:\u000d\u000acreate view V\u000d\u000aas\u000d\u000aselect * from emp where deptno != 10\u000d\u000a union all\u000d\u000aselect * from emp where ename = 'WARD'\u000d\u000aselect * from V\u000d\u000aEMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO\u000d\u000a----- ---------- --------- ----- ----------- ----- ----- ------\u000d\u000a 7369 SMITH CLERK 7902 17-DEC-2005 800 20\u000d\u000a 7499 ALLEN SALESMAN 7698 20-FEB-2006 1600 300 30\u000d\u000a 7521 WARD SALESMAN 7698 22-FEB-2006 1250 500 30\u000d\u000a 7566 JONES MANAGER 7839 02-APR-2006 2975 20\u000d\u000a 7654 MARTIN SALESMAN 7698 28-SEP-2006 1250 1400 30\u000d\u000a 7698 BLAKE MANAGER 7839 01-MAY-2006 2850 30\u000d\u000a 7788 SCOTT ANALYST 7566 09-DEC-2007 3000 20\u000d\u000a 7844 TURNER SALESMAN 7698 08-SEP-2006 1500 0 30\u000d\u000a 7876 ADAMS CLERK 7788 12-JAN-2008 1100 20\u000d\u000a 7900 JAMES CLERK 7698 03-DEC-2006 950 30\u000d\u000a44 | Chapter 3: Working with Multiple Tables"," 7902 FORD ANALYST 7566 03-DEC-2006 3000 20\u000d\u000a 7521 WARD SALESMAN 7698 22-FEB-2006 1250 500 30\u000d\u000aYou want to determine whether this view has exactly the same data as table EMP. The\u000d\u000arow for employee WARD is duplicated to show that the solution will reveal not only\u000d\u000adifferent data but duplicates as well. Based on the rows in table EMP, the difference\u000d\u000awill be the three rows for employees in department 10 and the two rows for employee\u000d\u000aWARD. You want to return the following result set:\u000d\u000aEMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO CNT\u000d\u000a----- ---------- --------- ----- ----------- ----- ----- ------ ---\u000d\u000a 7521 WARD SALESMAN 7698 22-FEB-2006 1250 500 30 1\u000d\u000a 7521 WARD SALESMAN 7698 22-FEB-2006 1250 500 30 2\u000d\u000a 7782 CLARK MANAGER 7839 09-JUN-2006 2450 10 1\u000d\u000a 7839 KING PRESIDENT 17-NOV-2006 5000 10 1\u000d\u000a 7934 MILLER CLERK 7782 23-JAN-2007 1300 10 1\u000d\u000aSolution\u000d\u000aFunctions that perform SET difference MINUS or EXCEPT, depending on your\u000d\u000aDBMS, make the problem of comparing tables a relatively easy one to solve. If your\u000d\u000aDBMS does not offer such functions, you can use a correlated subquery.\u000d\u000aDB2 and PostgreSQL\u000d\u000aUse the set operations EXCEPT and UNION ALL to find the difference between view\u000d\u000aV and table EMP combined with the difference between table EMP and view V:\u000d\u000a 1 (\u000d\u000a 2 select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a 3 count(*) as cnt\u000d\u000a 4 from V\u000d\u000a 5 group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a 6 except\u000d\u000a 7 select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a 8 count(*) as cnt\u000d\u000a 9 from emp\u000d\u000a10 group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a11 )\u000d\u000a12 union all\u000d\u000a13 (\u000d\u000a14 select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a15 count(*) as cnt\u000d\u000a16 from emp\u000d\u000a17 group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a18 except\u000d\u000a19 select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a20 count(*) as cnt\u000d\u000a21 from v\u000d\u000a22 group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a23 )\u000d\u000a3.7 Determining Whether Two Tables Have the Same Data | 45","Oracle\u000d\u000aUse the set operations MINUS and UNION ALL to find the difference between view\u000d\u000aV and table EMP combined with the difference between table EMP and view V:\u000d\u000a 1 (\u000d\u000a 2 select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a 3 count(*) as cnt\u000d\u000a 4 from V\u000d\u000a 5 group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a 6 minus\u000d\u000a 7 select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a 8 count(*) as cnt\u000d\u000a 9 from emp\u000d\u000a10 group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a11 )\u000d\u000a12 union all\u000d\u000a13 (\u000d\u000a14 select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a15 count(*) as cnt\u000d\u000a16 from emp\u000d\u000a17 group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a18 minus\u000d\u000a19 select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a20 count(*) as cnt\u000d\u000a21 from v\u000d\u000a22 group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a23 )\u000d\u000aMySQL and SQL Server\u000d\u000aUse a correlated subquery and UNION ALL to find the rows in view V and not in\u000d\u000atable EMP combined with the rows in table EMP and not in view V:\u000d\u000a 1 select *\u000d\u000a 2 from (\u000d\u000a 3 select e.empno,e.ename,e.job,e.mgr,e.hiredate,\u000d\u000a 4 e.sal,e.comm,e.deptno, count(*) as cnt\u000d\u000a 5 from emp e\u000d\u000a 6 group by empno,ename,job,mgr,hiredate,\u000d\u000a 7 sal,comm,deptno\u000d\u000a 8 ) e\u000d\u000a 9 where not exists (\u000d\u000a10 select null\u000d\u000a11 from (\u000d\u000a12 select v.empno,v.ename,v.job,v.mgr,v.hiredate,\u000d\u000a13 v.sal,v.comm,v.deptno, count(*) as cnt\u000d\u000a14 from v\u000d\u000a15 group by empno,ename,job,mgr,hiredate,\u000d\u000a16 sal,comm,deptno\u000d\u000a17 ) v\u000d\u000a18 where v.empno = e.empno\u000d\u000a19 and v.ename = e.ename\u000d\u000a46 | Chapter 3: Working with Multiple Tables","20 and v.job = e.job\u000d\u000a21 and coalesce(v.mgr,0) = coalesce(e.mgr,0)\u000d\u000a22 and v.hiredate = e.hiredate\u000d\u000a23 and v.sal = e.sal\u000d\u000a24 and v.deptno = e.deptno\u000d\u000a25 and v.cnt = e.cnt\u000d\u000a26 and coalesce(v.comm,0) = coalesce(e.comm,0)\u000d\u000a27 )\u000d\u000a28 union all\u000d\u000a29 select *\u000d\u000a30 from (\u000d\u000a31 select v.empno,v.ename,v.job,v.mgr,v.hiredate,\u000d\u000a32 v.sal,v.comm,v.deptno, count(*) as cnt\u000d\u000a33 from v\u000d\u000a34 group by empno,ename,job,mgr,hiredate,\u000d\u000a35 sal,comm,deptno\u000d\u000a36 ) v\u000d\u000a37 where not exists (\u000d\u000a38 select null\u000d\u000a39 from (\u000d\u000a40 select e.empno,e.ename,e.job,e.mgr,e.hiredate,\u000d\u000a41 e.sal,e.comm,e.deptno, count(*) as cnt\u000d\u000a42 from emp e\u000d\u000a43 group by empno,ename,job,mgr,hiredate,\u000d\u000a44 sal,comm,deptno\u000d\u000a45 ) e\u000d\u000a46 where v.empno = e.empno\u000d\u000a47 and v.ename = e.ename\u000d\u000a48 and v.job = e.job\u000d\u000a49 and coalesce(v.mgr,0) = coalesce(e.mgr,0)\u000d\u000a50 and v.hiredate = e.hiredate\u000d\u000a51 and v.sal = e.sal\u000d\u000a52 and v.deptno = e.deptno\u000d\u000a53 and v.cnt = e.cnt\u000d\u000a54 and coalesce(v.comm,0) = coalesce(e.comm,0)\u000d\u000a55 )\u000d\u000aDiscussion\u000d\u000aDespite using different techniques, the concept is the same for all solutions:\u000d\u000a1. Find rows in table EMP that do not exist in view V.\u000d\u000a2. Combine (UNION ALL) those rows with rows from view V that do not exist in\u000d\u000atable EMP.\u000d\u000aIf the tables in question are equal, then no rows are returned. If the tables are differ\u2010\u000d\u000aent, the rows causing the difference are returned. As an easy first step when compar\u2010\u000d\u000aing tables, you can compare the cardinalities alone rather than including them with\u000d\u000athe data comparison.\u000d\u000a3.7 Determining Whether Two Tables Have the Same Data | 47","The following query is a simple example of this and will work on all DBMSs:\u000d\u000aselect count(*)\u000d\u000a from emp\u000d\u000a union\u000d\u000aselect count(*)\u000d\u000a from dept\u000d\u000aCOUNT(*)\u000d\u000a--------\u000d\u000a 4\u000d\u000a 14\u000d\u000aBecause UNION will filter out duplicates, only one row will be returned if the tables\u2019\u000d\u000acardinalities are the same. Because two rows are returned in this example, you know\u000d\u000athat the tables do not contain identical rowsets.\u000d\u000aDB2, Oracle, and PostgreSQL\u000d\u000aMINUS and EXCEPT work in the same way, so we will use EXCEPT for this discus\u2010\u000d\u000asion. The queries before and after the UNION ALL are similar. So, to understand\u000d\u000ahow the solution works, simply execute the query prior to the UNION ALL by itself.\u000d\u000aThe following result set is produced by executing lines 1\u201311 in the \u201cSolution\u201d section:\u000d\u000a(\u000d\u000a select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a count(*) as cnt\u000d\u000a from V\u000d\u000a group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a except\u000d\u000a select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a count(*) as cnt\u000d\u000a from emp\u000d\u000a group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a)\u000d\u000a EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO CNT\u000d\u000a ----- ---------- --------- ----- ----------- ----- ----- ------ ---\u000d\u000a 7521 WARD SALESMAN 7698 22-FEB-2006 1250 500 30 2\u000d\u000aThe result set represents a row found in view V that is either not in table EMP, or has\u000d\u000aa different cardinality than that same row in table EMP. In this case, the duplicate row\u000d\u000afor employee WARD is found and returned. If you\u2019re still having trouble understand\u2010\u000d\u000aing how the result set is produced, run each query on either side of EXCEPT individ\u2010\u000d\u000aually. You\u2019ll notice the only difference between the two result sets is the CNT for\u000d\u000aemployee WARD returned by view V.\u000d\u000a48 | Chapter 3: Working with Multiple Tables","The portion of the query after the UNION ALL does the opposite of the query pre\u2010\u000d\u000aceding UNION ALL. The query returns rows in table EMP not in view V:\u000d\u000a(\u000d\u000a select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a count(*) as cnt\u000d\u000a from emp\u000d\u000a group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a minus\u000d\u000a select empno,ename,job,mgr,hiredate,sal,comm,deptno,\u000d\u000a count(*) as cnt\u000d\u000a from v\u000d\u000a group by empno,ename,job,mgr,hiredate,sal,comm,deptno\u000d\u000a)\u000d\u000aEMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO CNT\u000d\u000a----- ---------- --------- ----- ----------- ----- ----- ------ ---\u000d\u000a7521 WARD SALESMAN 7698 22-FEB-2006 1250 500 30 1\u000d\u000a7782 CLARK MANAGER 7839 09-JUN-2006 2450 10 1\u000d\u000a7839 KING PRESIDENT 17-NOV-2006 5000 10 1\u000d\u000a7934 MILLER CLERK 7782 23-JAN-2007 1300 10 1\u000d\u000aThe results are then combined by UNION ALL to produce the final result set.\u000d\u000aMySQL and SQL Server\u000d\u000aThe queries before and after the UNION ALL are similar. To understand how the\u000d\u000asubquery-based solution works, simply execute the query prior to the UNION ALL\u000d\u000aby itself. The following query is from lines 1\u201327 in the solution:\u000d\u000aselect *\u000d\u000a from (\u000d\u000a select e.empno,e.ename,e.job,e.mgr,e.hiredate,\u000d\u000a e.sal,e.comm,e.deptno, count(*) as cnt\u000d\u000a from emp e\u000d\u000a group by empno,ename,job,mgr,hiredate,\u000d\u000a sal,comm,deptno\u000d\u000a ) e\u000d\u000a where not exists (\u000d\u000aselect null\u000d\u000a from (\u000d\u000aselect v.empno,v.ename,v.job,v.mgr,v.hiredate,\u000d\u000a v.sal,v.comm,v.deptno, count(*) as cnt\u000d\u000a from v\u000d\u000a group by empno,ename,job,mgr,hiredate,\u000d\u000a sal,comm,deptno\u000d\u000a ) v\u000d\u000a where v.empno = e.empno\u000d\u000a and v.ename = e.ename\u000d\u000a and v.job = e.job\u000d\u000a and v.mgr = e.mgr\u000d\u000a and v.hiredate = e.hiredate\u000d\u000a3.7 Determining Whether Two Tables Have the Same Data | 49"," and v.sal = e.sal\u000d\u000a and v.deptno = e.deptno\u000d\u000a and v.cnt = e.cnt\u000d\u000a and coalesce(v.comm,0) = coalesce(e.comm,0)\u000d\u000a )\u000d\u000a EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO CNT\u000d\u000a ----- ---------- --------- ----- ----------- ----- ----- ------ ---\u000d\u000a 7521 WARD SALESMAN 7698 22-FEB-2006 1250 500 30 1\u000d\u000a 7782 CLARK MANAGER 7839 09-JUN-2006 2450 10 1\u000d\u000a 7839 KING PRESIDENT 17-NOV-2006 5000 10 1\u000d\u000a 7934 MILLER CLERK 7782 23-JAN-2007 1300 10 1\u000d\u000aNotice that the comparison is not between table EMP and view V, but rather between\u000d\u000ainline view E and inline view V. The cardinality for each row is found and returned as\u000d\u000aan attribute for that row. You are comparing each row and its occurrence count. If\u000d\u000ayou are having trouble understanding how the comparison works, run the subqueries\u000d\u000aindependently. The next step is to find all rows (including CNT) in inline view E that\u000d\u000ado not exist in inline view V. The comparison uses a correlated subquery and NOT\u000d\u000aEXISTS. The joins will determine which rows are the same, and the result will be all\u000d\u000arows from inline view E that are not the rows returned by the join. The query after\u000d\u000athe UNION ALL does the opposite; it finds all rows in inline view V that do not exist\u000d\u000ain inline view E:\u000d\u000aselect *\u000d\u000a from (\u000d\u000aselect v.empno,v.ename,v.job,v.mgr,v.hiredate,\u000d\u000a v.sal,v.comm,v.deptno, count(*) as cnt\u000d\u000a from v\u000d\u000a group by empno,ename,job,mgr,hiredate,\u000d\u000a sal,comm,deptno\u000d\u000a ) v\u000d\u000a where not exists (\u000d\u000aselect null\u000d\u000a from (\u000d\u000a select e.empno,e.ename,e.job,e.mgr,e.hiredate,\u000d\u000a e.sal,e.comm,e.deptno, count(*) as cnt\u000d\u000a from emp e\u000d\u000a group by empno,ename,job,mgr,hiredate,\u000d\u000a sal,comm,deptno\u000d\u000a ) e\u000d\u000a where v.empno = e.empno\u000d\u000a and v.ename = e.ename\u000d\u000a and v.job = e.job\u000d\u000a and v.mgr = e.mgr\u000d\u000a and v.hiredate = e.hiredate\u000d\u000a and v.sal = e.sal\u000d\u000a and v.deptno = e.deptno\u000d\u000a and v.cnt = e.cnt\u000d\u000a and coalesce(v.comm,0) = coalesce(e.comm,0)\u000d\u000a)\u000d\u000a50 | Chapter 3: Working with Multiple Tables","EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO CNT\u000d\u000a----- ---------- --------- ----- ----------- ----- ----- ------ ---\u000d\u000a 7521 WARD SALESMAN 7698 22-FEB-2006 1250 500 30 2\u000d\u000aThe results are then combined by UNION ALL to produce the final result set.\u000d\u000aAles Spetic and Jonathan Gennick give an alternate solution in\u000d\u000atheir book Transact-SQL Cookbook (O\u2019Reilly). See the section\u000d\u000a\u201cComparing Two Sets for Equality\u201d in Chapter 2 of their book.\u000d\u000a3.8 Identifying and Avoiding Cartesian Products\u000d\u000aProblem\u000d\u000aYou want to return the name of each employee in department 10 along with the loca\u2010\u000d\u000ation of the department. The following query is returning incorrect data:\u000d\u000aselect e.ename, d.loc\u000d\u000a from emp e, dept d\u000d\u000a where e.deptno = 10\u000d\u000aENAME LOC\u000d\u000a---------- -------------\u000d\u000aCLARK NEW YORK\u000d\u000aCLARK DALLAS\u000d\u000aCLARK CHICAGO\u000d\u000aCLARK BOSTON\u000d\u000aKING NEW YORK\u000d\u000aKING DALLAS\u000d\u000aKING CHICAGO\u000d\u000aKING BOSTON\u000d\u000aMILLER NEW YORK\u000d\u000aMILLER DALLAS\u000d\u000aMILLER CHICAGO\u000d\u000aMILLER BOSTON\u000d\u000aThe correct result set is the following:\u000d\u000aENAME LOC\u000d\u000a---------- ---------\u000d\u000aCLARK NEW YORK\u000d\u000aKING NEW YORK\u000d\u000aMILLER NEW YORK\u000d\u000a3.8 Identifying and Avoiding Cartesian Products | 51","Solution\u000d\u000aUse a join between the tables in the FROM clause to return the correct result set:\u000d\u000a1 select e.ename, d.loc\u000d\u000a2 from emp e, dept d\u000d\u000a3 where e.deptno = 10\u000d\u000a4 and d.deptno = e.deptno\u000d\u000aDiscussion\u000d\u000aLet\u2019s look at the data in the DEPT table:\u000d\u000aselect * from dept\u000d\u000a DEPTNO DNAME LOC\u000d\u000a---------- -------------- -------------\u000d\u000a 10 ACCOUNTING NEW YORK\u000d\u000a 20 RESEARCH DALLAS\u000d\u000a 30 SALES CHICAGO\u000d\u000a 40 OPERATIONS BOSTON\u000d\u000aYou can see that department 10 is in New York, and thus you can know that returning\u000d\u000aemployees with any location other than New York is incorrect. The number of rows\u000d\u000areturned by the incorrect query is the product of the cardinalities of the two tables in\u000d\u000athe FROM clause. In the original query, the filter on EMP for department 10 will\u000d\u000aresult in three rows. Because there is no filter for DEPT, all four rows from DEPT are\u000d\u000areturned. Three multiplied by four is twelve, so the incorrect query returns twelve\u000d\u000arows. Generally, to avoid a Cartesian product, you would apply the n\u20131 rule where n\u000d\u000arepresents the number of tables in the FROM clause and n\u20131 represents the mini\u2010\u000d\u000amum number of joins necessary to avoid a Cartesian product. Depending on what\u000d\u000athe keys and join columns in your tables are, you may very well need more than n\u20131\u000d\u000ajoins, but n\u20131 is a good place to start when writing queries.\u000d\u000aWhen used properly, Cartesian products can be useful. Common\u000d\u000auses of Cartesian products include transposing or pivoting (and\u000d\u000aunpivoting) a result set, generating a sequence of values, and mim\u2010\u000d\u000aicking a loop (although the last two may also be accomplished\u000d\u000ausing a recursive CTE).\u000d\u000a3.9 Performing Joins When Using Aggregates\u000d\u000aProblem\u000d\u000aYou want to perform an aggregation, but your query involves multiple tables. You\u000d\u000awant to ensure that joins do not disrupt the aggregation. For example, you want to\u000d\u000a52 | Chapter 3: Working with Multiple Tables","find the sum of the salaries for employees in department 10 along with the sum of\u000d\u000atheir bonuses. Some employees have more than one bonus, and the join between\u000d\u000atable EMP and table EMP_BONUS is causing incorrect values to be returned by the\u000d\u000aaggregate function SUM. For this problem, table EMP_BONUS contains the follow\u2010\u000d\u000aing data:\u000d\u000aselect * from emp_bonus\u000d\u000aEMPNO RECEIVED TYPE\u000d\u000a----- ----------- ----------\u000d\u000a 7934 17-MAR-2005 1\u000d\u000a 7934 15-FEB-2005 2\u000d\u000a 7839 15-FEB-2005 3\u000d\u000a 7782 15-FEB-2005 1\u000d\u000aNow, consider the following query that returns the salary and bonus for all employees\u000d\u000ain department 10. Table BONUS.TYPE determines the amount of the bonus. A type 1\u000d\u000abonus is 10% of an employee\u2019s salary, type 2 is 20%, and type 3 is 30%.\u000d\u000aselect e.empno,\u000d\u000a e.ename,\u000d\u000a e.sal,\u000d\u000a e.deptno,\u000d\u000a e.sal*case when eb.type = 1 then .1\u000d\u000a when eb.type = 2 then .2\u000d\u000a else .3\u000d\u000a end as bonus\u000d\u000a from emp e, emp_bonus eb\u000d\u000awhere e.empno = eb.empno\u000d\u000a and e.deptno = 10\u000d\u000a EMPNO ENAME SAL DEPTNO BONUS\u000d\u000a------- ---------- ---------- ---------- ---------\u000d\u000a 7934 MILLER 1300 10 130\u000d\u000a 7934 MILLER 1300 10 260\u000d\u000a 7839 KING 5000 10 1500\u000d\u000a 7782 CLARK 2450 10 245\u000d\u000aSo far, so good. However, things go awry when you attempt a join to the\u000d\u000aEMP_BONUS table to sum the bonus amounts:\u000d\u000aselect deptno,\u000d\u000a sum(sal) as total_sal,\u000d\u000a sum(bonus) as total_bonus\u000d\u000a from (\u000d\u000aselect e.empno,\u000d\u000a e.ename,\u000d\u000a e.sal,\u000d\u000a e.deptno,\u000d\u000a e.sal*case when eb.type = 1 then .1\u000d\u000a when eb.type = 2 then .2\u000d\u000a3.9 Performing Joins When Using Aggregates | 53"," else .3\u000d\u000a end as bonus\u000d\u000a from emp e, emp_bonus eb\u000d\u000a where e.empno = eb.empno\u000d\u000a and e.deptno = 10\u000d\u000a ) x\u000d\u000a group by deptno\u000d\u000aDEPTNO TOTAL_SAL TOTAL_BONUS\u000d\u000a------ ----------- -----------\u000d\u000a 10 10050 2135\u000d\u000aWhile the TOTAL_BONUS is correct, the TOTAL_SAL is incorrect. The sum of all\u000d\u000asalaries in department 10 is 8750, as the following query shows:\u000d\u000aselect sum(sal) from emp where deptno=10\u000d\u000a SUM(SAL)\u000d\u000a----------\u000d\u000a 8750\u000d\u000aWhy is TOTAL_SAL incorrect? The reason is the duplicate rows in the SAL column\u000d\u000acreated by the join. Consider the following query, which joins tables EMP and\u000d\u000aEMP_BONUS:\u000d\u000aselect e.ename,\u000d\u000a e.sal\u000d\u000a from emp e, emp_bonus eb\u000d\u000a where e.empno = eb.empno\u000d\u000a and e.deptno = 10\u000d\u000aENAME SAL\u000d\u000a---------- ----------\u000d\u000aCLARK 2450\u000d\u000aKING 5000\u000d\u000aMILLER 1300\u000d\u000aMILLER 1300\u000d\u000aNow it is easy to see why the value for TOTAL_SAL is incorrect: MILLER\u2019s salary is\u000d\u000acounted twice. The final result set that you are really after is:\u000d\u000aDEPTNO TOTAL_SAL TOTAL_BONUS\u000d\u000a------ --------- -----------\u000d\u000a 10 8750 2135\u000d\u000aSolution\u000d\u000aYou have to be careful when computing aggregates across joins. Typically when dupli\u2010\u000d\u000acates are returned due to a join, you can avoid miscalculations by aggregate functions\u000d\u000ain two ways: you can simply use the keyword DISTINCT in the call to the aggregate\u000d\u000afunction, so only unique instances of each value are used in the computation; or you\u000d\u000a54 | Chapter 3: Working with Multiple Tables","can perform the aggregation first (in an inline view) prior to joining, thus avoiding\u000d\u000athe incorrect computation by the aggregate function because the aggregate will\u000d\u000aalready be computed before you even join, thus avoiding the problem altogether. The\u000d\u000asolutions that follow use DISTINCT. The \u201cDiscussion\u201d section will discuss the techni\u2010\u000d\u000aque of using an inline view to perform the aggregation prior to joining.\u000d\u000aMySQL and PostgreSQL\u000d\u000aPerform a sum of only the DISTINCT salaries:\u000d\u000a 1 select deptno,\u000d\u000a 2 sum(distinct sal) as total_sal,\u000d\u000a 3 sum(bonus) as total_bonus\u000d\u000a 4 from (\u000d\u000a 5 select e.empno,\u000d\u000a 6 e.ename,\u000d\u000a 7 e.sal,\u000d\u000a 8 e.deptno,\u000d\u000a 9 e.sal*case when eb.type = 1 then .1\u000d\u000a10 when eb.type = 2 then .2\u000d\u000a11 else .3\u000d\u000a12 end as bonus\u000d\u000a13 from emp e, emp_bonus eb\u000d\u000a14 where e.empno = eb.empno\u000d\u000a15 and e.deptno = 10\u000d\u000a16 ) x\u000d\u000a17 group by deptno\u000d\u000aDB2, Oracle, and SQL Server\u000d\u000aThese platforms support the preceding solution, but they also support an alternative\u000d\u000asolution using the window function SUM OVER:\u000d\u000a 1 select distinct deptno,total_sal,total_bonus\u000d\u000a 2 from (\u000d\u000a 3 select e.empno,\u000d\u000a 4 e.ename,\u000d\u000a 5 sum(distinct e.sal) over\u000d\u000a 6 (partition by e.deptno) as total_sal,\u000d\u000a 7 e.deptno,\u000d\u000a 8 sum(e.sal*case when eb.type = 1 then .1\u000d\u000a 9 when eb.type = 2 then .2\u000d\u000a10 else .3 end) over\u000d\u000a11 (partition by deptno) as total_bonus\u000d\u000a12 from emp e, emp_bonus eb\u000d\u000a13 where e.empno = eb.empno\u000d\u000a14 and e.deptno = 10\u000d\u000a15 ) x\u000d\u000a3.9 Performing Joins When Using Aggregates | 55","Discussion\u000d\u000aMySQL and PostgreSQL\u000d\u000aThe second query in the \u201cProblem\u201d section of this recipe joins table EMP and table\u000d\u000aEMP_BONUS and returns two rows for employee MILLER, which is what causes the\u000d\u000aerror on the sum of EMP.SAL (the salary is added twice). The solution is to simply\u000d\u000asum the distinct EMP.SAL values that are returned by the query. The following query\u000d\u000ais an alternative solution\u2014necessary if there could be duplicate values in the column\u000d\u000ayou are summing. The sum of all salaries in department 10 is computed first, and that\u000d\u000arow is then joined to table EMP, which is then joined to table EMP_BONUS.\u000d\u000aThe following query works for all DBMSs:\u000d\u000aselect d.deptno,\u000d\u000a d.total_sal,\u000d\u000a sum(e.sal*case when eb.type = 1 then .1\u000d\u000a when eb.type = 2 then .2\u000d\u000a else .3 end) as total_bonus\u000d\u000a from emp e,\u000d\u000a emp_bonus eb,\u000d\u000a (\u000d\u000aselect deptno, sum(sal) as total_sal\u000d\u000a from emp\u000d\u000a where deptno = 10\u000d\u000a group by deptno\u000d\u000a ) d\u000d\u000a where e.deptno = d.deptno\u000d\u000a and e.empno = eb.empno\u000d\u000a group by d.deptno,d.total_sal\u000d\u000a DEPTNO TOTAL_SAL TOTAL_BONUS\u000d\u000a--------- ---------- ------------\u000d\u000a 10 8750 2135\u000d\u000aDB2, Oracle, and SQL Server\u000d\u000aThis alternative solution takes advantage of the window function SUM OVER. The\u000d\u000afollowing query is taken from lines 3\u201314 in \u201cSolution\u201d and returns the following\u000d\u000aresult set:\u000d\u000aselect e.empno,\u000d\u000a e.ename,\u000d\u000a sum(distinct e.sal) over\u000d\u000a (partition by e.deptno) as total_sal,\u000d\u000a e.deptno,\u000d\u000a sum(e.sal*case when eb.type = 1 then .1\u000d\u000a when eb.type = 2 then .2\u000d\u000a else .3 end) over\u000d\u000a (partition by deptno) as total_bonus\u000d\u000a56 | Chapter 3: Working with Multiple Tables"," from emp e, emp_bonus eb\u000d\u000a where e.empno = eb.empno\u000d\u000a and e.deptno = 10\u000d\u000aEMPNO ENAME TOTAL_SAL DEPTNO TOTAL_BONUS\u000d\u000a----- ---------- ---------- ------ -----------\u000d\u000a 7934 MILLER 8750 10 2135\u000d\u000a 7934 MILLER 8750 10 2135\u000d\u000a 7782 CLARK 8750 10 2135\u000d\u000a 7839 KING 8750 10 2135\u000d\u000aThe windowing function, SUM OVER, is called twice, first to compute the sum of the\u000d\u000adistinct salaries for the defined partition or group. In this case, the partition is\u000d\u000aDEPTNO 10, and the sum of the distinct salaries for DEPTNO 10 is 8750. The next\u000d\u000acall to SUM OVER computes the sum of the bonuses for the same defined partition.\u000d\u000aThe final result set is produced by taking the distinct values for TOTAL_SAL,\u000d\u000aDEPTNO, and TOTAL_BONUS.\u000d\u000a3.10 Performing Outer Joins When Using Aggregates\u000d\u000aProblem\u000d\u000aBegin with the same problem as in Recipe 3.9, but modify table EMP_BONUS such\u000d\u000athat the difference in this case is not all employees in department 10 have been given\u000d\u000abonuses. Consider the EMP_BONUS table and a query to (ostensibly) find both the\u000d\u000asum of all salaries for department 10 and the sum of all bonuses for all employees in\u000d\u000adepartment 10:\u000d\u000aselect * from emp_bonus\u000d\u000a EMPNO RECEIVED TYPE\u000d\u000a---------- ----------- ----------\u000d\u000a 7934 17-MAR-2005 1\u000d\u000a 7934 15-FEB-2005 2\u000d\u000aselect deptno,\u000d\u000a sum(sal) as total_sal,\u000d\u000a sum(bonus) as total_bonus\u000d\u000a from (\u000d\u000aselect e.empno,\u000d\u000a e.ename,\u000d\u000a e.sal,\u000d\u000a e.deptno,\u000d\u000a e.sal*case when eb.type = 1 then .1\u000d\u000a when eb.type = 2 then .2\u000d\u000a else .3 end as bonus\u000d\u000a from emp e, emp_bonus eb\u000d\u000a where e.empno = eb.empno\u000d\u000a3.10 Performing Outer Joins When Using Aggregates | 57"," and e.deptno = 10\u000d\u000a )\u000d\u000a group by deptno\u000d\u000a DEPTNO TOTAL_SAL TOTAL_BONUS\u000d\u000a ------ ---------- -----------\u000d\u000a 10 2600 390\u000d\u000aThe result for TOTAL_BONUS is correct, but the value returned for TOTAL_SAL\u000d\u000adoes not represent the sum of all salaries in department 10. The following query\u000d\u000ashows why the TOTAL_SAL is incorrect:\u000d\u000aselect e.empno,\u000d\u000a e.ename,\u000d\u000a e.sal,\u000d\u000a e.deptno,\u000d\u000a e.sal*case when eb.type = 1 then .1\u000d\u000a when eb.type = 2 then .2\u000d\u000a else .3 end as bonus\u000d\u000a from emp e, emp_bonus eb\u000d\u000a where e.empno = eb.empno\u000d\u000a and e.deptno = 10\u000d\u000a EMPNO ENAME SAL DEPTNO BONUS\u000d\u000a--------- --------- ------- ---------- ----------\u000d\u000a 7934 MILLER 1300 10 130\u000d\u000a 7934 MILLER 1300 10 260\u000d\u000aRather than sum all salaries in department 10, only the salary for MILLER is sum\u2010\u000d\u000amed, and it is erroneously summed twice. Ultimately, you would like to return the\u000d\u000afollowing result set:\u000d\u000aDEPTNO TOTAL_SAL TOTAL_BONUS\u000d\u000a------ --------- -----------\u000d\u000a 10 8750 390\u000d\u000aSolution\u000d\u000aThe solution is similar to that of Recipe 3.9, but here you outer join to EMP_BONUS\u000d\u000ato ensure all employees from department 10 are included.\u000d\u000aDB2, MySQL, PostgreSQL, and SQL Server\u000d\u000aOuter join to EMP_BONUS, then perform the sum on only distinct salaries from\u000d\u000adepartment 10:\u000d\u000a 1 select deptno,\u000d\u000a 2 sum(distinct sal) as total_sal,\u000d\u000a 3 sum(bonus) as total_bonus\u000d\u000a 4 from (\u000d\u000a 5 select e.empno,\u000d\u000a 6 e.ename,\u000d\u000a58 | Chapter 3: Working with Multiple Tables"," 7 e.sal,\u000d\u000a 8 e.deptno,\u000d\u000a 9 e.sal*case when eb.type is null then 0\u000d\u000a10 when eb.type = 1 then .1\u000d\u000a11 when eb.type = 2 then .2\u000d\u000a12 else .3 end as bonus\u000d\u000a13 from emp e left outer join emp_bonus eb\u000d\u000a14 on (e.empno = eb.empno)\u000d\u000a15 where e.deptno = 10\u000d\u000a16 )\u000d\u000a17 group by deptno\u000d\u000aYou can also use the window function SUM OVER:\u000d\u000a 1 select distinct deptno,total_sal,total_bonus\u000d\u000a 2 from (\u000d\u000a 3 select e.empno,\u000d\u000a 4 e.ename,\u000d\u000a 5 sum(distinct e.sal) over\u000d\u000a 6 (partition by e.deptno) as total_sal,\u000d\u000a 7 e.deptno,\u000d\u000a 8 sum(e.sal*case when eb.type is null then 0\u000d\u000a 9 when eb.type = 1 then .1\u000d\u000a10 when eb.type = 2 then .2\u000d\u000a11 else .3\u000d\u000a12 end) over\u000d\u000a13 (partition by deptno) as total_bonus\u000d\u000a14 from emp e left outer join emp_bonus eb\u000d\u000a15 on (e.empno = eb.empno)\u000d\u000a16 where e.deptno = 10\u000d\u000a17 ) x\u000d\u000aDiscussion\u000d\u000aThe second query in the \u201cProblem\u201d section of this recipe joins table EMP and table\u000d\u000aEMP_BONUS and returns only rows for employee MILLER, which is what causes the\u000d\u000aerror on the sum of EMP.SAL (the other employees in DEPTNO 10 do not have\u000d\u000abonuses, and their salaries are not included in the sum). The solution is to outer join\u000d\u000atable EMP to table EMP_BONUS so even employees without a bonus will be\u000d\u000aincluded in the result. If an employee does not have a bonus, NULL will be returned\u000d\u000afor EMP_BONUS.TYPE. It is important to keep this in mind as the CASE statement\u000d\u000ahas been modified and is slightly different from Recipe 3.9. If EMP_BONUS.TYPE is\u000d\u000aNULL, the CASE expression returns zero, which has no effect on the sum.\u000d\u000aThe following query is an alternative solution. The sum of all salaries in department\u000d\u000a10 is computed first, then joined to table EMP, which is then joined to table\u000d\u000aEMP_BONUS (thus avoiding the outer join). The following query works for all\u000d\u000aDBMSs:\u000d\u000a3.10 Performing Outer Joins When Using Aggregates | 59","select d.deptno,\u000d\u000a d.total_sal,\u000d\u000a sum(e.sal*case when eb.type = 1 then .1\u000d\u000a when eb.type = 2 then .2\u000d\u000a else .3 end) as total_bonus\u000d\u000a from emp e,\u000d\u000a emp_bonus eb,\u000d\u000a (\u000d\u000aselect deptno, sum(sal) as total_sal\u000d\u000a from emp\u000d\u000a where deptno = 10\u000d\u000a group by deptno\u000d\u000a ) d\u000d\u000a where e.deptno = d.deptno\u000d\u000a and e.empno = eb.empno\u000d\u000a group by d.deptno,d.total_sal\u000d\u000a DEPTNO TOTAL_SAL TOTAL_BONUS\u000d\u000a--------- ---------- -----------\u000d\u000a 10 8750 390\u000d\u000a3.11 Returning Missing Data from Multiple Tables\u000d\u000aProblem\u000d\u000aYou want to return missing data from multiple tables simultaneously. Returning rows\u000d\u000afrom table DEPT that do not exist in table EMP (any departments that have no\u000d\u000aemployees) requires an outer join. Consider the following query, which returns all\u000d\u000aDEPTNOs and DNAMEs from DEPT along with the names of all the employees in\u000d\u000aeach department (if there is an employee in a particular department):\u000d\u000aselect d.deptno,d.dname,e.ename\u000d\u000a from dept d left outer join emp e\u000d\u000a on (d.deptno=e.deptno)\u000d\u000a DEPTNO DNAME ENAME\u000d\u000a--------- -------------- ----------\u000d\u000a 20 RESEARCH SMITH\u000d\u000a 30 SALES ALLEN\u000d\u000a 30 SALES WARD\u000d\u000a 20 RESEARCH JONES\u000d\u000a 30 SALES MARTIN\u000d\u000a 30 SALES BLAKE\u000d\u000a 10 ACCOUNTING CLARK\u000d\u000a 20 RESEARCH SCOTT\u000d\u000a 10 ACCOUNTING KING\u000d\u000a 30 SALES TURNER\u000d\u000a 20 RESEARCH ADAMS\u000d\u000a 30 SALES JAMES\u000d\u000a60 | Chapter 3: Working with Multiple Tables"," 20 RESEARCH FORD\u000d\u000a 10 ACCOUNTING MILLER\u000d\u000a 40 OPERATIONS\u000d\u000aThe last row, the OPERATIONS department, is returned despite that department not\u000d\u000ahaving any employees, because table EMP was outer joined to table DEPT. Now, sup\u2010\u000d\u000apose there was an employee without a department. How would you return the previ\u2010\u000d\u000aous result set along with a row for the employee having no department? In other\u000d\u000awords, you want to outer join to both table EMP and table DEPT, and in the same\u000d\u000aquery. After creating the new employee, a first attempt may look like this:\u000d\u000ainsert into emp (empno,ename,job,mgr,hiredate,sal,comm,deptno)\u000d\u000aselect 1111,'YODA','JEDI',null,hiredate,sal,comm,null\u000d\u000a from emp\u000d\u000a where ename = 'KING'\u000d\u000aselect d.deptno,d.dname,e.ename\u000d\u000a from dept d right outer join emp e\u000d\u000a on (d.deptno=e.deptno)\u000d\u000a DEPTNO DNAME ENAME\u000d\u000a---------- ------------ ----------\u000d\u000a 10 ACCOUNTING MILLER\u000d\u000a 10 ACCOUNTING KING\u000d\u000a 10 ACCOUNTING CLARK\u000d\u000a 20 RESEARCH FORD\u000d\u000a 20 RESEARCH ADAMS\u000d\u000a 20 RESEARCH SCOTT\u000d\u000a 20 RESEARCH JONES\u000d\u000a 20 RESEARCH SMITH\u000d\u000a 30 SALES JAMES\u000d\u000a 30 SALES TURNER\u000d\u000a 30 SALES BLAKE\u000d\u000a 30 SALES MARTIN\u000d\u000a 30 SALES WARD\u000d\u000a 30 SALES ALLEN\u000d\u000a YODA\u000d\u000aThis outer join manages to return the new employee but lost the OPERATIONS\u000d\u000adepartment from the original result set. The final result set should return a row for\u000d\u000aYODA as well as OPERATIONS, such as the following:\u000d\u000a DEPTNO DNAME ENAME\u000d\u000a---------- ------------ --------\u000d\u000a 10 ACCOUNTING CLARK\u000d\u000a 10 ACCOUNTING KING\u000d\u000a 10 ACCOUNTING MILLER\u000d\u000a 20 RESEARCH ADAMS\u000d\u000a 20 RESEARCH FORD\u000d\u000a 20 RESEARCH JONES\u000d\u000a 20 RESEARCH SCOTT\u000d\u000a 20 RESEARCH SMITH\u000d\u000a3.11 Returning Missing Data from Multiple Tables | 61"," 30 SALES ALLEN\u000d\u000a 30 SALES BLAKE\u000d\u000a 30 SALES JAMES\u000d\u000a 30 SALES MARTIN\u000d\u000a 30 SALES TURNER\u000d\u000a 30 SALES WARD\u000d\u000a 40 OPERATIONS\u000d\u000a YODA\u000d\u000aSolution\u000d\u000aUse a full outer join to return missing data from both tables based on a common\u000d\u000avalue.\u000d\u000aDB2, MySQL, PostgreSQL, and SQL Server\u000d\u000aUse the explicit FULL OUTER JOIN command to return missing rows from both\u000d\u000atables along with matching rows:\u000d\u000a1 select d.deptno,d.dname,e.ename\u000d\u000a2 from dept d full outer join emp e\u000d\u000a3 on (d.deptno=e.deptno)\u000d\u000aAlternatively, since MySQL does not yet have a FULL OUTER JOIN, UNION the\u000d\u000aresults of the two different outer joins:\u000d\u000a1 select d.deptno,d.dname,e.ename\u000d\u000a2 from dept d right outer join emp e\u000d\u000a3 on (d.deptno=e.deptno)\u000d\u000a4 union\u000d\u000a5 select d.deptno,d.dname,e.ename\u000d\u000a6 from dept d left outer join emp e\u000d\u000a7 on (d.deptno=e.deptno)\u000d\u000aOracle\u000d\u000aOracle users can still use either of the preceding solutions. Alternatively, you can use\u000d\u000aOracle\u2019s proprietary outer join syntax:\u000d\u000a1 select d.deptno,d.dname,e.ename\u000d\u000a2 from dept d, emp e\u000d\u000a3 where d.deptno = e.deptno(+)\u000d\u000a4 union\u000d\u000a5 select d.deptno,d.dname,e.ename\u000d\u000a6 from dept d, emp e\u000d\u000a7 where d.deptno(+) = e.deptno\u000d\u000aDiscussion\u000d\u000aThe full outer join is simply the combination of outer joins on both tables. To see how\u000d\u000aa full outer join works \u201cunder the covers,\u201d simply run each outer join, then union the\u000d\u000a62 | Chapter 3: Working with Multiple Tables","results. The following query returns rows from table DEPT and any matching rows\u000d\u000afrom table EMP (if any):\u000d\u000aselect d.deptno,d.dname,e.ename\u000d\u000a from dept d left outer join emp e\u000d\u000a on (d.deptno = e.deptno)\u000d\u000a DEPTNO DNAME ENAME\u000d\u000a ------ -------------- ----------\u000d\u000a 20 RESEARCH SMITH\u000d\u000a 30 SALES ALLEN\u000d\u000a 30 SALES WARD\u000d\u000a 20 RESEARCH JONES\u000d\u000a 30 SALES MARTIN\u000d\u000a 30 SALES BLAKE\u000d\u000a 10 ACCOUNTING CLARK\u000d\u000a 20 RESEARCH SCOTT\u000d\u000a 10 ACCOUNTING KING\u000d\u000a 30 SALES TURNER\u000d\u000a 20 RESEARCH ADAMS\u000d\u000a 30 SALES JAMES\u000d\u000a 20 RESEARCH FORD\u000d\u000a 10 ACCOUNTING MILLER\u000d\u000a 40 OPERATIONS\u000d\u000aThis next query returns rows from table EMP and any matching rows from table\u000d\u000aDEPT (if any):\u000d\u000aselect d.deptno,d.dname,e.ename\u000d\u000a from dept d right outer join emp e\u000d\u000a on (d.deptno = e.deptno)\u000d\u000a DEPTNO DNAME ENAME\u000d\u000a ------ -------------- ----------\u000d\u000a 10 ACCOUNTING MILLER\u000d\u000a 10 ACCOUNTING KING\u000d\u000a 10 ACCOUNTING CLARK\u000d\u000a 20 RESEARCH FORD\u000d\u000a 20 RESEARCH ADAMS\u000d\u000a 20 RESEARCH SCOTT\u000d\u000a 20 RESEARCH JONES\u000d\u000a 20 RESEARCH SMITH\u000d\u000a 30 SALES JAMES\u000d\u000a 30 SALES TURNER\u000d\u000a 30 SALES BLAKE\u000d\u000a 30 SALES MARTIN\u000d\u000a 30 SALES WARD\u000d\u000a 30 SALES ALLEN\u000d\u000a YODA\u000d\u000aThe results from these two queries are unioned to provide the final result set.\u000d\u000a3.11 Returning Missing Data from Multiple Tables | 63","3.12 Using NULLs in Operations and Comparisons\u000d\u000aProblem\u000d\u000aNULL is never equal to or not equal to any value, not even itself, but you want to\u000d\u000aevaluate values returned by a nullable column like you would evaluate real values. For\u000d\u000aexample, you want to find all employees in EMP whose commission (COMM) is less\u000d\u000athan the commission of employee WARD. Employees with a NULL commission\u000d\u000ashould be included as well.\u000d\u000aSolution\u000d\u000aUse a function such as COALESCE to transform the NULL value into a real value that\u000d\u000acan be used in standard evaluation:\u000d\u000a1 select ename,comm\u000d\u000a2 from emp\u000d\u000a3 where coalesce(comm,0) < ( select comm\u000d\u000a4 from emp\u000d\u000a5 where ename = 'WARD' )\u000d\u000aDiscussion\u000d\u000aThe COALESCE function will return the first non-NULL value from the list of values\u000d\u000apassed to it. When a NULL value is encountered, it is replaced by zero, which is then\u000d\u000acompared with WARD\u2019s commission. This can be seen by putting the COALESCE\u000d\u000afunction in the SELECT list:\u000d\u000aselect ename,comm,coalesce(comm,0)\u000d\u000a from emp\u000d\u000a where coalesce(comm,0) < ( select comm\u000d\u000a from emp\u000d\u000a where ename = 'WARD' )\u000d\u000a ENAME COMM COALESCE(COMM,0)\u000d\u000a ---------- ---------- ----------------\u000d\u000a SMITH 0\u000d\u000a ALLEN 300 300\u000d\u000a JONES 0\u000d\u000a BLAKE 0\u000d\u000a CLARK 0\u000d\u000a SCOTT 0\u000d\u000a KING 0\u000d\u000a TURNER 0 0\u000d\u000a ADAMS 0\u000d\u000a JAMES 0\u000d\u000a FORD 0\u000d\u000a MILLER 0\u000d\u000a64 | Chapter 3: Working with Multiple Tables","3.13 Summing Up\u000d\u000aJoins are a crucial aspect of querying databases\u2014it will be the norm that you need to\u000d\u000ajoin two or more tables together to find what you are looking for. Mastering the dif\u2010\u000d\u000aferent combinations and categories of joins that are covered in this chapter will set\u000d\u000ayou up for success.\u000d\u000a3.13 Summing Up | 65","","CHAPTER 4\u000d\u000aInserting, Updating, and Deleting\u000d\u000aThe past few chapters have focused on basic query techniques, all centered around\u000d\u000athe task of getting data out of a database. This chapter turns the tables and focuses on\u000d\u000athe following three topic areas:\u000d\u000a\u2022 Inserting new records into your database\u000d\u000a\u2022 Updating existing records\u000d\u000a\u2022 Deleting records that you no longer want\u000d\u000aFor ease in finding them when you need them, recipes in this chapter have been grou\u2010\u000d\u000aped by topic: all the insertion recipes come first, followed by the update recipes, and\u000d\u000afinally recipes for deleting data.\u000d\u000aInserting is usually a straightforward task. It begins with the simple problem of\u000d\u000ainserting a single row. Many times, however, it is more efficient to use a set-based\u000d\u000aapproach to create new rows. To that end, you\u2019ll also find techniques for inserting\u000d\u000amany rows at a time.\u000d\u000aLikewise, updating and deleting start out as simple tasks. You can update one record,\u000d\u000aand you can delete one record. But you can also update whole sets of records at once,\u000d\u000aand in very powerful ways. And there are many handy ways to delete records. For\u000d\u000aexample, you can delete rows in one table depending on whether they exist in another\u000d\u000atable.\u000d\u000aSQL even has a way, a relatively new addition to the standard, letting you insert,\u000d\u000aupdate, and delete all at once. That may not sound like too useful a thing now, but the\u000d\u000aMERGE statement represents a powerful way to synchronize a database table with an\u000d\u000aexternal source of data (such as a flat file feed from a remote system). Check out\u000d\u000aRecipe 4.11 in this chapter for details.\u000d\u000a67","4.1 Inserting a New Record\u000d\u000aProblem\u000d\u000aYou want to insert a new record into a table. For example, you want to insert a new\u000d\u000arecord into the DEPT table. The value for DEPTNO should be 50, DNAME should be\u000d\u000aPROGRAMMING, and LOC should be BALTIMORE.\u000d\u000aSolution\u000d\u000aUse the INSERT statement with the VALUES clause to insert one row at a time:\u000d\u000ainsert into dept (deptno,dname,loc)\u000d\u000avalues (50,'PROGRAMMING','BALTIMORE')\u000d\u000aFor DB2, SQL Server, PostgreSQL, and MySQL you have the option of inserting one\u000d\u000arow at a time or multiple rows at a time by including multiple VALUES lists:\u000d\u000a/* multi row insert */\u000d\u000ainsert into dept (deptno,dname,loc)\u000d\u000avalues (1,'A','B'),\u000d\u000a (2,'B','C')\u000d\u000aDiscussion\u000d\u000aThe INSERT statement allows you to create new rows in database tables. The syntax\u000d\u000afor inserting a single row is consistent across all database brands.\u000d\u000aAs a shortcut, you can omit the column list in an INSERT statement:\u000d\u000ainsert into dept\u000d\u000avalues (50,'PROGRAMMING','BALTIMORE')\u000d\u000aHowever, if you do not list your target columns, you must insert into all of the col\u2010\u000d\u000aumns in the table and be mindful of the order of the values in the VALUES list; you\u000d\u000amust supply values in the same order in which the database displays columns in\u000d\u000aresponse to a SELECT * query. Either way, you should be mindful of column con\u2010\u000d\u000astraints because if you don\u2019t insert into every column, you are will create a row where\u000d\u000asome values are null. This can cause an error if there are columns constrained not to\u000d\u000aaccept nulls.\u000d\u000a4.2 Inserting Default Values\u000d\u000aProblem\u000d\u000aA table can be defined to take default values for specific columns. You want to insert a\u000d\u000arow of default values without having to specify those values.\u000d\u000a68 | Chapter 4: Inserting, Updating, and Deleting","Consider the following table:\u000d\u000acreate table D (id integer default 0)\u000d\u000aYou want to insert zero without explicitly specifying zero in the values list of an\u000d\u000aINSERT statement. You want to explicitly insert the default, whatever that default is.\u000d\u000aSolution\u000d\u000aAll brands support the use of the DEFAULT keyword as a way of explicitly specifying\u000d\u000athe default value for a column. Some brands provide additional ways to solve the\u000d\u000aproblem.\u000d\u000aThe following example illustrates the use of the DEFAULT keyword:\u000d\u000ainsert into D values (default)\u000d\u000aYou may also explicitly specify the column name, which you\u2019ll need to do anytime\u000d\u000ayou are not inserting into all columns of a table:\u000d\u000ainsert into D (id) values (default)\u000d\u000aOracle8i Database and prior versions do not support the DEFAULT keyword. Prior to\u000d\u000aOracle9i Database, there was no way to explicitly insert a default column value.\u000d\u000aMySQL allows you to specify an empty values list if all columns have a default value\u000d\u000adefined:\u000d\u000ainsert into D values ()\u000d\u000aIn this case, all columns will be set to their default values.\u000d\u000aPostgreSQL and SQL Server support a DEFAULT VALUES clause:\u000d\u000ainsert into D default values\u000d\u000aThe DEFAULT VALUES clause causes all columns to take on their default values.\u000d\u000aDiscussion\u000d\u000aThe DEFAULT keyword in the values list will insert the value that was specified as the\u000d\u000adefault for a particular column during table creation. The keyword is available for all\u000d\u000aDBMSs.\u000d\u000aMySQL, PostgreSQL, and SQL Server users have another option available if all col\u2010\u000d\u000aumns in the table are defined with a default value (as table D is in this case). You may\u000d\u000ause an empty VALUES list (MySQL) or specify the DEFAULT VALUES clause (Post\u2010\u000d\u000agreSQL and SQL Server) to create a new row with all default values; otherwise, you\u000d\u000aneed to specify DEFAULT for each column in the table.\u000d\u000aFor tables with a mix of default and nondefault columns, inserting default values for a\u000d\u000acolumn is as easy as excluding the column from the insert list; you do not need to use\u000d\u000a4.2 Inserting Default Values | 69","the DEFAULT keyword. Say that table D had an additional column that was not\u000d\u000adefined with a default value:\u000d\u000acreate table D (id integer default 0, foo varchar(10))\u000d\u000aYou can insert a default for ID by listing only FOO in the insert list:\u000d\u000ainsert into D (name) values ('Bar')\u000d\u000aThis statement will result in a row in which ID is 0 and FOO is BAR. ID takes on its\u000d\u000adefault value because no other value is specified.\u000d\u000a4.3 Overriding a Default Value with NULL\u000d\u000aProblem\u000d\u000aYou are inserting into a column having a default value, and you want to override that\u000d\u000adefault value by setting the column to NULL. Consider the following table:\u000d\u000acreate table D (id integer default 0, foo VARCHAR(10))\u000d\u000aYou want to insert a row with a NULL value for ID.\u000d\u000aSolution\u000d\u000aYou can explicitly specify NULL in your values list:\u000d\u000ainsert into d (id, foo) values (null, 'Brighten')\u000d\u000aDiscussion\u000d\u000aNot everyone realizes that you can explicitly specify NULL in the values list of an\u000d\u000aINSERT statement. Typically, when you do not want to specify a value for a column,\u000d\u000ayou leave that column out of your column and values lists:\u000d\u000ainsert into d (foo) values ('Brighten')\u000d\u000aHere, no value for ID is specified. Many would expect the column to taken on the null\u000d\u000avalue, but, alas, a default value was specified at table creation time, so the result of the\u000d\u000apreceding INSERT is that ID takes on the value zero (the default). By specifying\u000d\u000aNULL as the value for a column, you can set the column to NULL despite any default\u000d\u000avalue (excepting where a constraint has been specifically applied to prevent NULLs).\u000d\u000a4.4 Copying Rows from One Table into Another\u000d\u000aProblem\u000d\u000aYou want to copy rows from one table to another by using a query. The query may be\u000d\u000acomplex or simple, but ultimately you want the result to be inserted into another\u000d\u000a70 | Chapter 4: Inserting, Updating, and Deleting","table. For example, you want to copy rows from the DEPT table to the DEPT_EAST\u000d\u000atable. The DEPT_EAST table has already been created with the same structure (same\u000d\u000acolumns and data types) as DEPT and is currently empty.\u000d\u000aSolution\u000d\u000aUse the INSERT statement followed by a query to produce the rows you want:\u000d\u000a1 insert into dept_east (deptno,dname,loc)\u000d\u000a2 select deptno,dname,loc\u000d\u000a3 from dept\u000d\u000a4 where loc in ( 'NEW YORK','BOSTON' )\u000d\u000aDiscussion\u000d\u000aSimply follow the INSERT statement with a query that returns the desired rows. If\u000d\u000ayou want to copy all rows from the source table, exclude the WHERE clause from the\u000d\u000aquery. Like a regular insert, you do not have to explicitly specify which columns you\u000d\u000aare inserting into. But if you do not specify your target columns, you must insert data\u000d\u000ainto all of the table\u2019s columns, and you must be mindful of the order of the values in\u000d\u000athe SELECT list, as described earlier in Recipe 4.1.\u000d\u000a4.5 Copying a Table Definition\u000d\u000aProblem\u000d\u000aYou want to create a new table having the same set of columns as an existing table.\u000d\u000aFor example, you want to create a copy of the DEPT table and call it DEPT_2. You do\u000d\u000anot want to copy the rows, only the column structure of the table.\u000d\u000aSolution\u000d\u000aDB2\u000d\u000aUse the LIKE clause with the CREATE TABLE command:\u000d\u000acreate table dept_2 like dept\u000d\u000aOracle, MySQL, and PostgreSQL\u000d\u000aUse the CREATE TABLE command with a subquery that returns no rows:\u000d\u000a1 create table dept_2\u000d\u000a2 as\u000d\u000a3 select *\u000d\u000a4 from dept\u000d\u000a5 where 1 = 0\u000d\u000a4.5 Copying a Table Definition | 71","SQL Server\u000d\u000aUse the INTO clause with a subquery that returns no rows:\u000d\u000a1 select *\u000d\u000a2 into dept_2\u000d\u000a3 from dept\u000d\u000a4 where 1 = 0\u000d\u000aDiscussion\u000d\u000aDB2\u000d\u000aDB2\u2019s CREATE TABLE\u2026LIKE command allows you to easily use one table as the\u000d\u000apattern for creating another. Simply specify your pattern table\u2019s name following the\u000d\u000aLIKE keyword.\u000d\u000aOracle, MySQL, and PostgreSQL\u000d\u000aWhen using Create Table As Select (CTAS), all rows from your query will be used to\u000d\u000apopulate the new table you are creating unless you specify a false condition in the\u000d\u000aWHERE clause. In the solution provided, the expression \u201c1 = 0\u201d in the WHERE\u000d\u000aclause of the query causes no rows to be returned. Thus, the result of the CTAS state\u2010\u000d\u000ament is an empty table based on the columns in the SELECT clause of the query.\u000d\u000aSQL Server\u000d\u000aWhen using INTO to copy a table, all rows from your query will be used to populate\u000d\u000athe new table you are creating unless you specify a false condition in the WHERE\u000d\u000aclause of your query. In the solution provided, the expression \u201c1 = 0\u201d in the predicate\u000d\u000aof the query causes no rows to be returned. The result is an empty table based on the\u000d\u000acolumns in the SELECT clause of the query.\u000d\u000a4.6 Inserting into Multiple Tables at Once\u000d\u000aProblem\u000d\u000aYou want to take rows returned by a query and insert those rows into multiple target\u000d\u000atables. For example, you want to insert rows from DEPT into tables DEPT_EAST,\u000d\u000aDEPT_WEST, and DEPT_MID. All three tables have the same structure (same col\u2010\u000d\u000aumns and data types) as DEPT and are currently empty.\u000d\u000aSolution\u000d\u000aThe solution is to insert the result of a query into the target tables. The difference\u000d\u000afrom Recipe 4.4 is that for this problem you have multiple target tables.\u000d\u000a72 | Chapter 4: Inserting, Updating, and Deleting","Oracle\u000d\u000aUse either the INSERT ALL or INSERT FIRST statement. Both share the same syntax\u000d\u000aexcept for the choice between the ALL and FIRST keywords. The following statement\u000d\u000auses INSERT ALL to cause all possible target tables to be considered:\u000d\u000a1 insert all\u000d\u000a2 when loc in ('NEW YORK','BOSTON') then\u000d\u000a3 into dept_east (deptno,dname,loc) values (deptno,dname,loc)\u000d\u000a4 when loc = 'CHICAGO' then\u000d\u000a5 into dept_mid (deptno,dname,loc) values (deptno,dname,loc)\u000d\u000a6 else\u000d\u000a7 into dept_west (deptno,dname,loc) values (deptno,dname,loc)\u000d\u000a8 select deptno,dname,loc\u000d\u000a9 from dept\u000d\u000aDB2\u000d\u000aInsert into an inline view that performs a UNION ALL on the tables to be inserted.\u000d\u000aYou must also be sure to place constraints on the tables that will ensure each row goes\u000d\u000ainto the correct table:\u000d\u000acreate table dept_east\u000d\u000a( deptno integer,\u000d\u000a dname varchar(10),\u000d\u000a loc varchar(10) check (loc in ('NEW YORK','BOSTON')))\u000d\u000acreate table dept_mid\u000d\u000a( deptno integer,\u000d\u000a dname varchar(10),\u000d\u000a loc varchar(10) check (loc = 'CHICAGO'))\u000d\u000acreate table dept_west\u000d\u000a( deptno integer,\u000d\u000a dname varchar(10),\u000d\u000a loc varchar(10) check (loc = 'DALLAS'))\u000d\u000a1 insert into (\u000d\u000a2 select * from dept_west union all\u000d\u000a3 select * from dept_east union all\u000d\u000a4 select * from dept_mid\u000d\u000a5 ) select * from dept\u000d\u000aMySQL, PostgreSQL, and SQL Server\u000d\u000aAs of the time of this writing, these vendors do not support multitable inserts.\u000d\u000a4.6 Inserting into Multiple Tables at Once | 73","Discussion\u000d\u000aOracle\u000d\u000aOracle\u2019s multitable insert uses WHEN-THEN-ELSE clauses to evaluate the rows from\u000d\u000athe nested SELECT and insert them accordingly. In this recipe\u2019s example, INSERT\u000d\u000aALL and INSERT FIRST would produce the same result, but there is a difference\u000d\u000abetween the two. INSERT FIRST will break out of the WHEN-THEN-ELSE evalua\u2010\u000d\u000ation as soon as it encounters a condition evaluating to true; INSERT ALL will evalu\u2010\u000d\u000aate all conditions even if prior tests evaluate to true. Thus, you can use INSERT ALL\u000d\u000ato insert the same row into more than one table.\u000d\u000aDB2\u000d\u000aMy DB2 solution is a bit of a hack. It requires that the tables to be inserted into have\u000d\u000aconstraints defined to ensure that each row evaluated from the subquery will go into\u000d\u000athe correct table. The technique is to insert into a view that is defined as the UNION\u000d\u000aALL of the tables. If the check constraints are not unique among the tables in the\u000d\u000aINSERT (i.e., multiple tables have the same check constraint), the INSERT statement\u000d\u000awill not know where to put the rows, and it will fail.\u000d\u000aMySQL, PostgreSQL, and SQL Server\u000d\u000aAs of the time of this writing, only Oracle and DB2 provide mechanisms to insert\u000d\u000arows returned by a query into one or more of several tables within the same\u000d\u000astatement.\u000d\u000a4.7 Blocking Inserts to Certain Columns\u000d\u000aProblem\u000d\u000aYou want to prevent users, or an errant software application, from inserting values\u000d\u000ainto certain table columns. For example, you want to allow a program to insert into\u000d\u000aEMP, but only into the EMPNO, ENAME, and JOB columns.\u000d\u000aSolution\u000d\u000aCreate a view on the table exposing only those columns you want to expose. Then\u000d\u000aforce all inserts to go through that view.\u000d\u000aFor example, to create a view exposing the three columns in EMP:\u000d\u000acreate view new_emps as\u000d\u000aselect empno, ename, job\u000d\u000a from emp\u000d\u000a74 | Chapter 4: Inserting, Updating, and Deleting","Grant access to this view to those users and programs allowed to populate only the\u000d\u000athree fields in the view. Do not grant those users insert access to the EMP table. Users\u000d\u000amay then create new EMP records by inserting into the NEW_EMPS view, but they\u000d\u000awill not be able to provide values for columns other than the three that are specified\u000d\u000ain the view definition.\u000d\u000aDiscussion\u000d\u000aWhen you insert into a simple view such as in the solution, your database server will\u000d\u000atranslate that insert into the underlying table. For example, the following insert:\u000d\u000ainsert into new_emps\u000d\u000a (empno ename, job)\u000d\u000a values (1, 'Jonathan', 'Editor')\u000d\u000awill be translated behind the scenes into:\u000d\u000ainsert into emp\u000d\u000a (empno ename, job)\u000d\u000a values (1, 'Jonathan', 'Editor')\u000d\u000aIt is also possible, but perhaps less useful, to insert into an inline view (currently only\u000d\u000asupported by Oracle):\u000d\u000ainsert into\u000d\u000a (select empno, ename, job\u000d\u000a from emp)\u000d\u000avalues (1, 'Jonathan', 'Editor')\u000d\u000aView insertion is a complex topic. The rules become complicated very quickly for all\u000d\u000abut the simplest of views. If you plan to make use of the ability to insert into views, it\u000d\u000ais imperative that you consult and fully understand your vendor documentation on\u000d\u000athe matter.\u000d\u000a4.8 Modifying Records in a Table\u000d\u000aProblem\u000d\u000aYou want to modify values for some or all rows in a table. For example, you might\u000d\u000awant to increase the salaries of everyone in department 20 by 10%. The following\u000d\u000aresult set shows the DEPTNO, ENAME, and SAL for employees in that department:\u000d\u000aselect deptno,ename,sal\u000d\u000a from emp\u000d\u000a where deptno = 20\u000d\u000a order by 1,3\u000d\u000aDEPTNO ENAME SAL\u000d\u000a------ ---------- ----------\u000d\u000a 20 SMITH 800\u000d\u000a4.8 Modifying Records in a Table | 75"," 20 ADAMS 1100\u000d\u000a 20 JONES 2975\u000d\u000a 20 SCOTT 3000\u000d\u000a 20 FORD 3000\u000d\u000aYou want to bump all the SAL values by 10%.\u000d\u000aSolution\u000d\u000aUse the UPDATE statement to modify existing rows in a database table. For example:\u000d\u000a1 update emp\u000d\u000a2 set sal = sal*1.10\u000d\u000a3 where deptno = 20\u000d\u000aDiscussion\u000d\u000aUse the UPDATE statement along with a WHERE clause to specify which rows to\u000d\u000aupdate; if you exclude a WHERE clause, then all rows are updated. The expression\u000d\u000aSAL*1.10 in this solution returns the salary increased by 10%.\u000d\u000aWhen preparing for a mass update, you may want to preview the results. You can do\u000d\u000athat by issuing a SELECT statement that includes the expressions you plan to put into\u000d\u000ayour SET clauses. The following SELECT shows the result of a 10% salary increase:\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a sal as orig_sal,\u000d\u000a sal*.10 as amt_to_add,\u000d\u000a sal*1.10 as new_sal\u000d\u000a from emp\u000d\u000a where deptno=20\u000d\u000a order by 1,5\u000d\u000aDEPTNO ENAME ORIG_SAL AMT_TO_ADD NEW_SAL\u000d\u000a------ ------ -------- ---------- -------\u000d\u000a 20 SMITH 800 80 880\u000d\u000a 20 ADAMS 1100 110 1210\u000d\u000a 20 JONES 2975 298 3273\u000d\u000a 20 SCOTT 3000 300 3300\u000d\u000a 20 FORD 3000 300 3300\u000d\u000aThe salary increase is broken down into two columns: one to show the increase over\u000d\u000athe old salary, and the other to show the new salary.\u000d\u000a76 | Chapter 4: Inserting, Updating, and Deleting","4.9 Updating When Corresponding Rows Exist\u000d\u000aProblem\u000d\u000aYou want to update rows in one table when corresponding rows exist in another. For\u000d\u000aexample, if an employee appears in table EMP_BONUS, you want to increase that\u000d\u000aemployee\u2019s salary (in table EMP) by 20%. The following result set represents the data\u000d\u000acurrently in table EMP_BONUS:\u000d\u000aselect empno, ename\u000d\u000a from emp_bonus\u000d\u000a EMPNO ENAME\u000d\u000a---------- ---------\u000d\u000a 7369 SMITH\u000d\u000a 7900 JAMES\u000d\u000a 7934 MILLER\u000d\u000aSolution\u000d\u000aUse a subquery in your UPDATE statement\u2019s WHERE clause to find employees in\u000d\u000atable EMP that are also in table EMP_BONUS. Your UPDATE will then act only on\u000d\u000athose rows, enabling you to increase their salary by 20%:\u000d\u000a1 update emp\u000d\u000a2 set sal=sal*1.20\u000d\u000a3 where empno in ( select empno from emp_bonus )\u000d\u000aDiscussion\u000d\u000aThe results from the subquery represent the rows that will be updated in table EMP.\u000d\u000aThe IN predicate tests values of EMPNO from the EMP table to see whether they are\u000d\u000ain the list of EMPNO values returned by the subquery. When they are, the corre\u2010\u000d\u000asponding SAL values are updated.\u000d\u000aAlternatively, you can use EXISTS instead of IN:\u000d\u000aupdate emp\u000d\u000a set sal = sal*1.20\u000d\u000a where exists ( select null\u000d\u000a from emp_bonus\u000d\u000a where emp.empno=emp_bonus.empno )\u000d\u000aYou may be surprised to see NULL in the SELECT list of the EXISTS subquery. Fear\u000d\u000anot, that NULL does not have an adverse effect on the update. Arguably it increases\u000d\u000areadability as it reinforces the fact that, unlike the solution using a subquery with an\u000d\u000aIN operator, what will drive the update (i.e., which rows will be updated) will be con\u2010\u000d\u000atrolled by the WHERE clause of the subquery, not the values returned as a result of\u000d\u000athe subquery\u2019s SELECT list.\u000d\u000a4.9 Updating When Corresponding Rows Exist | 77","4.10 Updating with Values from Another Table\u000d\u000aProblem\u000d\u000aYou want to update rows in one table using values from another. For example, you\u000d\u000ahave a table called NEW_SAL, which holds the new salaries for certain employees.\u000d\u000aThe contents of table NEW_SAL are as follows:\u000d\u000aselect *\u000d\u000a from new_sal\u000d\u000aDEPTNO SAL\u000d\u000a------ ----------\u000d\u000a 10 4000\u000d\u000aColumn DEPTNO is the primary key of table NEW_SAL. You want to update the sal\u2010\u000d\u000aaries and commission of certain employees in table EMP using values table\u000d\u000aNEW_SAL if there is a match between EMP.DEPTNO and NEW_SAL.DEPTNO,\u000d\u000aupdate EMP.SAL to NEW_SAL.SAL, and update EMP.COMM to 50% of\u000d\u000aNEW_SAL.SAL. The rows in EMP are as follows:\u000d\u000aselect deptno,ename,sal,comm\u000d\u000a from emp\u000d\u000a order by 1\u000d\u000aDEPTNO ENAME SAL COMM\u000d\u000a------ ---------- ---------- ----------\u000d\u000a 10 CLARK 2450\u000d\u000a 10 KING 5000\u000d\u000a 10 MILLER 1300\u000d\u000a 20 SMITH 800\u000d\u000a 20 ADAMS 1100\u000d\u000a 20 FORD 3000\u000d\u000a 20 SCOTT 3000\u000d\u000a 20 JONES 2975\u000d\u000a 30 ALLEN 1600 300\u000d\u000a 30 BLAKE 2850\u000d\u000a 30 MARTIN 1250 1400\u000d\u000a 30 JAMES 950\u000d\u000a 30 TURNER 1500 0\u000d\u000a 30 WARD 1250 500\u000d\u000aSolution\u000d\u000aUse a join between NEW_SAL and EMP to find and return the new COMM values to\u000d\u000athe UPDATE statement. It is quite common for updates such as this one to be per\u2010\u000d\u000aformed via correlated subquery or alternatively using a CTE. Another technique\u000d\u000ainvolves creating a view (traditional or inline, depending on what your database sup\u2010\u000d\u000aports) and then updating that view.\u000d\u000a78 | Chapter 4: Inserting, Updating, and Deleting","DB2\u000d\u000aUse a correlated subquery to set new SAL and COMM values in EMP. Also use a cor\u2010\u000d\u000arelated subquery to identify which rows from EMP should be updated:\u000d\u000a1 update emp e set (e.sal,e.comm) = (select ns.sal, ns.sal/2\u000d\u000a2 from new_sal ns\u000d\u000a3 where ns.deptno=e.deptno)\u000d\u000a4 where exists ( select *\u000d\u000a5 from new_sal ns\u000d\u000a6 where ns.deptno = e.deptno )\u000d\u000aMySQL\u000d\u000aInclude both EMP and NEW_SAL in the UPDATE clause of the UPDATE statement\u000d\u000aand join in the WHERE clause:\u000d\u000a1 update emp e, new_sal ns\u000d\u000a2 set e.sal=ns.sal,\u000d\u000a3 e.comm=ns.sal/2\u000d\u000a4 where e.deptno=ns.deptno\u000d\u000aOracle\u000d\u000aThe method for the DB2 solution will work for Oracle, but as an alternative, you can\u000d\u000aupdate an inline view:\u000d\u000a1 update (\u000d\u000a2 select e.sal as emp_sal, e.comm as emp_comm,\u000d\u000a3 ns.sal as ns_sal, ns.sal/2 as ns_comm\u000d\u000a4 from emp e, new_sal ns\u000d\u000a5 where e.deptno = ns.deptno\u000d\u000a6 ) set emp_sal = ns_sal, emp_comm = ns_comm\u000d\u000aPostgreSQL\u000d\u000aThe method used for the DB2 solution will work for PostgreSQL, but you could also\u000d\u000a(quite conveniently) join directly in the UPDATE statement:\u000d\u000a1 update emp\u000d\u000a2 set sal = ns.sal,\u000d\u000a3 comm = ns.sal/2\u000d\u000a4 from new_sal ns\u000d\u000a5 where ns.deptno = emp.deptno\u000d\u000aSQL Server\u000d\u000aThe method used for the DB2 solution will work for SQL Server, but as an alternative\u000d\u000ayou can (similarly to the PostgreSQL solution) join directly in the UPDATE\u000d\u000astatement:\u000d\u000a4.10 Updating with Values from Another Table | 79","1 update e\u000d\u000a2 set e.sal = ns.sal,\u000d\u000a3 e.comm = ns.sal/2\u000d\u000a4 from emp e,\u000d\u000a5 new_sal ns\u000d\u000a6 where ns.deptno = e.deptno\u000d\u000aDiscussion\u000d\u000aBefore discussing the different solutions, it\u2019s worth mentioning something important\u000d\u000aregarding updates that use queries to supply new values. A WHERE clause in the sub\u2010\u000d\u000aquery of a correlated update is not the same as the WHERE clause of the table being\u000d\u000aupdated. If you look at the UPDATE statement in the \u201cProblem\u201d section, the join on\u000d\u000aDEPTNO between EMP and NEW_SAL is done and returns rows to the SET clause\u000d\u000aof the UPDATE statement. For employees in DEPTNO 10, valid values are returned\u000d\u000abecause there is a matching DEPTNO in table NEW_SAL. But what about employees\u000d\u000ain the other departments? NEW_SAL does not have any other departments, so the\u000d\u000aSAL and COMM for employees in DEPTNOs 20 and 30 are set to NULL. Unless you\u000d\u000aare doing so via LIMIT or TOP or whatever mechanism your vendor supplies for\u000d\u000alimiting the number of rows returned in a result set, the only way to restrict rows\u000d\u000afrom a table in SQL is to use a WHERE clause. To correctly perform this UPDATE,\u000d\u000ause a WHERE clause on the table being updated along with a WHERE clause in the\u000d\u000acorrelated subquery.\u000d\u000aDB2\u000d\u000aTo ensure you do not update every row in table EMP, remember to include a correla\u2010\u000d\u000ated subquery in the WHERE clause of the UPDATE. Performing the join (the correla\u2010\u000d\u000ated subquery) in the SET clause is not enough. By using a WHERE clause in the\u000d\u000aUPDATE, you ensure that only rows in EMP that match on DEPTNO to table\u000d\u000aNEW_SAL are updated. This holds true for all RDBMSs.\u000d\u000aOracle\u000d\u000aIn the Oracle solution using the update join view, you are using equi-joins to deter\u2010\u000d\u000amine which rows will be updated. You can confirm which rows are being updated by\u000d\u000aexecuting the query independently. To be able to successfully use this type of\u000d\u000aUPDATE, you must first understand the concept of key-preservation. The DEPTNO\u000d\u000acolumn of the table NEW_SAL is the primary key of that table; thus, its values are\u000d\u000aunique within the table. When joining between EMP and NEW_SAL, however,\u000d\u000aNEW_SAL.DEPTNO is not unique in the result set, as shown here:\u000d\u000aselect e.empno, e.deptno e_dept, ns.sal, ns.deptno ns_deptno\u000d\u000a from emp e, new_sal ns\u000d\u000a where e.deptno = ns.deptno\u000d\u000a80 | Chapter 4: Inserting, Updating, and Deleting","EMPNO E_DEPT SAL NS_DEPTNO\u000d\u000a----- ---------- ---------- ----------\u000d\u000a 7782 10 4000 10\u000d\u000a 7839 10 4000 10\u000d\u000a 7934 10 4000 10\u000d\u000aTo enable Oracle to update this join, one of the tables must be key-preserved, mean\u2010\u000d\u000aing that if its values are not unique in the result set, it should at least be unique in the\u000d\u000atable it comes from. In this case, NEW_SAL has a primary key on DEPTNO, which\u000d\u000amakes it unique in the table. Because it is unique in its table, it may appear multiple\u000d\u000atimes in the result set and will still be considered key-preserved, thus allowing the\u000d\u000aupdate to complete successfully.\u000d\u000aPostgreSQL, SQL Server, and MySQL\u000d\u000aThe syntax is a bit different between these platforms, but the technique is the same.\u000d\u000aBeing able to join directly in the UPDATE statement is extremely convenient. Since\u000d\u000ayou specify which table to update (the table listed after the UPDATE keyword),\u000d\u000athere\u2019s no confusion as to which table\u2019s rows are modified. Additionally, because you\u000d\u000aare using joins in the update (since there is an explicit WHERE clause), you can avoid\u000d\u000asome of the pitfalls when coding correlated subquery updates; in particular, if you\u000d\u000amissed a join here, it would be obvious you\u2019d have a problem.\u000d\u000a4.11 Merging Records\u000d\u000aProblem\u000d\u000aYou want to conditionally insert, update, or delete records in a table depending on\u000d\u000awhether corresponding records exist. (If a record exists, then update; if not, then\u000d\u000ainsert; if after updating a row fails to meet a certain condition, delete it.) For example,\u000d\u000ayou want to modify table EMP_COMMISSION such that:\u000d\u000a\u2022 If any employee in EMP_COMMISSION also exists in table EMP, then update\u000d\u000atheir commission (COMM) to 1000.\u000d\u000a\u2022 For all employees who will potentially have their COMM updated to 1000, if their\u000d\u000aSAL is less than 2000, delete them (they should not be exist in EMP_[.keeptogether] COMMISSION).\u000d\u000a\u2022 Otherwise, insert the EMPNO, ENAME, and DEPTNO values from table EMP\u000d\u000ainto table EMP_COMMISSION.\u000d\u000aEssentially, you want to execute either an UPDATE or an INSERT depending on\u000d\u000awhether a given row from EMP has a match in EMP_COMMISSION. Then you want\u000d\u000ato execute a DELETE if the result of an UPDATE causes a commission that\u2019s too high.\u000d\u000a4.11 Merging Records | 81","The following rows are currently in tables EMP and EMP_COMMISSION,\u000d\u000arespectively:\u000d\u000aselect deptno,empno,ename,comm\u000d\u000a from emp\u000d\u000a order by 1\u000d\u000aDEPTNO EMPNO ENAME COMM\u000d\u000a------ ---------- ------ ----------\u000d\u000a 10 7782 CLARK\u000d\u000a 10 7839 KING\u000d\u000a 10 7934 MILLER\u000d\u000a 20 7369 SMITH\u000d\u000a 20 7876 ADAMS\u000d\u000a 20 7902 FORD\u000d\u000a 20 7788 SCOTT\u000d\u000a 20 7566 JONES\u000d\u000a 30 7499 ALLEN 300\u000d\u000a 30 7698 BLAKE\u000d\u000a 30 7654 MARTIN 1400\u000d\u000a 30 7900 JAMES\u000d\u000a 30 7844 TURNER 0\u000d\u000a 30 7521 WARD 500\u000d\u000aselect deptno,empno,ename,comm\u000d\u000a from emp_commission\u000d\u000a order by 1\u000d\u000a DEPTNO EMPNO ENAME COMM\u000d\u000a---------- ---------- ---------- ----------\u000d\u000a 10 7782 CLARK\u000d\u000a 10 7839 KING\u000d\u000a 10 7934 MILLER\u000d\u000aSolution\u000d\u000aThe statement designed to solve this problem is the MERGE statement, and it can\u000d\u000aperform either an UPDATE or an INSERT, as needed. For example:\u000d\u000a1 merge into emp_commission ec\u000d\u000a2 using (select * from emp) emp\u000d\u000a3 on (ec.empno=emp.empno)\u000d\u000a4 when matched then\u000d\u000a5 update set ec.comm = 1000\u000d\u000a6 delete where (sal < 2000)\u000d\u000a7 when not matched then\u000d\u000a8 insert (ec.empno,ec.ename,ec.deptno,ec.comm)\u000d\u000a9 values (emp.empno,emp.ename,emp.deptno,emp.comm)\u000d\u000aCurrently, MySQL does not have a MERGE statement; otherwise, this query should\u000d\u000awork on any RDBMS in this book, and in a wide number of others.\u000d\u000a82 | Chapter 4: Inserting, Updating, and Deleting","Discussion\u000d\u000aThe join on line 3 of the solution determines what rows already exist and will be\u000d\u000aupdated. The join is between EMP_COMMISSION (aliased as EC) and the subquery\u000d\u000a(aliased as EMP). When the join succeeds, the two rows are considered \u201cmatched,\u201d\u000d\u000aand the UPDATE specified in the WHEN MATCHED clause is executed. Otherwise,\u000d\u000ano match is found, and the INSERT in WHEN NOT MATCHED is executed. Thus,\u000d\u000arows from table EMP that do not have corresponding rows based on EMPNO in table\u000d\u000aEMP_COMMISSION will be inserted into EMP_COMMISSION. Of all the employ\u2010\u000d\u000aees in table EMP, only those in DEPTNO 10 should have their COMM updated in\u000d\u000aEMP_COMMISSION, while the rest of the employees are inserted. Additionally,\u000d\u000asince MILLER is in DEPTNO 10, he is a candidate to have his COMM updated, but\u000d\u000abecause his SAL is less than 2,000, it is deleted from EMP_COMMISSION.\u000d\u000a4.12 Deleting All Records from a Table\u000d\u000aProblem\u000d\u000aYou want to delete all the records from a table.\u000d\u000aSolution\u000d\u000aUse the DELETE command to delete records from a table. For example, to delete all\u000d\u000arecords from EMP, use the following:\u000d\u000adelete from emp\u000d\u000aDiscussion\u000d\u000aWhen using the DELETE command without a WHERE clause, you will delete all\u000d\u000arows from the table specified. Sometimes TRUNCATE, which applies to tables and\u000d\u000atherefore doesn\u2019t use the WHERE clause, is preferred as it is faster. At least in Oracle,\u000d\u000ahowever, TRUNCATE cannot be undone. You should carefully check vendor docu\u2010\u000d\u000amentation for a detailed view of the performance and rollback differences between\u000d\u000aTRUNCATE and DELETE in your specific RDBMS.\u000d\u000a4.13 Deleting Specific Records\u000d\u000aProblem\u000d\u000aYou want to delete records meeting a specific criterion from a table.\u000d\u000a4.12 Deleting All Records from a Table | 83","Solution\u000d\u000aUse the DELETE command with a WHERE clause specifying which rows to delete.\u000d\u000aFor example, to delete all employees in department 10, use the following:\u000d\u000adelete from emp where deptno = 10\u000d\u000aDiscussion\u000d\u000aBy using a WHERE clause with the DELETE command, you can delete a subset of\u000d\u000arows in a table rather than all the rows. Don\u2019t forget to check that you\u2019re deleting the\u000d\u000aright data by previewing the effect of your WHERE clause using SELECT\u2014you can\u000d\u000adelete the wrong data even in a simple situation. For example, in the previous case, a\u000d\u000atypo could lead to the employees in department 20 being deleted instead of depart\u2010\u000d\u000ament 10!\u000d\u000a4.14 Deleting a Single Record\u000d\u000aProblem\u000d\u000aYou want to delete a single record from a table.\u000d\u000aSolution\u000d\u000aThis is a special case of Recipe 4.13. The key is to ensure that your selection criterion\u000d\u000ais narrow enough to specify only the one record that you want to delete. Often you\u000d\u000awill want to delete based on the primary key. For example, to delete employee\u000d\u000aCLARK (EMPNO 7782):\u000d\u000adelete from emp where empno = 7782\u000d\u000aDiscussion\u000d\u000aDeleting is always about identifying the rows to be deleted, and the impact of a\u000d\u000aDELETE always comes down to its WHERE clause. Omit the WHERE clause and the\u000d\u000ascope of a DELETE is the entire table. By writing conditions in the WHERE clause,\u000d\u000ayou can narrow the scope to a group of records or to a single record. When deleting a\u000d\u000asingle record, you should typically be identifying that record based on its primary key\u000d\u000aor on one of its unique keys.\u000d\u000aIf your deletion criterion is based on a primary or unique key, then\u000d\u000ayou can be sure of deleting only one record. (This is because your\u000d\u000aRDBMS will not allow two rows to contain the same primary or\u000d\u000aunique key values.) Otherwise, you may want to check first, to be\u000d\u000asure you aren\u2019t about to inadvertently delete more records than you\u000d\u000aintend.\u000d\u000a84 | Chapter 4: Inserting, Updating, and Deleting","4.15 Deleting Referential Integrity Violations\u000d\u000aProblem\u000d\u000aYou want to delete records from a table when those records refer to nonexistent\u000d\u000arecords in some other table. For example, some employees are assigned to depart\u2010\u000d\u000aments that do not exist. You want to delete those employees.\u000d\u000aSolution\u000d\u000aUse the NOT EXISTS predicate with a subquery to test the validity of department\u000d\u000anumbers:\u000d\u000adelete from emp\u000d\u000a where not exists (\u000d\u000a select * from dept\u000d\u000a where dept.deptno = emp.deptno\u000d\u000a)\u000d\u000aAlternatively, you can write the query using a NOT IN predicate:\u000d\u000adelete from emp\u000d\u000awhere deptno not in (select deptno from dept)\u000d\u000aDiscussion\u000d\u000aDeleting is really all about selecting: the real work lies in writing WHERE clause con\u2010\u000d\u000aditions to correctly describe those records that you want to delete.\u000d\u000aThe NOT EXISTS solution uses a correlated subquery to test for the existence of a\u000d\u000arecord in DEPT having a DEPTNO matching that in a given EMP record. If such a\u000d\u000arecord exists, then the EMP record is retained. Otherwise, it is deleted. Each EMP\u000d\u000arecord is checked in this manner.\u000d\u000aThe IN solution uses a subquery to retrieve a list of valid department numbers.\u000d\u000aDEPTNOs from each EMP record are then checked against that list. When an EMP\u000d\u000arecord is found with a DEPTNO not in the list, the EMP record is deleted.\u000d\u000a4.16 Deleting Duplicate Records\u000d\u000aProblem\u000d\u000aYou want to delete duplicate records from a table. Consider the following table:\u000d\u000acreate table dupes (id integer, name varchar(10))\u000d\u000ainsert into dupes values (1, 'NAPOLEON')\u000d\u000ainsert into dupes values (2, 'DYNAMITE')\u000d\u000a4.15 Deleting Referential Integrity Violations | 85","insert into dupes values (3, 'DYNAMITE')\u000d\u000ainsert into dupes values (4, 'SHE SELLS')\u000d\u000ainsert into dupes values (5, 'SEA SHELLS')\u000d\u000ainsert into dupes values (6, 'SEA SHELLS')\u000d\u000ainsert into dupes values (7, 'SEA SHELLS')\u000d\u000aselect * from dupes order by 1\u000d\u000a ID NAME\u000d\u000a---------- ----------\u000d\u000a 1 NAPOLEON\u000d\u000a 2 DYNAMITE\u000d\u000a 3 DYNAMITE\u000d\u000a 4 SHE SELLS\u000d\u000a 5 SEA SHELLS\u000d\u000a 6 SEA SHELLS\u000d\u000a 7 SEA SHELLS\u000d\u000aFor each group of duplicate names, such as SEA SHELLS, you want to arbitrarily\u000d\u000aretain one ID and delete the rest. In the case of SEA SHELLS, you don\u2019t care whether\u000d\u000ayou delete lines 5 and 6, or lines 5 and 7, or lines 6 and 7, but in the end you want just\u000d\u000aone record for SEA SHELLS.\u000d\u000aSolution\u000d\u000aUse a subquery with an aggregate function such as MIN to arbitrarily choose the ID\u000d\u000ato retain (in this case only the NAME with the smallest value for ID is not deleted):\u000d\u000a1 delete from dupes\u000d\u000a2 where id not in ( select min(id)\u000d\u000a3 from dupes\u000d\u000a4 group by name )\u000d\u000aFor MySQL users you will need slightly different syntax because you cannot reference\u000d\u000athe same table twice in a delete (as of the time of this writing):\u000d\u000a1 delete from dupes\u000d\u000a2 where id not in\u000d\u000a3 (select min(id)\u000d\u000a4 from (select id,name from dupes) tmp\u000d\u000a5 group by name)\u000d\u000aDiscussion\u000d\u000aThe first thing to do when deleting duplicates is to define exactly what it means for\u000d\u000atwo rows to be considered \u201cduplicates\u201d of each other. For my example in this recipe,\u000d\u000athe definition of \u201cduplicate\u201d is that two records contain the same value in their NAME\u000d\u000acolumn. Having that definition in place, you can look to some other column to dis\u2010\u000d\u000acriminate among each set of duplicates, to identify those records to retain. It\u2019s best if\u000d\u000a86 | Chapter 4: Inserting, Updating, and Deleting","this discriminating column (or columns) is a primary key. We used the ID column,\u000d\u000awhich is a good choice because no two records have the same ID.\u000d\u000aThe key to the solution is that you group by the values that are duplicated (by NAME\u000d\u000ain this case), and then use an aggregate function to pick off just one key value to\u000d\u000aretain. The subquery in the \u201cSolution\u201d example will return the smallest ID for each\u000d\u000aNAME, which represents the row you will not delete:\u000d\u000aselect min(id)\u000d\u000a from dupes\u000d\u000a group by name\u000d\u000a MIN(ID)\u000d\u000a-----------\u000d\u000a 2\u000d\u000a 1\u000d\u000a 5\u000d\u000a 4\u000d\u000aThe DELETE then deletes any ID in the table that is not returned by the subquery (in\u000d\u000athis case IDs 3, 6, and 7). If you are having trouble seeing how this works, run the\u000d\u000asubquery first and include the NAME in the SELECT list:\u000d\u000aselect name, min(id)\u000d\u000a from dupes\u000d\u000a group by name\u000d\u000aNAME MIN(ID)\u000d\u000a---------- ----------\u000d\u000aDYNAMITE 2\u000d\u000aNAPOLEON 1\u000d\u000aSEA SHELLS 5\u000d\u000aSHE SELLS 4\u000d\u000aThe rows returned by the subquery represent those to be retained. The NOT IN\u000d\u000apredicate in the DELETE statement causes all other rows to be deleted.\u000d\u000a4.17 Deleting Records Referenced from Another Table\u000d\u000aProblem\u000d\u000aYou want to delete records from one table when those records are referenced from\u000d\u000asome other table. Consider the following table, named DEPT_ACCIDENTS, which\u000d\u000acontains one row for each accident that occurs in a manufacturing business. Each row\u000d\u000arecords the department in which an accident occurred and also the type of accident.\u000d\u000acreate table dept_accidents\u000d\u000a( deptno integer,\u000d\u000a accident_name varchar(20) )\u000d\u000a4.17 Deleting Records Referenced from Another Table | 87","insert into dept_accidents values (10,'BROKEN FOOT')\u000d\u000ainsert into dept_accidents values (10,'FLESH WOUND')\u000d\u000ainsert into dept_accidents values (20,'FIRE')\u000d\u000ainsert into dept_accidents values (20,'FIRE')\u000d\u000ainsert into dept_accidents values (20,'FLOOD')\u000d\u000ainsert into dept_accidents values (30,'BRUISED GLUTE')\u000d\u000aselect * from dept_accidents\u000d\u000a DEPTNO ACCIDENT_NAME\u000d\u000a---------- --------------------\u000d\u000a 10 BROKEN FOOT\u000d\u000a 10 FLESH WOUND\u000d\u000a 20 FIRE\u000d\u000a 20 FIRE\u000d\u000a 20 FLOOD\u000d\u000a 30 BRUISED GLUTE\u000d\u000aYou want to delete from EMP the records for those employees working at a depart\u2010\u000d\u000ament that has three or more accidents.\u000d\u000aSolution\u000d\u000aUse a subquery and the aggregate function COUNT to find the departments with\u000d\u000athree or more accidents. Then delete all employees working in those departments:\u000d\u000a1 delete from emp\u000d\u000a2 where deptno in ( select deptno\u000d\u000a3 from dept_accidents\u000d\u000a4 group by deptno\u000d\u000a5 having count(*) >= 3 )\u000d\u000aDiscussion\u000d\u000aThe subquery will identify which departments have three or more accidents:\u000d\u000aselect deptno\u000d\u000a from dept_accidents\u000d\u000a group by deptno\u000d\u000ahaving count(*) >= 3\u000d\u000a DEPTNO\u000d\u000a----------\u000d\u000a 20\u000d\u000aThe DELETE will then delete any employees in the departments returned by the sub\u2010\u000d\u000aquery (in this case, only in department 20).\u000d\u000a88 | Chapter 4: Inserting, Updating, and Deleting","4.18 Summing Up\u000d\u000aInserting and updating data may seem to take up less of your time than querying\u000d\u000adata, and in the rest of the book we will concentrate on queries. However, being able\u000d\u000ato maintain the data in a database is clearly fundamental to its purpose, and these rec\u2010\u000d\u000aipes are a crucial part of the skill set needed to maintain a database. Some of these\u000d\u000acommands, especially commands that remove or delete data, can have lasting conse\u2010\u000d\u000aquences. Always preview any data you intend to delete to make sure you are really\u000d\u000adeleting what you mean to, and become familiar with what can and can\u2019t be undone\u000d\u000ain your specific RDBMS.\u000d\u000a4.18 Summing Up | 89","","CHAPTER 5\u000d\u000aMetadata Queries\u000d\u000aThis chapter presents recipes that allow you to find information about a given\u000d\u000aschema. For example, you may want to know what tables you\u2019ve created or which for\u2010\u000d\u000aeign keys are not indexed. All of the RDBMSs in this book provide tables and views\u000d\u000afor obtaining such data. The recipes in this chapter will get you started on gleaning\u000d\u000ainformation from those tables and views.\u000d\u000aAlthough at a high level the strategy of storing metadata in tables and views within\u000d\u000athe RDBMS is common, the ultimate implementation is not standardized to the same\u000d\u000adegree as most of the SQL language features covered in this book. Therefore, com\u2010\u000d\u000apared to other chapters, in this chapter having a different solution for each RDBMS is\u000d\u000afar more common.\u000d\u000aThe following is selection of the most common schema queries written for each of the\u000d\u000aRDMSs covered in the book. There is far more information available than the recipes\u000d\u000ain this chapter can show. Consult your RDBMS\u2019s documentation for the complete list\u000d\u000aof catalog or data dictionary tables/views when you need to go beyond what\u2019s presen\u2010\u000d\u000ated here.\u000d\u000aFor the purposes of demonstration, all of the recipes in this chapter\u000d\u000aassume there is a schema named SMEAGOL.\u000d\u000a5.1 Listing Tables in a Schema\u000d\u000aProblem\u000d\u000aYou want to see a list of all the tables you\u2019ve created in a given schema.\u000d\u000a91","Solution\u000d\u000aThe solutions that follow all assume you are working with the SMEAGOL schema.\u000d\u000aThe basic approach to a solution is the same for all RDBMSs: you query a system\u000d\u000atable (or view) containing a row for each table in the database.\u000d\u000aDB2\u000d\u000aQuery SYSCAT.TABLES:\u000d\u000a1 select tabname\u000d\u000a2 from syscat.tables\u000d\u000a3 where tabschema = 'SMEAGOL'\u000d\u000aOracle\u000d\u000aQuery SYS.ALL_TABLES:\u000d\u000aselect table_name\u000d\u000a from all_tables\u000d\u000a where owner = 'SMEAGOL'\u000d\u000aPostgreSQL, MySQL, and SQL Server\u000d\u000aQuery INFORMATION_SCHEMA.TABLES:\u000d\u000a1 select table_name\u000d\u000a2 from information_schema.tables\u000d\u000a3 where table_schema = 'SMEAGOL'\u000d\u000aDiscussion\u000d\u000aIn a delightfully circular manner, databases expose information about themselves\u000d\u000athrough the very mechanisms that you create for your own applications: tables and\u000d\u000aviews. Oracle, for example, maintains an extensive catalog of system views, such as\u000d\u000aALL_TABLES, that you can query for information about tables, indexes, grants, and\u000d\u000aany other database object.\u000d\u000aOracle\u2019s catalog views are just that, views. They are based on an\u000d\u000aunderlying set of tables that contain the information in a userunfriendly form. The views put a usable face on Oracle\u2019s catalog\u000d\u000adata.\u000d\u000aOracle\u2019s system views and DB2\u2019s system tables are each vendor-specific. PostgreSQL,\u000d\u000aMySQL, and SQL Server, on the other hand, support something called the informa\u2010\u000d\u000ation schema, which is a set of views defined by the ISO SQL standard. That\u2019s why the\u000d\u000asame query can work for all three of those databases.\u000d\u000a92 | Chapter 5: Metadata Queries","5.2 Listing a Table\u2019s Columns\u000d\u000aProblem\u000d\u000aYou want to list the columns in a table, along with their data types, and their position\u000d\u000ain the table they are in.\u000d\u000aSolution\u000d\u000aThe following solutions assume that you want to list columns, their data types, and\u000d\u000atheir numeric position in the table named EMP in the schema SMEAGOL.\u000d\u000aDB2\u000d\u000aQuery SYSCAT.COLUMNS:\u000d\u000a1 select colname, typename, colno\u000d\u000a2 from syscat.columns\u000d\u000a3 where tabname = 'EMP'\u000d\u000a4 and tabschema = 'SMEAGOL'\u000d\u000aOracle\u000d\u000aQuery ALL_TAB_COLUMNS:\u000d\u000a1 select column_name, data_type, column_id\u000d\u000a2 from all_tab_columns\u000d\u000a3 where owner = 'SMEAGOL'\u000d\u000a4 and table_name = 'EMP'\u000d\u000aPostgreSQL, MySQL, and SQL Server\u000d\u000aQuery INFORMATION_SCHEMA.COLUMNS:\u000d\u000a1 select column_name, data_type, ordinal_position\u000d\u000a2 from information_schema.columns\u000d\u000a3 where table_schema = 'SMEAGOL'\u000d\u000a4 and table_name = 'EMP'\u000d\u000aDiscussion\u000d\u000aEach vendor provides ways for you to get detailed information about your column\u000d\u000adata. In the previous examples, only the column name, data type, and position are\u000d\u000areturned. Additional useful items of information include length, nullability, and\u000d\u000adefault values.\u000d\u000a5.2 Listing a Table\u2019s Columns | 93","5.3 Listing Indexed Columns for a Table\u000d\u000aProblem\u000d\u000aYou want list indexes, their columns, and the column position (if available) in the\u000d\u000aindex for a given table.\u000d\u000aSolution\u000d\u000aThe vendor-specific solutions that follow all assume that you are listing indexes for\u000d\u000atable EMP in the SMEAGOL schema.\u000d\u000aDB2\u000d\u000aQuery SYSCAT.INDEXES:\u000d\u000a1 select a.tabname, b.indname, b.colname, b.colseq\u000d\u000a2 from syscat.indexes a,\u000d\u000a3 syscat.indexcoluse b\u000d\u000a4 where a.tabname = 'EMP'\u000d\u000a5 and a.tabschema = 'SMEAGOL'\u000d\u000a6 and a.indschema = b.indschema\u000d\u000a7 and a.indname = b.indname\u000d\u000aOracle\u000d\u000aQuery SYS.ALL_IND_COLUMNS:\u000d\u000aselect table_name, index_name, column_name, column_position\u000d\u000a from sys.all_ind_columns\u000d\u000a where table_name = 'EMP'\u000d\u000a and table_owner = 'SMEAGOL'\u000d\u000aPostgreSQL\u000d\u000aQuery PG_CATALOG.PG_INDEXES and INFORMATION_SCHEMA.COLUMNS:\u000d\u000a1 select a.tablename,a.indexname,b.column_name\u000d\u000a2 from pg_catalog.pg_indexes a,\u000d\u000a3 information_schema.columns b\u000d\u000a4 where a.schemaname = 'SMEAGOL'\u000d\u000a5 and a.tablename = b.table_name\u000d\u000aMySQL\u000d\u000aUse the SHOW INDEX command:\u000d\u000ashow index from emp\u000d\u000a94 | Chapter 5: Metadata Queries","SQL Server\u000d\u000aQuery SYS.TABLES, SYS.INDEXES, SYS.INDEX_COLUMNS, and SYS.COLUMNS:\u000d\u000a 1 select a.name table_name,\u000d\u000a 2 b.name index_name,\u000d\u000a 3 d.name column_name,\u000d\u000a 4 c.index_column_id\u000d\u000a 5 from sys.tables a,\u000d\u000a 6 sys.indexes b,\u000d\u000a 7 sys.index_columns c,\u000d\u000a 8 sys.columns d\u000d\u000a 9 where a.object_id = b.object_id\u000d\u000a10 and b.object_id = c.object_id\u000d\u000a11 and b.index_id = c.index_id\u000d\u000a12 and c.object_id = d.object_id\u000d\u000a13 and c.column_id = d.column_id\u000d\u000a14 and a.name = 'EMP'\u000d\u000aDiscussion\u000d\u000aWhen it comes to queries, it\u2019s important to know what columns are/aren\u2019t indexed.\u000d\u000aIndexes can provide good performance for queries against columns that are fre\u2010\u000d\u000aquently used in filters and that are fairly selective. Indexes are also useful when join\u2010\u000d\u000aing between tables. By knowing what columns are indexed, you are already one step\u000d\u000aahead of performance problems if they should occur. Additionally, you might want to\u000d\u000afind information about the indexes themselves: how many levels deep they are, how\u000d\u000amany distinct keys there are, how many leaf blocks there are, and so forth. Such\u000d\u000ainformation is also available from the views/tables queried in this recipe\u2019s solutions.\u000d\u000a5.4 Listing Constraints on a Table\u000d\u000aProblem\u000d\u000aYou want to list the constraints defined for a table in some schema and the columns\u000d\u000athey are defined on. For example, you want to find the constraints and the columns\u000d\u000athey are on for table EMP.\u000d\u000aSolution\u000d\u000aDB2\u000d\u000aQuery SYSCAT.TABCONST and SYSCAT.COLUMNS:\u000d\u000a1 select a.tabname, a.constname, b.colname, a.type\u000d\u000a2 from syscat.tabconst a,\u000d\u000a3 syscat.columns b\u000d\u000a4 where a.tabname = 'EMP'\u000d\u000a5.4 Listing Constraints on a Table | 95","5 and a.tabschema = 'SMEAGOL'\u000d\u000a6 and a.tabname = b.tabname\u000d\u000a7 and a.tabschema = b.tabschema\u000d\u000aOracle\u000d\u000aQuery SYS.ALL_CONSTRAINTS and SYS.ALL_CONS_COLUMNS:\u000d\u000a 1 select a.table_name,\u000d\u000a 2 a.constraint_name,\u000d\u000a 3 b.column_name,\u000d\u000a 4 a.constraint_type\u000d\u000a 5 from all_constraints a,\u000d\u000a 6 all_cons_columns b\u000d\u000a 7 where a.table_name = 'EMP'\u000d\u000a 8 and a.owner = 'SMEAGOL'\u000d\u000a 9 and a.table_name = b.table_name\u000d\u000a10 and a.owner = b.owner\u000d\u000a11 and a.constraint_name = b.constraint_name\u000d\u000aPostgreSQL, MySQL, and SQL Server\u000d\u000aQuery INFORMATION_SCHEMA.TABLE_CONSTRAINTS and INFORMATION_\u000d\u000aSCHEMA.KEY_COLUMN_USAGE:\u000d\u000a 1 select a.table_name,\u000d\u000a 2 a.constraint_name,\u000d\u000a 3 b.column_name,\u000d\u000a 4 a.constraint_type\u000d\u000a 5 from information_schema.table_constraints a,\u000d\u000a 6 information_schema.key_column_usage b\u000d\u000a 7 where a.table_name = 'EMP'\u000d\u000a 8 and a.table_schema = 'SMEAGOL'\u000d\u000a 9 and a.table_name = b.table_name\u000d\u000a10 and a.table_schema = b.table_schema\u000d\u000a11 and a.constraint_name = b.constraint_name\u000d\u000aDiscussion\u000d\u000aConstraints are such a critical part of relational databases that it should go without\u000d\u000asaying why you need to know what constraints are on your tables. Listing the con\u2010\u000d\u000astraints on tables is useful for a variety of reasons: you may want to find tables miss\u2010\u000d\u000aing a primary key, you may want to find which columns should be foreign keys but\u000d\u000aare not (i.e., child tables have data different from the parent tables and you want to\u000d\u000aknow how that happened), or you may want to know about check constraints (Are\u000d\u000acolumns nullable? Do they have to satisfy a specific condition? etc.).\u000d\u000a96 | Chapter 5: Metadata Queries","5.5 Listing Foreign Keys Without Corresponding Indexes\u000d\u000aProblem\u000d\u000aYou want to list tables that have foreign key columns that are not indexed. For exam\u2010\u000d\u000aple, you want to determine whether the foreign keys on table EMP are indexed.\u000d\u000aSolution\u000d\u000aDB2\u000d\u000aQuery SYSCAT.TABCONST, SYSCAT.KEYCOLUSE, SYSCAT.INDEXES, and SYS\u2010\u000d\u000aCAT.INDEXCOLUSE:\u000d\u000a 1 select fkeys.tabname,\u000d\u000a 2 fkeys.constname,\u000d\u000a 3 fkeys.colname,\u000d\u000a 4 ind_cols.indname\u000d\u000a 5 from (\u000d\u000a 6 select a.tabschema, a.tabname, a.constname, b.colname\u000d\u000a 7 from syscat.tabconst a,\u000d\u000a 8 syscat.keycoluse b\u000d\u000a 9 where a.tabname = 'EMP'\u000d\u000a10 and a.tabschema = 'SMEAGOL'\u000d\u000a11 and a.type = 'F'\u000d\u000a12 and a.tabname = b.tabname\u000d\u000a13 and a.tabschema = b.tabschema\u000d\u000a14 ) fkeys\u000d\u000a15 left join\u000d\u000a16 (\u000d\u000a17 select a.tabschema,\u000d\u000a18 a.tabname,\u000d\u000a19 a.indname,\u000d\u000a20 b.colname\u000d\u000a21 from syscat.indexes a,\u000d\u000a22 syscat.indexcoluse b\u000d\u000a23 where a.indschema = b.indschema\u000d\u000a24 and a.indname = b.indname\u000d\u000a25 ) ind_cols\u000d\u000a26 on (fkeys.tabschema = ind_cols.tabschema\u000d\u000a27 and fkeys.tabname = ind_cols.tabname\u000d\u000a28 and fkeys.colname = ind_cols.colname )\u000d\u000a29 where ind_cols.indname is null\u000d\u000aOracle\u000d\u000aQuery SYS.ALL_CONS_COLUMNS, SYS.ALL_CONSTRAINTS, and\u000d\u000aSYS.ALL_IND_COLUMNS:\u000d\u000a5.5 Listing Foreign Keys Without Corresponding Indexes | 97"," 1 select a.table_name,\u000d\u000a 2 a.constraint_name,\u000d\u000a 3 a.column_name,\u000d\u000a 4 c.index_name\u000d\u000a 5 from all_cons_columns a,\u000d\u000a 6 all_constraints b,\u000d\u000a 7 all_ind_columns c\u000d\u000a 8 where a.table_name = 'EMP'\u000d\u000a 9 and a.owner = 'SMEAGOL'\u000d\u000a10 and b.constraint_type = 'R'\u000d\u000a11 and a.owner = b.owner\u000d\u000a12 and a.table_name = b.table_name\u000d\u000a13 and a.constraint_name = b.constraint_name\u000d\u000a14 and a.owner = c.table_owner (+)\u000d\u000a15 and a.table_name = c.table_name (+)\u000d\u000a16 and a.column_name = c.column_name (+)\u000d\u000a17 and c.index_name is null\u000d\u000aPostgreSQL\u000d\u000aQuery INFORMATION_SCHEMA.KEY_COLUMN_USAGE, INFORMATION_\u000d\u000aSCHEMA.REFERENTIAL_CONSTRAINTS, INFORMATION_SCHEMA.COL\u2010\u000d\u000aUMNS, and PG_CATALOG.PG_INDEXES:\u000d\u000a 1 select fkeys.table_name,\u000d\u000a 2 fkeys.constraint_name,\u000d\u000a 3 fkeys.column_name,\u000d\u000a 4 ind_cols.indexname\u000d\u000a 5 from (\u000d\u000a 6 select a.constraint_schema,\u000d\u000a 7 a.table_name,\u000d\u000a 8 a.constraint_name,\u000d\u000a 9 a.column_name\u000d\u000a10 from information_schema.key_column_usage a,\u000d\u000a11 information_schema.referential_constraints b\u000d\u000a12 where a.constraint_name = b.constraint_name\u000d\u000a13 and a.constraint_schema = b.constraint_schema\u000d\u000a14 and a.constraint_schema = 'SMEAGOL'\u000d\u000a15 and a.table_name = 'EMP'\u000d\u000a16 ) fkeys\u000d\u000a17 left join\u000d\u000a18 (\u000d\u000a19 select a.schemaname, a.tablename, a.indexname, b.column_name\u000d\u000a20 from pg_catalog.pg_indexes a,\u000d\u000a21 information_schema.columns b\u000d\u000a22 where a.tablename = b.table_name\u000d\u000a23 and a.schemaname = b.table_schema\u000d\u000a24 ) ind_cols\u000d\u000a25 on ( fkeys.constraint_schema = ind_cols.schemaname\u000d\u000a26 and fkeys.table_name = ind_cols.tablename\u000d\u000a27 and fkeys.column_name = ind_cols.column_name )\u000d\u000a28 where ind_cols.indexname is null\u000d\u000a98 | Chapter 5: Metadata Queries","MySQL\u000d\u000aYou can use the SHOW INDEX command to retrieve index information such as\u000d\u000aindex name, columns in the index, and ordinal position of the columns in the index.\u000d\u000aAdditionally, you can query INFORMATION_SCHEMA.KEY_COLUMN_USAGE\u000d\u000ato list the foreign keys for a given table. In MySQL 5, foreign keys are said to be\u000d\u000aindexed automatically, but can in fact be dropped. To determine whether a foreign\u000d\u000akey column\u2019s index has been dropped, you can execute SHOW INDEX for a particu\u2010\u000d\u000alar table and compare the output with that of INFORMATION_SCHEMA.KEY_\u000d\u000aCOLUMN_USAGE.COLUMN_NAME for the same table. If the COLUMN_NAME\u000d\u000ais listed in KEY_COLUMN_USAGE but is not returned by SHOW INDEX, you\u000d\u000aknow that column is not indexed.\u000d\u000aSQL Server\u000d\u000aQuery SYS.TABLES, SYS.FOREIGN_KEYS, SYS.COLUMNS, SYS.INDEXES, and\u000d\u000aSYS.INDEX_COLUMNS:\u000d\u000a 1 select fkeys.table_name,\u000d\u000a 2 fkeys.constraint_name,\u000d\u000a 3 fkeys.column_name,\u000d\u000a 4 ind_cols.index_name\u000d\u000a 5 from (\u000d\u000a 6 select a.object_id,\u000d\u000a 7 d.column_id,\u000d\u000a 8 a.name table_name,\u000d\u000a 9 b.name constraint_name,\u000d\u000a10 d.name column_name\u000d\u000a11 from sys.tables a\u000d\u000a12 join\u000d\u000a13 sys.foreign_keys b\u000d\u000a14 on ( a.name = 'EMP'\u000d\u000a15 and a.object_id = b.parent_object_id\u000d\u000a16 )\u000d\u000a17 join\u000d\u000a18 sys.foreign_key_columns c\u000d\u000a19 on ( b.object_id = c.constraint_object_id )\u000d\u000a20 join\u000d\u000a21 sys.columns d\u000d\u000a22 on ( c.constraint_column_id = d.column_id\u000d\u000a23 and a.object_id = d.object_id\u000d\u000a24 )\u000d\u000a25 ) fkeys\u000d\u000a26 left join\u000d\u000a27 (\u000d\u000a28 select a.name index_name,\u000d\u000a29 b.object_id,\u000d\u000a30 b.column_id\u000d\u000a31 from sys.indexes a,\u000d\u000a32 sys.index_columns b\u000d\u000a5.5 Listing Foreign Keys Without Corresponding Indexes | 99","33 where a.index_id = b.index_id\u000d\u000a34 ) ind_cols\u000d\u000a35 on ( fkeys.object_id = ind_cols.object_id\u000d\u000a36 and fkeys.column_id = ind_cols.column_id )\u000d\u000a37 where ind_cols.index_name is null\u000d\u000aDiscussion\u000d\u000aEach vendor uses its own locking mechanism when modifying rows. In cases where\u000d\u000athere is a parent-child relationship enforced via foreign key, having indexes on the\u000d\u000achild column(s) can reducing locking (see your specific RDBMS documentation for\u000d\u000adetails). In other cases, it is common that a child table is joined to a parent table on\u000d\u000athe foreign key column, so an index may help improve performance in that scenario\u000d\u000aas well.\u000d\u000a5.6 Using SQL to Generate SQL\u000d\u000aProblem\u000d\u000aYou want to create dynamic SQL statements, perhaps to automate maintenance tasks.\u000d\u000aYou want to accomplish three tasks in particular: count the number of rows in your\u000d\u000atables, disable foreign key constraints defined on your tables, and generate insert\u000d\u000ascripts from the data in your tables.\u000d\u000aSolution\u000d\u000aThe concept is to use strings to build SQL statements, and the values that need to be\u000d\u000afilled in (such as the object name the command acts upon) will be supplied by data\u000d\u000afrom the tables you are selecting from. Keep in mind, the queries only generate the\u000d\u000astatements; you must then run these statements via script, manually, or however you\u000d\u000aexecute your SQL statements. The following examples are queries that would work on\u000d\u000aan Oracle system. For other RDBMSs the technique is exactly the same, the only dif\u2010\u000d\u000aference being things like the names of the data dictionary tables and date formatting.\u000d\u000aThe output shown from the queries that follow are a portion of the rows returned\u000d\u000afrom an instance of Oracle on my laptop. Your result sets will of course vary:\u000d\u000a/* generate SQL to count all the rows in all your tables */\u000d\u000aselect 'select count(*) from '||table_name||';' cnts\u000d\u000a from user_tables;\u000d\u000aCNTS\u000d\u000a----------------------------------------\u000d\u000aselect count(*) from ANT;\u000d\u000aselect count(*) from BONUS;\u000d\u000aselect count(*) from DEMO1;\u000d\u000aselect count(*) from DEMO2;\u000d\u000a100 | Chapter 5: Metadata Queries","select count(*) from DEPT;\u000d\u000aselect count(*) from DUMMY;\u000d\u000aselect count(*) from EMP;\u000d\u000aselect count(*) from EMP_SALES;\u000d\u000aselect count(*) from EMP_SCORE;\u000d\u000aselect count(*) from PROFESSOR;\u000d\u000aselect count(*) from T;\u000d\u000aselect count(*) from T1;\u000d\u000aselect count(*) from T2;\u000d\u000aselect count(*) from T3;\u000d\u000aselect count(*) from TEACH;\u000d\u000aselect count(*) from TEST;\u000d\u000aselect count(*) from TRX_LOG;\u000d\u000aselect count(*) from X;\u000d\u000a/* disable foreign keys from all tables */\u000d\u000aselect 'alter table '||table_name||\u000d\u000a ' disable constraint '||constraint_name||';' cons\u000d\u000a from user_constraints\u000d\u000a where constraint_type = 'R';\u000d\u000aCONS\u000d\u000a------------------------------------------------\u000d\u000aalter table ANT disable constraint ANT_FK;\u000d\u000aalter table BONUS disable constraint BONUS_FK;\u000d\u000aalter table DEMO1 disable constraint DEMO1_FK;\u000d\u000aalter table DEMO2 disable constraint DEMO2_FK;\u000d\u000aalter table DEPT disable constraint DEPT_FK;\u000d\u000aalter table DUMMY disable constraint DUMMY_FK;\u000d\u000aalter table EMP disable constraint EMP_FK;\u000d\u000aalter table EMP_SALES disable constraint EMP_SALES_FK;\u000d\u000aalter table EMP_SCORE disable constraint EMP_SCORE_FK;\u000d\u000aalter table PROFESSOR disable constraint PROFESSOR_FK;\u000d\u000a/* generate an insert script from some columns in table EMP */\u000d\u000aselect 'insert into emp(empno,ename,hiredate) '||chr(10)||\u000d\u000a 'values( '||empno||','||''''||ename\u000d\u000a ||''',to_date('||''''||hiredate||''') );' inserts\u000d\u000a from emp\u000d\u000a where deptno = 10;\u000d\u000aINSERTS\u000d\u000a--------------------------------------------------\u000d\u000ainsert into emp(empno,ename,hiredate)\u000d\u000avalues( 7782,'CLARK',to_date('09-JUN-2006 00:00:00') );\u000d\u000ainsert into emp(empno,ename,hiredate)\u000d\u000avalues( 7839,'KING',to_date('17-NOV-2006 00:00:00') );\u000d\u000a5.6 Using SQL to Generate SQL | 101","insert into emp(empno,ename,hiredate)\u000d\u000avalues( 7934,'MILLER',to_date('23-JAN-2007 00:00:00') );\u000d\u000aDiscussion\u000d\u000aUsing SQL to generate SQL is particularly useful for creating portable scripts such as\u000d\u000ayou might use when testing on multiple environments. Additionally, as can be seen by\u000d\u000athe previous examples, using SQL to generate SQL is useful for performing batch\u000d\u000amaintenance, and for easily finding out information about multiple objects in one go.\u000d\u000aGenerating SQL with SQL is an extremely simple operation, and the more you\u000d\u000aexperiment with it, the easier it will become. The examples provided should give you\u000d\u000aa nice base on how to build your own \u201cdynamic\u201d SQL scripts because, quite frankly,\u000d\u000athere\u2019s not much to it. Work on it and you\u2019ll get it.\u000d\u000a5.7 Describing the Data Dictionary Views in an Oracle\u000d\u000aDatabase\u000d\u000aProblem\u000d\u000aYou are using Oracle. You can\u2019t remember what data dictionary views are available to\u000d\u000ayou, nor can you remember their column definitions. Worse yet, you do not have\u000d\u000aconvenient access to vendor documentation.\u000d\u000aSolution\u000d\u000aThis is an Oracle-specific recipe. Not only does Oracle maintain a robust set of data\u000d\u000adictionary views, but there are also data dictionary views to document the data dic\u2010\u000d\u000ationary views. It\u2019s all so wonderfully circular.\u000d\u000aQuery the view named DICTIONARY to list data dictionary views and their\u000d\u000apurposes:\u000d\u000aselect table_name, comments\u000d\u000a from dictionary\u000d\u000a order by table_name;\u000d\u000aTABLE_NAME COMMENTS\u000d\u000a------------------------------ --------------------------------------------\u000d\u000aALL_ALL_TABLES Description of all object and relational\u000d\u000a tables accessible to the user\u000d\u000aALL_APPLY Details about each apply process that\u000d\u000a dequeues from the queue visible to the\u000d\u000a current user\u000d\u000a\u2026\u000d\u000a102 | Chapter 5: Metadata Queries","Query DICT_COLUMNS to describe the columns in a given data dictionary view:\u000d\u000aselect column_name, comments\u000d\u000a from dict_columns\u000d\u000a where table_name = 'ALL_TAB_COLUMNS';\u000d\u000aCOLUMN_NAME COMMENTS\u000d\u000a------------------------------- --------------------------------------------\u000d\u000aOWNER\u000d\u000aTABLE_NAME Table, view or cluster name\u000d\u000aCOLUMN_NAME Column name\u000d\u000aDATA_TYPE Datatype of the column\u000d\u000aDATA_TYPE_MOD Datatype modifier of the column\u000d\u000aDATA_TYPE_OWNER Owner of the datatype of the column\u000d\u000aDATA_LENGTH Length of the column in bytes\u000d\u000aDATA_PRECISION Length: decimal digits (NUMBER) or binary\u000d\u000a digits (FLOAT)\u000d\u000aDiscussion\u000d\u000aBack in the day, when Oracle\u2019s documentation set wasn\u2019t so freely available on the\u000d\u000aweb, it was incredibly convenient that Oracle made the DICTIONARY and DICT_\u000d\u000aCOLUMNS views available. Knowing just those two views, you could bootstrap to\u000d\u000alearning about all the other views and then shift to learning about your entire\u000d\u000adatabase.\u000d\u000aEven today, it\u2019s convenient to know about DICTIONARY and DICT_COLUMNS.\u000d\u000aOften, if you aren\u2019t quite certain which view describes a given object type, you can\u000d\u000aissue a wildcard query to find out. For example, to get a handle on what views might\u000d\u000adescribe tables in your schema:\u000d\u000aselect table_name, comments\u000d\u000a from dictionary\u000d\u000a where table_name LIKE '%TABLE%'\u000d\u000a order by table_name;\u000d\u000aThis query returns all data dictionary view names that include the term TABLE. This\u000d\u000aapproach takes advantage of Oracle\u2019s fairly consistent data dictionary view naming\u000d\u000aconventions. Views describing tables are all likely to contain TABLE in their name.\u000d\u000a(Sometimes, as in the case of ALL_TAB_COLUMNS, TABLE is abbreviated TAB.)\u000d\u000a5.8 Summing Up\u000d\u000aQueries on metadata open up a range of possibilities for letting SQL do more of the\u000d\u000awork than you, and they relieve some of the need to know your database. This is espe\u2010\u000d\u000acially useful as you deal with more complex databases with similarly complex\u000d\u000astructures.\u000d\u000a5.8 Summing Up | 103","","CHAPTER 6\u000d\u000aWorking with Strings\u000d\u000aThis chapter focuses on string manipulation in SQL. Keep in mind that SQL is not\u000d\u000adesigned to perform complex string manipulation, and you can (and will) find work\u2010\u000d\u000aing with strings in SQL to be cumbersome and frustrating at times. Despite SQL\u2019s lim\u2010\u000d\u000aitations, there are some useful built-in functions provided by the different DBMSs,\u000d\u000aand we\u2019ve tried to use them in creative ways. This chapter in particular is representa\u2010\u000d\u000ative of the message we tried to convey in the introduction; SQL is the good, the bad,\u000d\u000aand the ugly. Hopefully you take away from this chapter a better appreciation for\u000d\u000awhat can and can\u2019t be done in SQL when working with strings. In many cases you\u2019ll\u000d\u000abe surprised by how easy parsing and transforming strings can be, while at other\u000d\u000atimes you\u2019ll be aghast by the kind of SQL that is necessary to accomplish a particular\u000d\u000atask.\u000d\u000aMany of the recipes that follow use the TRANSLATE and REPLACE functions that\u000d\u000aare now available in all the DBMSs covered in this book, with the exception of\u000d\u000aMySQL, which only has replace. In this last case, it is worth noting early on that you\u000d\u000acan replicate the effect of TRANSLATE by using nested REPLACE functions.\u000d\u000aThe first recipe in this chapter is critically important, as it is leveraged by several of\u000d\u000athe subsequent solutions. In many cases, you\u2019d like to have the ability to traverse a\u000d\u000astring by moving through it a character at a time. Unfortunately, SQL does not make\u000d\u000athis easy. Because there is limited loop functionality in SQL, you need to mimic a\u000d\u000aloop to traverse a string. We call this operation \u201cwalking a string\u201d or \u201cwalking\u000d\u000athrough a string,\u201d and the very first recipe explains the technique. This is a funda\u2010\u000d\u000amental operation in string parsing when using SQL, and is referenced and used by\u000d\u000aalmost all recipes in this chapter. We strongly suggest becoming comfortable with\u000d\u000ahow the technique works.\u000d\u000a105","6.1 Walking a String\u000d\u000aProblem\u000d\u000aYou want to traverse a string to return each character as a row, but SQL lacks a loop\u000d\u000aoperation. For example, you want to display the ENAME \u201cKING\u201d from table EMP as\u000d\u000afour rows, where each row contains just characters from KING.\u000d\u000aSolution\u000d\u000aUse a Cartesian product to generate the number of rows needed to return each char\u2010\u000d\u000aacter of a string on its own line. Then use your DBMS\u2019s built-in string parsing func\u2010\u000d\u000ation to extract the characters you are interested in (SQL Server users will use SUB\u2010\u000d\u000aSTRING instead of SUBSTR and DATALENGTH instead of LENGTH):\u000d\u000a1 select substr(e.ename,iter.pos,1) as C\u000d\u000a2 from (select ename from emp where ename = 'KING') e,\u000d\u000a3 (select id as pos from t10) iter\u000d\u000a4 where iter.pos <= length(e.ename)\u000d\u000aC\u000d\u000a-\u000d\u000aK\u000d\u000aI\u000d\u000aN\u000d\u000aG\u000d\u000aDiscussion\u000d\u000aThe key to iterating through a string\u2019s characters is to join against a table that has\u000d\u000aenough rows to produce the required number of iterations. This example uses table\u000d\u000aT10, which contains 10 rows (it has one column, ID, holding the values 1 through\u000d\u000a10). The maximum number of rows that can be returned from this query is 10.\u000d\u000aThe following example shows the Cartesian product between E and ITER (i.e.,\u000d\u000abetween the specific name and the 10 rows from T10) without parsing ENAME:\u000d\u000aselect ename, iter.pos\u000d\u000a from (select ename from emp where ename = 'KING') e,\u000d\u000a (select id as pos from t10) iter\u000d\u000aENAME POS\u000d\u000a---------- ----------\u000d\u000aKING 1\u000d\u000aKING 2\u000d\u000aKING 3\u000d\u000aKING 4\u000d\u000aKING 5\u000d\u000a106 | Chapter 6: Working with Strings","KING 6\u000d\u000aKING 7\u000d\u000aKING 8\u000d\u000aKING 9\u000d\u000aKING 10\u000d\u000aThe cardinality of inline view E is 1, and the cardinality of inline view ITER is 10. The\u000d\u000aCartesian product is then 10 rows. Generating such a product is the first step in mim\u2010\u000d\u000aicking a loop in SQL.\u000d\u000aIt is common practice to refer to table T10 as a \u201cpivot\u201d table.\u000d\u000aThe solution uses a WHERE clause to break out of the loop after four rows have been\u000d\u000areturned. To restrict the result set to the same number of rows as there are characters\u000d\u000ain the name, that WHERE clause specifies ITER.POS <= LENGTH(E. ENAME) as\u000d\u000athe condition:\u000d\u000aselect ename, iter.pos\u000d\u000a from (select ename from emp where ename = 'KING') e,\u000d\u000a (select id as pos from t10) iter\u000d\u000a where iter.pos <= length(e.ename)\u000d\u000aENAME POS\u000d\u000a---------- ----------\u000d\u000aKING 1\u000d\u000aKING 2\u000d\u000aKING 3\u000d\u000aKING 4\u000d\u000aNow that you have one row for each character in E.ENAME, you can use ITER.POS\u000d\u000aas a parameter to SUBSTR, allowing you to navigate through the characters in the\u000d\u000astring. ITER.POS increments with each row, and thus each row can be made to return\u000d\u000aa successive character from E.ENAME. This is how the solution example works.\u000d\u000aDepending on what you are trying to accomplish, you may or may not need to gener\u2010\u000d\u000aate a row for every single character in a string. The following query is an example of\u000d\u000awalking E.ENAME and exposing different portions (more than a single character) of\u000d\u000athe string:\u000d\u000aselect substr(e.ename,iter.pos) a,\u000d\u000a substr(e.ename,length(e.ename)-iter.pos+1) b\u000d\u000a from (select ename from emp where ename = 'KING') e,\u000d\u000a (select id pos from t10) iter\u000d\u000a where iter.pos <= length(e.ename)\u000d\u000a6.1 Walking a String | 107","A B\u000d\u000a---------- ----------\u000d\u000aKING G\u000d\u000aING NG\u000d\u000aNG ING\u000d\u000aG KING\u000d\u000aThe most common scenarios for the recipes in this chapter involve walking the whole\u000d\u000astring to generate a row for each character in the string, or walking the string such\u000d\u000athat the number of rows generated reflects the number of particular characters or\u000d\u000adelimiters that are present in the string.\u000d\u000a6.2 Embedding Quotes Within String Literals\u000d\u000aProblem\u000d\u000aYou want to embed quote marks within string literals. You would like to produce\u000d\u000aresults such as the following with SQL:\u000d\u000aQMARKS\u000d\u000a--------------\u000d\u000ag'day mate\u000d\u000abeavers' teeth\u000d\u000a'\u000d\u000aSolution\u000d\u000aThe following three SELECTs highlight different ways you can create quotes: in the\u000d\u000amiddle of a string and by themselves:\u000d\u000a1 select 'g''day mate' qmarks from t1 union all\u000d\u000a2 select 'beavers'' teeth' from t1 union all\u000d\u000a3 select '''' from t1\u000d\u000aDiscussion\u000d\u000aWhen working with quotes, it\u2019s often useful to think of them like parentheses. When\u000d\u000ayou have an opening parenthesis, you must always have a closing parenthesis. The\u000d\u000asame goes for quotes. Keep in mind that you should always have an even number of\u000d\u000aquotes across any given string. To embed a single quote within a string, you need to\u000d\u000ause two quotes:\u000d\u000aselect 'apples core', 'apple''s core',\u000d\u000a case when '' is null then 0 else 1 end\u000d\u000a from t1\u000d\u000a 'APPLESCORE 'APPLE''SCOR CASEWHEN''ISNULLTHEN0ELSE1END\u000d\u000a ----------- ------------ -----------------------------\u000d\u000a apples core apple's core 0\u000d\u000a108 | Chapter 6: Working with Strings","The following is the solution stripped down to its bare elements. You have two outer\u000d\u000aquotes defining a string literal, and within that string literal, you have two quotes that\u000d\u000atogether represent just one quote in the string that you actually get:\u000d\u000aselect '''' as quote from t1\u000d\u000aQ\u000d\u000a-\u000d\u000a'\u000d\u000aWhen working with quotes, be sure to remember that a string literal comprising two\u000d\u000aquotes alone, with no intervening characters, is NULL.\u000d\u000a6.3 Counting the Occurrences of a Character in a String\u000d\u000aProblem\u000d\u000aYou want to count the number of times a character or substring occurs within a given\u000d\u000astring. Consider the following string:\u000d\u000a10,CLARK,MANAGER\u000d\u000aYou want to determine how many commas are in the string.\u000d\u000aSolution\u000d\u000aSubtract the length of the string without the commas from the original length of the\u000d\u000astring to determine the number of commas in the string. Each DBMS provides func\u2010\u000d\u000ations for obtaining the length of a string and removing characters from a string. In\u000d\u000amost cases, these functions are LENGTH and REPLACE, respectively (SQL Server\u000d\u000ausers will use the built-in function LEN rather than LENGTH):\u000d\u000a1 select (length('10,CLARK,MANAGER')-\u000d\u000a2 length(replace('10,CLARK,MANAGER',',','')))/length(',')\u000d\u000a3 as cnt\u000d\u000a4 from t1\u000d\u000aDiscussion\u000d\u000aYou arrive at the solution by using simple subtraction. The call to LENGTH on line 1\u000d\u000areturns the original size of the string, and the first call to LENGTH on line 2 returns\u000d\u000athe size of the string without the commas, which are removed by REPLACE.\u000d\u000aBy subtracting the two lengths, you obtain the difference in terms of characters,\u000d\u000awhich is the number of commas in the string. The last operation divides the differ\u2010\u000d\u000aence by the length of your search string. This division is necessary if the string you\u000d\u000aare looking for has a length greater than 1. In the following example, counting the\u000d\u000a6.3 Counting the Occurrences of a Character in a String | 109","occurrence of \u201cLL\u201d in the string \u201cHELLO HELLO\u201d without dividing will return an\u000d\u000aincorrect result:\u000d\u000aselect\u000d\u000a (length('HELLO HELLO')-\u000d\u000a length(replace('HELLO HELLO','LL','')))/length('LL')\u000d\u000a as correct_cnt,\u000d\u000a (length('HELLO HELLO')-\u000d\u000a length(replace('HELLO HELLO','LL',''))) as incorrect_cnt\u000d\u000a from t1\u000d\u000aCORRECT_CNT INCORRECT_CNT\u000d\u000a----------- -------------\u000d\u000a 2 4\u000d\u000a6.4 Removing Unwanted Characters from a String\u000d\u000aProblem\u000d\u000aYou want to remove specific characters from your data. A scenario where this may\u000d\u000aoccur is in dealing with badly formatted numeric data, especially currency data,\u000d\u000awhere commas have been used to separate zeros, and currency markers are mixed in\u000d\u000athe column with the quantity. Another scenario is that you want to export data from\u000d\u000ayour database as a CSV file, but there is a text field containing commas, which will be\u000d\u000aread as separators when the CSV file is accessed. Consider this result set:\u000d\u000aENAME SAL\u000d\u000a---------- ----------\u000d\u000aSMITH 800\u000d\u000aALLEN 1600\u000d\u000aWARD 1250\u000d\u000aJONES 2975\u000d\u000aMARTIN 1250\u000d\u000aBLAKE 2850\u000d\u000aCLARK 2450\u000d\u000aSCOTT 3000\u000d\u000aKING 5000\u000d\u000aTURNER 1500\u000d\u000aADAMS 1100\u000d\u000aJAMES 950\u000d\u000aFORD 3000\u000d\u000aMILLER 1300\u000d\u000aYou want to remove all zeros and vowels as shown by the following values in columns\u000d\u000aSTRIPPED1 and STRIPPED2:\u000d\u000aENAME STRIPPED1 SAL STRIPPED2\u000d\u000a---------- ---------- ---------- ---------\u000d\u000aSMITH SMTH 800 8\u000d\u000aALLEN LLN 1600 16\u000d\u000a110 | Chapter 6: Working with Strings","WARD WRD 1250 125\u000d\u000aJONES JNS 2975 2975\u000d\u000aMARTIN MRTN 1250 125\u000d\u000aBLAKE BLK 2850 285\u000d\u000aCLARK CLRK 2450 245\u000d\u000aSCOTT SCTT 3000 3\u000d\u000aKING KNG 5000 5\u000d\u000aTURNER TRNR 1500 15\u000d\u000aADAMS DMS 1100 11\u000d\u000aJAMES JMS 950 95\u000d\u000aFORD FRD 3000 3\u000d\u000aMILLER MLLR 1300 13\u000d\u000aSolution\u000d\u000aEach DBMS provides functions for removing unwanted characters from a string. The\u000d\u000afunctions REPLACE and TRANSLATE are most useful for this problem.\u000d\u000aDB2, Oracle, PostgreSQL, and SQL Server\u000d\u000aUse the built-in functions TRANSLATE and REPLACE to remove unwanted charac\u2010\u000d\u000aters and strings:\u000d\u000a1 select ename,\u000d\u000a2 replace(translate(ename,'aaaaa','AEIOU'),'a','') as stripped1,\u000d\u000a3 sal,\u000d\u000a4 replace(cast(sal as char(4)),'0','') as stripped2\u000d\u000a5 from emp\u000d\u000aNote that for DB2, the AS keyword is optional for assigning a column alias and can\u000d\u000abe left out.\u000d\u000aMySQL\u000d\u000aMySQL does not offer a TRANSLATE function, so several calls to REPLACE are\u000d\u000aneeded:\u000d\u000a 1 select ename,\u000d\u000a 2 replace(\u000d\u000a 3 replace(\u000d\u000a 4 replace(\u000d\u000a 5 replace(\u000d\u000a 6 replace(ename,'A',''),'E',''),'I',''),'O',''),'U','')\u000d\u000a 7 as stripped1,\u000d\u000a 8 sal,\u000d\u000a 9 replace(sal,0,'') stripped2\u000d\u000a10 from emp\u000d\u000a6.4 Removing Unwanted Characters from a String | 111","Discussion\u000d\u000aThe built-in function REPLACE removes all occurrences of zeros. To remove the\u000d\u000avowels, use TRANSLATE to convert all vowels into one specific character (we used\u000d\u000a\u201ca\u201d; you can use any character); then use REPLACE to remove all occurrences of that\u000d\u000acharacter.\u000d\u000a6.5 Separating Numeric and Character Data\u000d\u000aProblem\u000d\u000aYou have numeric data stored with character data together in one column. This could\u000d\u000aeasily happen if you inherit data where units of measurement or currency have been\u000d\u000astored with their quantity (e.g., a column with 100 km, AUD$200, or 40 pounds,\u000d\u000arather than either the column making the units clear or a separate column showing\u000d\u000athe units where necessary).\u000d\u000aYou want to separate the character data from the numeric data. Consider the follow\u2010\u000d\u000aing result set:\u000d\u000aDATA\u000d\u000a---------------\u000d\u000aSMITH800\u000d\u000aALLEN1600\u000d\u000aWARD1250\u000d\u000aJONES2975\u000d\u000aMARTIN1250\u000d\u000aBLAKE2850\u000d\u000aCLARK2450\u000d\u000aSCOTT3000\u000d\u000aKING5000\u000d\u000aTURNER1500\u000d\u000aADAMS1100\u000d\u000aJAMES950\u000d\u000aFORD3000\u000d\u000aMILLER1300\u000d\u000aYou would like the result to be:\u000d\u000aENAME SAL\u000d\u000a---------- ----------\u000d\u000aSMITH 800\u000d\u000aALLEN 1600\u000d\u000aWARD 1250\u000d\u000aJONES 2975\u000d\u000aMARTIN 1250\u000d\u000aBLAKE 2850\u000d\u000aCLARK 2450\u000d\u000aSCOTT 3000\u000d\u000aKING 5000\u000d\u000a112 | Chapter 6: Working with Strings","TURNER 1500\u000d\u000aADAMS 1100\u000d\u000aJAMES 950\u000d\u000aFORD 3000\u000d\u000aMILLER 1300\u000d\u000aSolution\u000d\u000aUse the built-in functions TRANSLATE and REPLACE to isolate the character from\u000d\u000athe numeric data. Like other recipes in this chapter, the trick is to use TRANSLATE\u000d\u000ato transform multiple characters into a single character you can reference. This way\u000d\u000ayou are no longer searching for multiple numbers or characters; rather, you are\u000d\u000asearching for just one character to represent all numbers or one character to repre\u2010\u000d\u000asent all characters.\u000d\u000aDB2\u000d\u000aUse the functions TRANSLATE and REPLACE to isolate and separate the numeric\u000d\u000afrom the character data:\u000d\u000a 1 select replace(\u000d\u000a 2 translate(data,'0000000000','0123456789'),'0','') ename,\u000d\u000a 3 cast(\u000d\u000a 4 replace(\u000d\u000a 5 translate(lower(data),repeat('z',26),\u000d\u000a 6 'abcdefghijklmnopqrstuvwxyz'),'z','') as integer) sal\u000d\u000a 7 from (\u000d\u000a 8 select ename||cast(sal as char(4)) data\u000d\u000a 9 from emp\u000d\u000a10 ) x\u000d\u000aOracle\u000d\u000aUse the functions TRANSLATE and REPLACE to isolate and separate the numeric\u000d\u000afrom the character data:\u000d\u000a 1 select replace(\u000d\u000a 2 translate(data,'0123456789','0000000000'),'0') ename,\u000d\u000a 3 to_number(\u000d\u000a 4 replace(\u000d\u000a 5 translate(lower(data),\u000d\u000a 6 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a 7 rpad('z',26,'z')),'z')) sal\u000d\u000a 8 from (\u000d\u000a 9 select ename||sal data\u000d\u000a10 from emp\u000d\u000a11 )\u000d\u000a6.5 Separating Numeric and Character Data | 113","PostgreSQL\u000d\u000aUse the functions TRANSLATE and REPLACE to isolate and separate the numeric\u000d\u000afrom the character data:\u000d\u000a 1 select replace(\u000d\u000a 2 translate(data,'0123456789','0000000000'),'0','') as ename,\u000d\u000a 3 cast(\u000d\u000a 4 replace(\u000d\u000a 5 translate(lower(data),\u000d\u000a 6 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a 7 rpad('z',26,'z')),'z','') as integer) as sal\u000d\u000a 8 from (\u000d\u000a 9 select ename||sal as data\u000d\u000a10 from emp\u000d\u000a11 ) x\u000d\u000aSQL Server\u000d\u000aUse the functions TRANSLATE and REPLACE to isolate and separate the numeric\u000d\u000afrom the character data:\u000d\u000a 1 select replace(\u000d\u000a 2 translate(data,'0123456789','0000000000'),'0','') as ename,\u000d\u000a 3 cast(\u000d\u000a 4 replace(\u000d\u000a 5 translate(lower(data),\u000d\u000a 6 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a 7 replicate('z',26),'z','') as integer) as sal\u000d\u000a 8 from (\u000d\u000a 9 select concat(ename,sal) as data\u000d\u000a10 from emp\u000d\u000a11 ) x\u000d\u000aDiscussion\u000d\u000aThe syntax is a bit different for each DBMS, but the technique is the same. The syntax\u000d\u000ais slightly different for each DBMS, but the technique is the same; we will use the\u000d\u000aOracle solution for this discussion. The key to solving this problem is to isolate the\u000d\u000anumeric and character data. You can use TRANSLATE and REPLACE to do this. To\u000d\u000aextract the numeric data, first isolate all character data using TRANSLATE:\u000d\u000aselect data,\u000d\u000a translate(lower(data),\u000d\u000a 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a rpad('z',26,'z')) sal\u000d\u000a from (select ename||sal data from emp)\u000d\u000aDATA SAL\u000d\u000a-------------------- -------------------\u000d\u000aSMITH800 zzzzz800\u000d\u000aALLEN1600 zzzzz1600\u000d\u000a114 | Chapter 6: Working with Strings","WARD1250 zzzz1250\u000d\u000aJONES2975 zzzzz2975\u000d\u000aMARTIN1250 zzzzzz1250\u000d\u000aBLAKE2850 zzzzz2850\u000d\u000aCLARK2450 zzzzz2450\u000d\u000aSCOTT3000 zzzzz3000\u000d\u000aKING5000 zzzz5000\u000d\u000aTURNER1500 zzzzzz1500\u000d\u000aADAMS1100 zzzzz1100\u000d\u000aJAMES950 zzzzz950\u000d\u000aFORD3000 zzzz3000\u000d\u000aMILLER1300 zzzzzz1300\u000d\u000aBy using TRANSLATE you convert every nonnumeric character into a lowercase Z.\u000d\u000aThe next step is to remove all instances of lowercase Z from each record using\u000d\u000aREPLACE, leaving only numerical characters that can then be cast to a number:\u000d\u000aselect data,\u000d\u000a to_number(\u000d\u000a replace(\u000d\u000a translate(lower(data),\u000d\u000a 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a rpad('z',26,'z')),'z')) sal\u000d\u000a from (select ename||sal data from emp)\u000d\u000a DATA SAL\u000d\u000a -------------------- ----------\u000d\u000a SMITH800 800\u000d\u000a ALLEN1600 1600\u000d\u000a WARD1250 1250\u000d\u000a JONES2975 2975\u000d\u000a MARTIN1250 1250\u000d\u000a BLAKE2850 2850\u000d\u000a CLARK2450 2450\u000d\u000a SCOTT3000 3000\u000d\u000a KING5000 5000\u000d\u000a TURNER1500 1500\u000d\u000a ADAMS1100 1100\u000d\u000a JAMES950 950\u000d\u000a FORD3000 3000\u000d\u000a MILLER1300 1300\u000d\u000aTo extract the nonnumeric characters, isolate the numeric characters using\u000d\u000aTRANSLATE:\u000d\u000aselect data,\u000d\u000a translate(data,'0123456789','0000000000') ename\u000d\u000a from (select ename||sal data from emp)\u000d\u000a DATA ENAME\u000d\u000a -------------------- ----------\u000d\u000a SMITH800 SMITH000\u000d\u000a ALLEN1600 ALLEN0000\u000d\u000a6.5 Separating Numeric and Character Data | 115"," WARD1250 WARD0000\u000d\u000a JONES2975 JONES0000\u000d\u000a MARTIN1250 MARTIN0000\u000d\u000a BLAKE2850 BLAKE0000\u000d\u000a CLARK2450 CLARK0000\u000d\u000a SCOTT3000 SCOTT0000\u000d\u000a KING5000 KING0000\u000d\u000a TURNER1500 TURNER0000\u000d\u000a ADAMS1100 ADAMS0000\u000d\u000a JAMES950 JAMES000\u000d\u000a FORD3000 FORD0000\u000d\u000a MILLER1300 MILLER0000\u000d\u000aBy using TRANSLATE, you convert every numeric character into a zero. The next\u000d\u000astep is to remove all instances of zero from each record using REPLACE, leaving only\u000d\u000anonnumeric characters:\u000d\u000aselect data,\u000d\u000a replace(translate(data,'0123456789','0000000000'),'0') ename\u000d\u000a from (select ename||sal data from emp)\u000d\u000a DATA ENAME\u000d\u000a -------------------- -------\u000d\u000a SMITH800 SMITH\u000d\u000a ALLEN1600 ALLEN\u000d\u000a WARD1250 WARD\u000d\u000a JONES2975 JONES\u000d\u000a MARTIN1250 MARTIN\u000d\u000a BLAKE2850 BLAKE\u000d\u000a CLARK2450 CLARK\u000d\u000a SCOTT3000 SCOTT\u000d\u000a KING5000 KING\u000d\u000a TURNER1500 TURNER\u000d\u000a ADAMS1100 ADAMS\u000d\u000a JAMES950 JAMES\u000d\u000a FORD3000 FORD\u000d\u000a MILLER1300 MILLER\u000d\u000aPut the two techniques together and you have your solution.\u000d\u000a6.6 Determining Whether a String Is Alphanumeric\u000d\u000aProblem\u000d\u000aYou want to return rows from a table only when a column of interest contains no\u000d\u000acharacters other than numbers and letters. Consider the following view V (SQL\u000d\u000aServer users will use the operator + for concatenation instead of ||):\u000d\u000a116 | Chapter 6: Working with Strings","create view V as\u000d\u000aselect ename as data\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a union all\u000d\u000aselect ename||', $'|| cast(sal as char(4)) ||'.00' as data\u000d\u000a from emp\u000d\u000a where deptno=20\u000d\u000a union all\u000d\u000aselect ename|| cast(deptno as char(4)) as data\u000d\u000a from emp\u000d\u000a where deptno=30\u000d\u000aThe view V represents your table, and it returns the following:\u000d\u000aDATA\u000d\u000a--------------------\u000d\u000aCLARK\u000d\u000aKING\u000d\u000aMILLER\u000d\u000aSMITH, $800.00\u000d\u000aJONES, $2975.00\u000d\u000aSCOTT, $3000.00\u000d\u000aADAMS, $1100.00\u000d\u000aFORD, $3000.00\u000d\u000aALLEN30\u000d\u000aWARD30\u000d\u000aMARTIN30\u000d\u000aBLAKE30\u000d\u000aTURNER30\u000d\u000aJAMES30\u000d\u000aHowever, from the view\u2019s data you want to return only the following records:\u000d\u000aDATA\u000d\u000a-------------\u000d\u000aCLARK\u000d\u000aKING\u000d\u000aMILLER\u000d\u000aALLEN30\u000d\u000aWARD30\u000d\u000aMARTIN30\u000d\u000aBLAKE30\u000d\u000aTURNER30\u000d\u000aJAMES30\u000d\u000aIn short, you want to omit those rows containing data other than letters and digits.\u000d\u000aSolution\u000d\u000aIt may seem intuitive at first to solve the problem by searching for all the possible\u000d\u000anon-alphanumeric characters that can be found in a string, but, on the contrary, you\u000d\u000awill find it easier to do the exact opposite: find all the alphanumeric characters. By\u000d\u000a6.6 Determining Whether a String Is Alphanumeric | 117","doing so, you can treat all the alphanumeric characters as one by converting them to\u000d\u000aone single character. The reason you want to do this is so the alphanumeric\u000d\u000acharacters can be manipulated together, as a whole. Once you\u2019ve generated a copy of\u000d\u000athe string in which all alphanumeric characters are represented by a single character\u000d\u000aof your choosing, it is easy to isolate the alphanumeric characters from any other\u000d\u000acharacters.\u000d\u000aDB2\u000d\u000aUse the function TRANSLATE to convert all alphanumeric characters to a single\u000d\u000acharacter; then identify any rows that have characters other than the converted alpha\u2010\u000d\u000anumeric character. For DB2 users, the CAST function calls in view V are necessary;\u000d\u000aotherwise, the view cannot be created due to type conversion errors. Take extra care\u000d\u000awhen working with casts to CHAR as they are fixed length (padded):\u000d\u000a1 select data\u000d\u000a2 from V\u000d\u000a3 where translate(lower(data),\u000d\u000a4 repeat('a',36),\u000d\u000a5 '0123456789abcdefghijklmnopqrstuvwxyz') =\u000d\u000a6 repeat('a',length(data))\u000d\u000aMySQL\u000d\u000aThe syntax for view V is slightly different in MySQL:\u000d\u000acreate view V as\u000d\u000aselect ename as data\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a union all\u000d\u000aselect concat(ename,', $',sal,'.00') as data\u000d\u000a from emp\u000d\u000a where deptno=20\u000d\u000a union all\u000d\u000aselect concat(ename,deptno) as data\u000d\u000a from emp\u000d\u000a where deptno=30\u000d\u000aUse a regular expression to easily find rows that contain non-alphanumeric data:\u000d\u000a1 select data\u000d\u000a2 from V\u000d\u000a3 where data regexp '[^0-9a-zA-Z]' = 0\u000d\u000aOracle and PostgreSQL\u000d\u000aUse the function TRANSLATE to convert all alphanumeric characters to a single\u000d\u000acharacter; then identify any rows that have characters other than the converted alpha\u2010\u000d\u000anumeric character. The CAST function calls in view V are not needed for Oracle and\u000d\u000a118 | Chapter 6: Working with Strings","PostgreSQL. Take extra care when working with casts to CHAR as they are fixed\u000d\u000alength (padded).\u000d\u000aIf you decide to cast, cast to VARCHAR or VARCHAR2:\u000d\u000a1 select data\u000d\u000a2 from V\u000d\u000a3 where translate(lower(data),\u000d\u000a4 '0123456789abcdefghijklmnopqrstuvwxyz',\u000d\u000a5 rpad('a',36,'a')) = rpad('a',length(data),'a')\u000d\u000aSQL Server\u000d\u000aThe technique is the same, with the exception of there being no RPAD in SQL Server:\u000d\u000a1 select data\u000d\u000a2 from V\u000d\u000a3 where translate(lower(data),\u000d\u000a4 '0123456789abcdefghijklmnopqrstuvwxyz',\u000d\u000a5 replicate('a',36)) = replicate('a',len(data))\u000d\u000aDiscussion\u000d\u000aThe key to these solutions is being able to reference multiple characters concurrently.\u000d\u000aBy using the function TRANSLATE, you can easily manipulate all numbers or all\u000d\u000acharacters without having to \u201citerate\u201d and inspect each character one by one.\u000d\u000aDB2, Oracle, PostgreSQL, and SQL Server\u000d\u000aOnly 9 of the 14 rows from view V are alphanumeric. To find the rows that are alpha\u2010\u000d\u000anumeric only, simply use the function TRANSLATE. In this example, TRANSLATE\u000d\u000aconverts characters 0\u20139 and a\u2013z to \u201ca\u201d. Once the conversion is done, the converted\u000d\u000arow is then compared with a string of all \u201ca\u201d with the same length (as the row). If the\u000d\u000alength is the same, then you know all the characters are alphanumeric and nothing\u000d\u000aelse.\u000d\u000aBy using the TRANSLATE function (using the Oracle syntax):\u000d\u000awhere translate(lower(data),\u000d\u000a '0123456789abcdefghijklmnopqrstuvwxyz',\u000d\u000a rpad('a',36,'a'))\u000d\u000ayou convert all numbers and letters into a distinct character (we chose \u201ca\u201d). Once the\u000d\u000adata is converted, all strings that are indeed alphanumeric can be identified as a string\u000d\u000acomprising only a single character (in this case, \u201ca\u201d). This can be seen by running\u000d\u000aTRANSLATE by itself:\u000d\u000aselect data, translate(lower(data),\u000d\u000a '0123456789abcdefghijklmnopqrstuvwxyz',\u000d\u000a rpad('a',36,'a'))\u000d\u000a from V\u000d\u000a6.6 Determining Whether a String Is Alphanumeric | 119","DATA TRANSLATE(LOWER(DATA)\u000d\u000a-------------------- ---------------------\u000d\u000aCLARK aaaaa\u000d\u000a\u2026\u000d\u000aSMITH, $800.00 aaaaa, $aaa.aa\u000d\u000a\u2026\u000d\u000aALLEN30 aaaaaaa\u000d\u000a\u2026\u000d\u000aThe alphanumeric values are converted, but the string lengths have not been modi\u2010\u000d\u000afied. Because the lengths are the same, the rows to keep are the ones for which the call\u000d\u000ato TRANSLATE returns all \u201ca\"s. You keep those rows, rejecting the others, by com\u2010\u000d\u000aparing each original string\u2019s length with the length of its corresponding string of \u201ca\"s:\u000d\u000aselect data, translate(lower(data),\u000d\u000a '0123456789abcdefghijklmnopqrstuvwxyz',\u000d\u000a rpad('a',36,'a')) translated,\u000d\u000a rpad('a',length(data),'a') fixed\u000d\u000a from V\u000d\u000aDATA TRANSLATED FIXED\u000d\u000a-------------------- -------------------- ----------------\u000d\u000aCLARK aaaaa aaaaa\u000d\u000a\u2026\u000d\u000aSMITH, $800.00 aaaaa, $aaa.aa aaaaaaaaaaaaaa\u000d\u000a\u2026\u000d\u000aALLEN30 aaaaaaa aaaaaaa\u000d\u000a\u2026\u000d\u000aThe last step is to keep only the strings where TRANSLATED equals FIXED.\u000d\u000aMySQL\u000d\u000aThe expression in the WHERE clause:\u000d\u000awhere data regexp '[^0-9a-zA-Z]' = 0\u000d\u000acauses rows that have only numbers or characters to be returned. The value ranges in\u000d\u000athe brackets, \u201c0-9a-zA-Z\u201d, represent all possible numbers and letters. The character ^\u000d\u000ais for negation, so the expression can be stated as \u201cnot numbers or letters.\u201d A return\u000d\u000avalue of 1 is true and 0 is false, so the whole expression can be stated as \u201creturn rows\u000d\u000awhere anything other than numbers and letters is false.\u201d\u000d\u000a6.7 Extracting Initials from a Name\u000d\u000aProblem\u000d\u000aYou want convert a full name into initials. Consider the following name:\u000d\u000aStewie Griffin\u000d\u000a120 | Chapter 6: Working with Strings","You would like to return:\u000d\u000aS.G.\u000d\u000aSolution\u000d\u000aIt\u2019s important to keep in mind that SQL does not provide the flexibility of languages\u000d\u000asuch as C or Python; therefore, creating a generic solution to deal with any name for\u2010\u000d\u000amat is not something particularly easy to do in SQL. The solutions presented here\u000d\u000aexpect the names to be either first and last name, or first, middle name/middle initial,\u000d\u000aand last name.\u000d\u000aDB2\u000d\u000aUse the built-in functions REPLACE, TRANSLATE, and REPEAT to extract the\u000d\u000ainitials:\u000d\u000a1 select replace(\u000d\u000a2 replace(\u000d\u000a3 translate(replace('Stewie Griffin', '.', ''),\u000d\u000a4 repeat('#',26),\u000d\u000a5 'abcdefghijklmnopqrstuvwxyz'),\u000d\u000a6 '#','' ), ' ','.' )\u000d\u000a7 ||'.'\u000d\u000a8 from t1\u000d\u000aMySQL\u000d\u000aUse the built-in functions CONCAT, CONCAT_WS, SUBSTRING, and SUB\u2010\u000d\u000aSTRING_ INDEX to extract the initials:\u000d\u000a 1 select case\u000d\u000a 2 when cnt = 2 then\u000d\u000a 3 trim(trailing '.' from\u000d\u000a 4 concat_ws('.',\u000d\u000a 5 substr(substring_index(name,' ',1),1,1),\u000d\u000a 6 substr(name,\u000d\u000a 7 length(substring_index(name,' ',1))+2,1),\u000d\u000a 8 substr(substring_index(name,' ',-1),1,1),\u000d\u000a 9 '.'))\u000d\u000a10 else\u000d\u000a11 trim(trailing '.' from\u000d\u000a12 concat_ws('.',\u000d\u000a13 substr(substring_index(name,' ',1),1,1),\u000d\u000a14 substr(substring_index(name,' ',-1),1,1)\u000d\u000a15 ))\u000d\u000a16 end as initials\u000d\u000a17 from (\u000d\u000a18 select name,length(name)-length(replace(name,' ','')) as cnt\u000d\u000a19 from (\u000d\u000a20 select replace('Stewie Griffin','.','') as name from t1\u000d\u000a6.7 Extracting Initials from a Name | 121","21 )y\u000d\u000a22 )x\u000d\u000aOracle and PostgreSQL\u000d\u000aUse the built-in functions REPLACE, TRANSLATE, and RPAD to extract the initials:\u000d\u000a1 select replace(\u000d\u000a2 replace(\u000d\u000a3 translate(replace('Stewie Griffin', '.', ''),\u000d\u000a4 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a5 rpad('#',26,'#') ), '#','' ),' ','.' ) ||'.'\u000d\u000a6 from t1\u000d\u000aSQL Server\u000d\u000a1 select replace(\u000d\u000a2 replace(\u000d\u000a3 translate(replace('Stewie Griffin', '.', ''),\u000d\u000a4 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a5 replicate('#',26) ), '#','' ),' ','.' ) + '.'\u000d\u000a6 from t1\u000d\u000aDiscussion\u000d\u000aBy isolating the capital letters, you can extract the initials from a name. The following\u000d\u000asections describe each vendor-specific solution in detail.\u000d\u000aDB2\u000d\u000aThe REPLACE function will remove any periods in the name (to handle middle ini\u2010\u000d\u000atials), and the TRANSLATE function will convert all non-uppercase letters to #.\u000d\u000aselect translate(replace('Stewie Griffin', '.', ''),\u000d\u000a repeat('#',26),\u000d\u000a 'abcdefghijklmnopqrstuvwxyz')\u000d\u000a from t1\u000d\u000aTRANSLATE('STE\u000d\u000a--------------\u000d\u000aS##### G######\u000d\u000aAt this point, the initials are the characters that are not #. The function REPLACE is\u000d\u000athen used to remove all the # characters:\u000d\u000aselect replace(\u000d\u000a translate(replace('Stewie Griffin', '.', ''),\u000d\u000a repeat('#',26),\u000d\u000a 'abcdefghijklmnopqrstuvwxyz'),'#','')\u000d\u000a from t1\u000d\u000a122 | Chapter 6: Working with Strings","REP\u000d\u000a---\u000d\u000aS G\u000d\u000aThe next step is to replace the white space with a period by using REPLACE again:\u000d\u000aselect replace(\u000d\u000a replace(\u000d\u000a translate(replace('Stewie Griffin', '.', ''),\u000d\u000a repeat('#',26),\u000d\u000a 'abcdefghijklmnopqrstuvwxyz'),'#',''),' ','.') || '.'\u000d\u000a from t1\u000d\u000a REPLA\u000d\u000a -----\u000d\u000a S.G\u000d\u000aThe final step is to append a decimal to the end of the initials.\u000d\u000aOracle and PostgreSQL\u000d\u000aThe REPLACE function will remove any periods in the name (to handle middle ini\u2010\u000d\u000atials), and the TRANSLATE function will convert all non-uppercase letters to #.\u000d\u000aselect translate(replace('Stewie Griffin','.',''),\u000d\u000a 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a rpad('#',26,'#'))\u000d\u000a from t1\u000d\u000aTRANSLATE('STE\u000d\u000a--------------\u000d\u000aS##### G######\u000d\u000aAt this point, the initials are the characters that are not #. The function REPLACE is\u000d\u000athen used to remove all the # characters:\u000d\u000aselect replace(\u000d\u000a translate(replace('Stewie Griffin','.',''),\u000d\u000a 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a rpad('#',26,'#')),'#','')\u000d\u000a from t1\u000d\u000aREP\u000d\u000a---\u000d\u000aS G\u000d\u000aThe next step is to replace the white space with a period by using REPLACE again:\u000d\u000aselect replace(\u000d\u000a replace(\u000d\u000a translate(replace('Stewie Griffin','.',''),\u000d\u000a 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a rpad('#',26,'#') ),'#',''),' ','.') || '.'\u000d\u000a from t1\u000d\u000a6.7 Extracting Initials from a Name | 123","REPLA\u000d\u000a-----\u000d\u000aS.G\u000d\u000aThe final step is to append a decimal to the end of the initials.\u000d\u000aMySQL\u000d\u000aThe inline view Y is used to remove any period from the name. The inline view X\u000d\u000afinds the number of white spaces in the name so the SUBSTR function can be called\u000d\u000athe correct number of times to extract the initials. The three calls to SUBSTRING_\u000d\u000aINDEX parse the string into individual names based on the location of the white\u000d\u000aspace. Because there is only a first and last name, the code in the ELSE portion of the\u000d\u000acase statement is executed:\u000d\u000aselect substr(substring_index(name, ' ',1),1,1) as a,\u000d\u000a substr(substring_index(name,' ',-1),1,1) as b\u000d\u000a from (select 'Stewie Griffin' as name from t1) x\u000d\u000aA B\u000d\u000a- -\u000d\u000aS G\u000d\u000aIf the name in question has a middle name or initial, the initial would be returned by\u000d\u000aexecuting:\u000d\u000asubstr(name,length(substring_index(name, ' ',1))+2,1)\u000d\u000awhich finds the end of the first name and then moves two spaces to the beginning of\u000d\u000athe middle name or initial, that is, the start position for SUBSTR. Because only one\u000d\u000acharacter is kept, the middle name or initial is successfully returned. The initials are\u000d\u000athen passed to CONCAT_WS, which separates the initials by a period:\u000d\u000aselect concat_ws('.',\u000d\u000a substr(substring_index(name, ' ',1),1,1),\u000d\u000a substr(substring_index(name,' ',-1),1,1),\u000d\u000a '.' ) a\u000d\u000a from (select 'Stewie Griffin' as name from t1) x\u000d\u000aA\u000d\u000a-----\u000d\u000aS.G..\u000d\u000aThe last step is to trim the extraneous period from the initials.\u000d\u000a124 | Chapter 6: Working with Strings","6.8 Ordering by Parts of a String\u000d\u000aProblem\u000d\u000aYou want to order your result set based on a substring. Consider the following\u000d\u000arecords:\u000d\u000aENAME\u000d\u000a----------\u000d\u000aSMITH\u000d\u000aALLEN\u000d\u000aWARD\u000d\u000aJONES\u000d\u000aMARTIN\u000d\u000aBLAKE\u000d\u000aCLARK\u000d\u000aSCOTT\u000d\u000aKING\u000d\u000aTURNER\u000d\u000aADAMS\u000d\u000aJAMES\u000d\u000aFORD\u000d\u000aMILLER\u000d\u000aYou want the records to be ordered based on the last two characters of each name:\u000d\u000aENAME\u000d\u000a---------\u000d\u000aALLEN\u000d\u000aTURNER\u000d\u000aMILLER\u000d\u000aJONES\u000d\u000aJAMES\u000d\u000aMARTIN\u000d\u000aBLAKE\u000d\u000aADAMS\u000d\u000aKING\u000d\u000aWARD\u000d\u000aFORD\u000d\u000aCLARK\u000d\u000aSMITH\u000d\u000aSCOTT\u000d\u000aSolution\u000d\u000aThe key to this solution is to find and use your DBMS\u2019s built-in function to extract\u000d\u000athe substring on which you want to sort. This is typically done with the SUBSTR\u000d\u000afunction.\u000d\u000a6.8 Ordering by Parts of a String | 125","DB2, Oracle, MySQL, and PostgreSQL\u000d\u000aUse a combination of the built-in functions LENGTH and SUBSTR to order by a spe\u2010\u000d\u000acific part of a string:\u000d\u000a1 select ename\u000d\u000a2 from emp\u000d\u000a3 order by substr(ename,length(ename)-1,)\u000d\u000aSQL Server\u000d\u000aUse functions SUBSTRING and LEN to order by a specific part of a string:\u000d\u000a1 select ename\u000d\u000a2 from emp\u000d\u000a3 order by substring(ename,len(ename)-1,2)\u000d\u000aDiscussion\u000d\u000aBy using a SUBSTR expression in your ORDER BY clause, you can pick any part of a\u000d\u000astring to use in ordering a result set. You\u2019re not limited to SUBSTR either. You can\u000d\u000aorder rows by the result of almost any expression.\u000d\u000a6.9 Ordering by a Number in a String\u000d\u000aProblem\u000d\u000aYou want order your result set based on a number within a string. Consider the fol\u2010\u000d\u000alowing view:\u000d\u000acreate view V as\u000d\u000aselect e.ename ||' '||\u000d\u000a cast(e.empno as char(4))||' '||\u000d\u000a d.dname as data\u000d\u000a from emp e, dept d\u000d\u000a where e.deptno=d.deptno\u000d\u000aThis view returns the following data:\u000d\u000aDATA\u000d\u000a ----------------------------\u000d\u000a CLARK 7782 ACCOUNTING\u000d\u000a KING 7839 ACCOUNTING\u000d\u000a MILLER 7934 ACCOUNTING\u000d\u000a SMITH 7369 RESEARCH\u000d\u000a JONES 7566 RESEARCH\u000d\u000a SCOTT 7788 RESEARCH\u000d\u000a ADAMS 7876 RESEARCH\u000d\u000a FORD 7902 RESEARCH\u000d\u000a ALLEN 7499 SALES\u000d\u000a WARD 7521 SALES\u000d\u000a126 | Chapter 6: Working with Strings"," MARTIN 7654 SALES\u000d\u000a BLAKE 7698 SALES\u000d\u000a TURNER 7844 SALES\u000d\u000a JAMES 7900 SALES\u000d\u000aYou want to order the results based on the employee number, which falls between the\u000d\u000aemployee name and respective department:\u000d\u000aDATA\u000d\u000a---------------------------\u000d\u000aSMITH 7369 RESEARCH\u000d\u000aALLEN 7499 SALES\u000d\u000aWARD 7521 SALES\u000d\u000aJONES 7566 RESEARCH\u000d\u000aMARTIN 7654 SALES\u000d\u000aBLAKE 7698 SALES\u000d\u000aCLARK 7782 ACCOUNTING\u000d\u000aSCOTT 7788 RESEARCH\u000d\u000aKING 7839 ACCOUNTING\u000d\u000aTURNER 7844 SALES\u000d\u000aADAMS 7876 RESEARCH\u000d\u000aJAMES 7900 SALES\u000d\u000aFORD 7902 RESEARCH\u000d\u000aMILLER 7934 ACCOUNTING\u000d\u000aSolution\u000d\u000aEach solution uses functions and syntax specific to its DBMS, but the method (mak\u2010\u000d\u000aing use of the built-in functions REPLACE and TRANSLATE) is the same for each.\u000d\u000aThe idea is to use REPLACE and TRANSLATE to remove nondigits from the strings,\u000d\u000aleaving only the numeric values upon which to sort.\u000d\u000aDB2\u000d\u000aUse the built-in functions REPLACE and TRANSLATE to order by numeric charac\u2010\u000d\u000aters in a string:\u000d\u000a1 select data\u000d\u000a2 from V\u000d\u000a3 order by\u000d\u000a4 cast(\u000d\u000a5 replace(\u000d\u000a6 translate(data,repeat('#',length(data)),\u000d\u000a7 replace(\u000d\u000a8 translate(data,'##########','0123456789'),\u000d\u000a9 '#','')),'#','') as integer)\u000d\u000aOracle\u000d\u000aUse the built-in functions REPLACE and TRANSLATE to order by numeric charac\u2010\u000d\u000aters in a string:\u000d\u000a6.9 Ordering by a Number in a String | 127","1 select data\u000d\u000a2 from V\u000d\u000a3 order by\u000d\u000a4 to_number(\u000d\u000a5 replace(\u000d\u000a6 translate(data,\u000d\u000a7 replace(\u000d\u000a8 translate(data,'0123456789','##########'),\u000d\u000a9 '#'),rpad('#',20,'#')),'#'))\u000d\u000aPostgreSQL\u000d\u000aUse the built-in functions REPLACE and TRANSLATE to order by numeric charac\u2010\u000d\u000aters in a string:\u000d\u000a1 select data\u000d\u000a2 from V\u000d\u000a3 order by\u000d\u000a4 cast(\u000d\u000a5 replace(\u000d\u000a6 translate(data,\u000d\u000a7 replace(\u000d\u000a8 translate(data,'0123456789','##########'),\u000d\u000a9 '#',''),rpad('#',20,'#')),'#','') as integer)\u000d\u000aMySQL\u000d\u000aAs of the time of this writing, MySQL does not provide the TRANSLATE function.\u000d\u000aDiscussion\u000d\u000aThe purpose of view V is only to supply rows on which to demonstrate this recipe\u2019s\u000d\u000asolution. The view simply concatenates several columns from the EMP table. The sol\u2010\u000d\u000aution shows how to take such concatenated text as input and sort it by the employee\u000d\u000anumber embedded within.\u000d\u000aThe ORDER BY clause in each solution may look intimidating, but it performs quite\u000d\u000awell and is straightforward once you examine it piece by piece. To order by the num\u2010\u000d\u000abers in the string, it\u2019s easiest to remove any characters that are not numbers. Once the\u000d\u000anonnumeric characters are removed, all that is left to do is cast the string of numerals\u000d\u000ainto a number and then sort as you see fit. Before examining each function call, it is\u000d\u000aimportant to understand the order in which each function is called. Starting with the\u000d\u000ainnermost call, TRANSLATE (line 8 from each of the original solutions), you see that:\u000d\u000aFrom the innermost call, the sequence of steps is TRANSLATE (line 8); REPLACE\u000d\u000a(line 7) ; TRANSLATE (line 6); REPLACE (line 5). The final step is to use CAST to\u000d\u000areturn the result as a number.\u000d\u000a128 | Chapter 6: Working with Strings","The first step is to convert the numbers into characters that do not exist in the rest of\u000d\u000athe string. For this example, we chose # and used TRANSLATE to convert all nonnu\u2010\u000d\u000americ characters into occurrences of #. For example, the following query shows the\u000d\u000aoriginal data on the left and the results from the first translation:\u000d\u000aselect data,\u000d\u000a translate(data,'0123456789','##########') as tmp\u000d\u000a from V\u000d\u000aDATA TMP\u000d\u000a ------------------------------ -----------------------\u000d\u000a CLARK 7782 ACCOUNTING CLARK #### ACCOUNTING\u000d\u000a KING 7839 ACCOUNTING KING #### ACCOUNTING\u000d\u000a MILLER 7934 ACCOUNTING MILLER #### ACCOUNTING\u000d\u000a SMITH 7369 RESEARCH SMITH #### RESEARCH\u000d\u000a JONES 7566 RESEARCH JONES #### RESEARCH\u000d\u000a SCOTT 7788 RESEARCH SCOTT #### RESEARCH\u000d\u000a ADAMS 7876 RESEARCH ADAMS #### RESEARCH\u000d\u000a FORD 7902 RESEARCH FORD #### RESEARCH\u000d\u000a ALLEN 7499 SALES ALLEN #### SALES\u000d\u000a WARD 7521 SALES WARD #### SALES\u000d\u000a MARTIN 7654 SALES MARTIN #### SALES\u000d\u000a BLAKE 7698 SALES BLAKE #### SALES\u000d\u000a TURNER 7844 SALES TURNER #### SALES\u000d\u000a JAMES 7900 SALES JAMES #### SALES\u000d\u000aTRANSLATE finds the numerals in each string and converts each one to the # char\u2010\u000d\u000aacter. The modified strings are then returned to REPLACE (line 11), which removes\u000d\u000aall occurrences of #:\u000d\u000aselect data,\u000d\u000areplace(\u000d\u000atranslate(data,'0123456789','##########'),'#') as tmp\u000d\u000a from V\u000d\u000aDATA TMP\u000d\u000a ------------------------------ -------------------\u000d\u000a CLARK 7782 ACCOUNTING CLARK ACCOUNTING\u000d\u000a KING 7839 ACCOUNTING KING ACCOUNTING\u000d\u000a MILLER 7934 ACCOUNTING MILLER ACCOUNTING\u000d\u000a SMITH 7369 RESEARCH SMITH RESEARCH\u000d\u000a JONES 7566 RESEARCH JONES RESEARCH\u000d\u000a SCOTT 7788 RESEARCH SCOTT RESEARCH\u000d\u000a ADAMS 7876 RESEARCH ADAMS RESEARCH\u000d\u000a FORD 7902 RESEARCH FORD RESEARCH\u000d\u000a ALLEN 7499 SALES ALLEN SALES\u000d\u000a WARD 7521 SALES WARD SALES\u000d\u000a MARTIN 7654 SALES MARTIN SALES\u000d\u000a BLAKE 7698 SALES BLAKE SALES\u000d\u000a TURNER 7844 SALES TURNER SALES\u000d\u000a JAMES 7900 SALES JAMES SALES\u000d\u000a6.9 Ordering by a Number in a String | 129","The strings are then returned to TRANSLATE once again, but this time it\u2019s the sec\u2010\u000d\u000aond (outermost) TRANSLATE in the solution. TRANSLATE searches the original\u000d\u000astring for any characters that match the characters in TMP. If any are found, they too\u000d\u000aare converted to #s.\u000d\u000aThis conversion allows all nonnumeric characters to be treated as a single character\u000d\u000a(because they are all transformed to the same character):\u000d\u000aselect data, translate(data,\u000d\u000a replace(\u000d\u000a translate(data,'0123456789','##########'),\u000d\u000a '#'),\u000d\u000a rpad('#',length(data),'#')) as tmp\u000d\u000a from V\u000d\u000aDATA TMP\u000d\u000a------------------------------ ---------------------------\u000d\u000aCLARK 7782 ACCOUNTING ########7782###########\u000d\u000aKING 7839 ACCOUNTING ########7839###########\u000d\u000aMILLER 7934 ACCOUNTING ########7934###########\u000d\u000aSMITH 7369 RESEARCH ########7369#########\u000d\u000aJONES 7566 RESEARCH ########7566#########\u000d\u000aSCOTT 7788 RESEARCH ########7788#########\u000d\u000aADAMS 7876 RESEARCH ########7876#########\u000d\u000aFORD 7902 RESEARCH ########7902#########\u000d\u000aALLEN 7499 SALES ########7499######\u000d\u000aWARD 7521 SALES ########7521######\u000d\u000aMARTIN 7654 SALES ########7654######\u000d\u000aBLAKE 7698 SALES ########7698######\u000d\u000aTURNER 7844 SALES ########7844######\u000d\u000aJAMES 7900 SALES ########7900######\u000d\u000aThe next step is to remove all # characters through a call to REPLACE (line 8), leav\u2010\u000d\u000aing you with only numbers:\u000d\u000aselect data, replace(\u000d\u000a translate(data,\u000d\u000a replace(\u000d\u000a translate(data,'0123456789','##########'),\u000d\u000a '#'),\u000d\u000a rpad('#',length(data),'#')),'#') as tmp\u000d\u000a from V\u000d\u000aDATA TMP\u000d\u000a------------------------------ -----------\u000d\u000aCLARK 7782 ACCOUNTING 7782\u000d\u000aKING 7839 ACCOUNTING 7839\u000d\u000aMILLER 7934 ACCOUNTING 7934\u000d\u000aSMITH 7369 RESEARCH 7369\u000d\u000aJONES 7566 RESEARCH 7566\u000d\u000aSCOTT 7788 RESEARCH 7788\u000d\u000aADAMS 7876 RESEARCH 7876\u000d\u000a130 | Chapter 6: Working with Strings","FORD 7902 RESEARCH 7902\u000d\u000aALLEN 7499 SALES 7499\u000d\u000aWARD 7521 SALES 7521\u000d\u000aMARTIN 7654 SALES 7654\u000d\u000aBLAKE 7698 SALES 7698\u000d\u000aTURNER 7844 SALES 7844\u000d\u000aJAMES 7900 SALES 7900\u000d\u000aFinally, cast TMP to a number (line 4) using the appropriate DBMS function (often\u000d\u000aCAST) to accomplish this:\u000d\u000aselect data, to_number(\u000d\u000a replace(\u000d\u000a translate(data,\u000d\u000a replace(\u000d\u000a translate(data,'0123456789','##########'),\u000d\u000a '#'),\u000d\u000a rpad('#',length(data),'#')),'#')) as tmp\u000d\u000a from V\u000d\u000aDATA TMP\u000d\u000a------------------------------ ----------\u000d\u000aCLARK 7782 ACCOUNTING 7782\u000d\u000aKING 7839 ACCOUNTING 7839\u000d\u000aMILLER 7934 ACCOUNTING 7934\u000d\u000aSMITH 7369 RESEARCH 7369\u000d\u000aJONES 7566 RESEARCH 7566\u000d\u000aSCOTT 7788 RESEARCH 7788\u000d\u000aADAMS 7876 RESEARCH 7876\u000d\u000aFORD 7902 RESEARCH 7902\u000d\u000aALLEN 7499 SALES 7499\u000d\u000aWARD 7521 SALES 7521\u000d\u000aMARTIN 7654 SALES 7654\u000d\u000aBLAKE 7698 SALES 7698\u000d\u000aTURNER 7844 SALES 7844\u000d\u000aJAMES 7900 SALES 7900\u000d\u000aWhen developing queries like this, it\u2019s helpful to work with your expressions in the\u000d\u000aSELECT list. That way, you can easily view the intermediate results as you work\u000d\u000atoward a final solution. However, because the point of this recipe is to order the\u000d\u000aresults, ultimately you should place all the function calls into the ORDER BY clause:\u000d\u000aselect data\u000d\u000a from V\u000d\u000a order by\u000d\u000a to_number(\u000d\u000a replace(\u000d\u000a translate( data,\u000d\u000a replace(\u000d\u000a translate( data,'0123456789','##########'),\u000d\u000a '#'),rpad('#',length(data),'#')),'#'))\u000d\u000a6.9 Ordering by a Number in a String | 131","DATA\u000d\u000a---------------------------\u000d\u000aSMITH 7369 RESEARCH\u000d\u000aALLEN 7499 SALES\u000d\u000aWARD 7521 SALES\u000d\u000aJONES 7566 RESEARCH\u000d\u000aMARTIN 7654 SALES\u000d\u000aBLAKE 7698 SALES\u000d\u000aCLARK 7782 ACCOUNTING\u000d\u000aSCOTT 7788 RESEARCH\u000d\u000aKING 7839 ACCOUNTING\u000d\u000aTURNER 7844 SALES\u000d\u000aADAMS 7876 RESEARCH\u000d\u000aJAMES 7900 SALES\u000d\u000aFORD 7902 RESEARCH\u000d\u000aMILLER 7934 ACCOUNTING\u000d\u000aAs a final note, the data in the view is comprised of three fields, only one being\u000d\u000anumeric. Keep in mind that if there had been multiple numeric fields, they would\u000d\u000ahave all been concatenated into one number before the rows were sorted.\u000d\u000a6.10 Creating a Delimited List from Table Rows\u000d\u000aProblem\u000d\u000aYou want to return table rows as values in a delimited list, perhaps delimited by com\u2010\u000d\u000amas, rather than in vertical columns as they normally appear. You want to convert a\u000d\u000aresult set from this:\u000d\u000aDEPTNO EMPS\u000d\u000a------ ----------\u000d\u000a 10 CLARK\u000d\u000a 10 KING\u000d\u000a 10 MILLER\u000d\u000a 20 SMITH\u000d\u000a 20 ADAMS\u000d\u000a 20 FORD\u000d\u000a 20 SCOTT\u000d\u000a 20 JONES\u000d\u000a 30 ALLEN\u000d\u000a 30 BLAKE\u000d\u000a 30 MARTIN\u000d\u000a 30 JAMES\u000d\u000a 30 TURNER\u000d\u000a 30 WARD\u000d\u000ato this:\u000d\u000a DEPTNO EMPS\u000d\u000a------- ------------------------------------\u000d\u000a 10 CLARK,KING,MILLER\u000d\u000a132 | Chapter 6: Working with Strings"," 20 SMITH,JONES,SCOTT,ADAMS,FORD\u000d\u000a 30 ALLEN,WARD,MARTIN,BLAKE,TURNER,JAMES\u000d\u000aSolution\u000d\u000aEach DBMS requires a different approach to this problem. The key is to take advan\u2010\u000d\u000atage of the built-in functions provided by your DBMS. Understanding what is avail\u2010\u000d\u000aable to you will allow you to exploit your DBMS\u2019s functionality and come up with\u000d\u000acreative solutions for a problem that is typically not solved in SQL.\u000d\u000aMost DBMSs have now adopted a function specifically designed to concatenate\u000d\u000astrings, such as MySQL\u2019s GROUP_CONCAT function (one of the earliest) or\u000d\u000aSTRING_ADD (added to SQL Server as recently as SQL Server 2017). These func\u2010\u000d\u000ations have similar syntax, and make this task straightforward.\u000d\u000aDB2\u000d\u000aUse LIST_AGG to build the delimited list:\u000d\u000a1 select deptno,\u000d\u000a2 list_agg(ename ',') within GROUP(Order by 0) as emps\u000d\u000a3 from emp\u000d\u000a4 group by deptno\u000d\u000aMySQL\u000d\u000aUse the built-in function GROUP_CONCAT to build the delimited list:\u000d\u000a1 select deptno,\u000d\u000a2 group_concat(ename order by empno separator, ',') as emps\u000d\u000a3 from emp\u000d\u000a4 group by deptno\u000d\u000aOracle\u000d\u000aUse the built-in function SYS_CONNECT_BY_PATH to build the delimited list:\u000d\u000a 1 select deptno,\u000d\u000a 2 ltrim(sys_connect_by_path(ename,','),',') emps\u000d\u000a 3 from (\u000d\u000a 4 select deptno,\u000d\u000a 5 ename,\u000d\u000a 6 row_number() over\u000d\u000a 7 (partition by deptno order by empno) rn,\u000d\u000a 8 count(*) over\u000d\u000a 9 (partition by deptno) cnt\u000d\u000a10 from emp\u000d\u000a11 )\u000d\u000a12 where level = cnt\u000d\u000a13 start with rn = 1\u000d\u000a14 connect by prior deptno = deptno and prior rn = rn-1\u000d\u000a6.10 Creating a Delimited List from Table Rows | 133","PostgreSQL and SQL Server\u000d\u000a1 select deptno,\u000d\u000a2 string_agg(ename order by empno separator, ',') as emps\u000d\u000a3 from emp\u000d\u000a4 group by deptno\u000d\u000aDiscussion\u000d\u000aBeing able to create delimited lists in SQL is useful because it is a common require\u2010\u000d\u000ament. The SQL:2016 standard added LIST_AGG to perform this task, but only DB2\u000d\u000ahas implemented this function so far. Thankfully, other DBMS have similar functions,\u000d\u000aoften with simpler syntax.\u000d\u000aMySQL\u000d\u000aThe function GROUP_CONCAT in MySQL concatenates the values found in the col\u2010\u000d\u000aumn passed to it, in this case ENAME. It\u2019s an aggregate function, thus the need for\u000d\u000aGROUP BY in the query.\u000d\u000aPostgreSQL and SQL Server\u000d\u000aThe STRING_AGG function syntax is similar enough to GROUP_CONCAT that the\u000d\u000asame query can be used with the GROUP_CONCAT simply changed to\u000d\u000aSTRING_AGG.\u000d\u000aOracle\u000d\u000aThe first step to understanding the Oracle query is to break it down. Running the\u000d\u000ainline view by itself (lines 4\u201310), you generate a result set that includes the following\u000d\u000afor each employee: her department, her name, a rank within her respective depart\u2010\u000d\u000ament that is derived by an ascending sort on EMPNO, and a count of all employees in\u000d\u000aher department. For example:\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a row_number() over\u000d\u000a (partition by deptno order by empno) rn,\u000d\u000a count(*) over (partition by deptno) cnt\u000d\u000a from emp\u000d\u000aDEPTNO ENAME RN CNT\u000d\u000a------ ---------- -- ---\u000d\u000a 10 CLARK 1 3\u000d\u000a 10 KING 2 3\u000d\u000a 10 MILLER 3 3\u000d\u000a 20 SMITH 1 5\u000d\u000a 20 JONES 2 5\u000d\u000a 20 SCOTT 3 5\u000d\u000a 20 ADAMS 4 5\u000d\u000a134 | Chapter 6: Working with Strings"," 20 FORD 5 5\u000d\u000a 30 ALLEN 1 6\u000d\u000a 30 WARD 2 6\u000d\u000a 30 MARTIN 3 6\u000d\u000a 30 BLAKE 4 6\u000d\u000a 30 TURNER 5 6\u000d\u000a 30 JAMES 6 6\u000d\u000aThe purpose of the rank (aliased RN in the query) is to allow you to walk the tree. \u000d\u000aSince the function ROW_NUMBER generates an enumeration starting from one\u000d\u000awith no duplicates or gaps, just subtract one (from the current value) to reference a\u000d\u000aprior (or parent) row. For example, the number prior to 3 is 3 minus 1, which equals\u000d\u000a2. In this context, 2 is the parent of 3; you can observe this on line 12. Additionally,\u000d\u000athe lines:\u000d\u000astart with rn = 1\u000d\u000aconnect by prior deptno = deptno\u000d\u000aidentify the root for each DEPTNO as having RN equal to 1 and create a new list\u000d\u000awhenever a new department is encountered (whenever a new occurrence of 1 is\u000d\u000afound for RN).\u000d\u000aAt this point, it\u2019s important to stop and look at the ORDER BY portion of the\u000d\u000aROW_NUMBER function. Keep in mind the names are ranked by EMPNO, and the\u000d\u000alist will be created in that order. The number of employees per department is calcula\u2010\u000d\u000ated (aliased CNT) and is used to ensure that the query returns only the list that has all\u000d\u000athe employee names for a department. This is done because SYS_CONNECT_\u000d\u000aBY_PATH builds the list iteratively, and you do not want to end up with partial lists.\u000d\u000aFor hierarchical queries, the pseudocolumn LEVEL starts with 1 (for queries not\u000d\u000ausing CONNECT BY, LEVEL is 0, unless you are on release 10g and later when\u000d\u000aLEVEL is available only when using CONNECT BY) and increments by one after\u000d\u000aeach employee in a department has been evaluated (for each level of depth in the\u000d\u000ahierarchy). Because of this, you know that once LEVEL reaches CNT, you have\u000d\u000areached the last EMPNO and will have a complete list.\u000d\u000aThe SYS_CONNECT_BY_PATH function prefixes the list with\u000d\u000ayour chosen delimiter (in this case, a comma). You may or may not\u000d\u000awant that behavior. In this recipe\u2019s solution, the call to the function\u000d\u000aLTRIM removes the leading comma from the list.\u000d\u000a6.10 Creating a Delimited List from Table Rows | 135","6.11 Converting Delimited Data into a Multivalued IN-List\u000d\u000aProblem\u000d\u000aYou have delimited data that you want to pass to the IN-list iterator of a WHERE\u000d\u000aclause. Consider the following string:\u000d\u000a7654,7698,7782,7788\u000d\u000aYou would like to use the string in a WHERE clause, but the following SQL fails\u000d\u000abecause EMPNO is a numeric column:\u000d\u000aselect ename,sal,deptno\u000d\u000a from emp\u000d\u000a where empno in ( '7654,7698,7782,7788' )\u000d\u000aThis SQL fails because, while EMPNO is a numeric column, the IN list is composed\u000d\u000aof a single string value. You want that string to be treated as a comma-delimited list of\u000d\u000anumeric values.\u000d\u000aSolution\u000d\u000aOn the surface it may seem that SQL should do the work of treating a delimited string\u000d\u000aas a list of delimited values for you, but that is not the case. When a comma embed\u2010\u000d\u000aded within quotes is encountered, SQL can\u2019t possibly know that signals a multivalued\u000d\u000alist. SQL must treat everything between the quotes as a single entity, as one string\u000d\u000avalue. You must break the string up into individual EMPNOs. The key to this solu\u2010\u000d\u000ation is to walk the string, but not into individual characters. You want to walk the\u000d\u000astring into valid EMPNO values.\u000d\u000aDB2\u000d\u000aBy walking the string passed to the IN-list, you can easily convert it to rows. The\u000d\u000afunctions ROW_NUMBER, LOCATE, and SUBSTR are particularly useful here:\u000d\u000a 1 select empno,ename,sal,deptno\u000d\u000a 2 from emp\u000d\u000a 3 where empno in (\u000d\u000a 4 select cast(substr(c,2,locate(',',c,2)-2) as integer) empno\u000d\u000a 5 from (\u000d\u000a 6 select substr(csv.emps,cast(iter.pos as integer)) as c\u000d\u000a 7 from (select ','||'7654,7698,7782,7788'||',' emps\u000d\u000a 8 from t1) csv,\u000d\u000a 9 (select id as pos\u000d\u000a10 from t100 ) iter\u000d\u000a11 where iter.pos <= length(csv.emps)\u000d\u000a12 ) x\u000d\u000a13 where length(c) > 1\u000d\u000a14 and substr(c,1,1) = ','\u000d\u000a15 )\u000d\u000a136 | Chapter 6: Working with Strings","MySQL\u000d\u000aBy walking the string passed to the IN-list, you can easily convert it to rows:\u000d\u000a 1 select empno, ename, sal, deptno\u000d\u000a 2 from emp\u000d\u000a 3 where empno in\u000d\u000a 4 (\u000d\u000a 5 select substring_index(\u000d\u000a 6 substring_index(list.vals,',',iter.pos),',',-1) empno\u000d\u000a 7 from (select id pos from t10) as iter,\u000d\u000a 8 (select '7654,7698,7782,7788' as vals\u000d\u000a 9 from t1) list\u000d\u000a10 where iter.pos <=\u000d\u000a11 (length(list.vals)-length(replace(list.vals,',','')))+1\u000d\u000a12 )\u000d\u000aOracle\u000d\u000aBy walking the string passed to the IN-list, you can easily convert it to rows. The\u000d\u000afunctions ROWNUM, SUBSTR, and INSTR are particularly useful here:\u000d\u000a 1 select empno,ename,sal,deptno\u000d\u000a 2 from emp\u000d\u000a 3 where empno in (\u000d\u000a 4 select to_number(\u000d\u000a 5 rtrim(\u000d\u000a 6 substr(emps,\u000d\u000a 7 instr(emps,',',1,iter.pos)+1,\u000d\u000a 8 instr(emps,',',1,iter.pos+1)\u000d\u000a 9 instr(emps,',',1,iter.pos)),',')) emps\u000d\u000a10 from (select ','||'7654,7698,7782,7788'||',' emps from t1) csv,\u000d\u000a11 (select rownum pos from emp) iter\u000d\u000a12 where iter.pos <= ((length(csv.emps)-\u000d\u000a13 length(replace(csv.emps,',')))/length(','))-1\u000d\u000a14 )\u000d\u000aPostgreSQL\u000d\u000aBy walking the string passed to the IN-list, you can easily convert it to rows. The\u000d\u000afunction SPLIT_PART makes it easy to parse the string into individual numbers:\u000d\u000a 1 select ename,sal,deptno\u000d\u000a 2 from emp\u000d\u000a 3 where empno in (\u000d\u000a 4 select cast(empno as integer) as empno\u000d\u000a 5 from (\u000d\u000a 6 select split_part(list.vals,',',iter.pos) as empno\u000d\u000a 7 from (select id as pos from t10) iter,\u000d\u000a 8 (select ','||'7654,7698,7782,7788'||',' as vals\u000d\u000a 9 from t1) list\u000d\u000a10 where iter.pos <=\u000d\u000a11 length(list.vals)-length(replace(list.vals,',',''))\u000d\u000a6.11 Converting Delimited Data into a Multivalued IN-List | 137","12 ) z\u000d\u000a13 where length(empno) > 0\u000d\u000a14 )\u000d\u000aSQL Server\u000d\u000aBy walking the string passed to the IN-list, you can easily convert it to rows. The\u000d\u000afunctions ROW_NUMBER, CHARINDEX, and SUBSTRING are particularly useful\u000d\u000ahere:\u000d\u000a 1 select empno,ename,sal,deptno\u000d\u000a 2 from emp\u000d\u000a 3 where empno in (select substring(c,2,charindex(',',c,2)-2) as empno\u000d\u000a 4 from (\u000d\u000a 5 select substring(csv.emps,iter.pos,len(csv.emps)) as c\u000d\u000a 6 from (select ','+'7654,7698,7782,7788'+',' as emps\u000d\u000a 7 from t1) csv,\u000d\u000a 8 (select id as pos\u000d\u000a 9 from t100) iter\u000d\u000a10 where iter.pos <= len(csv.emps)\u000d\u000a11 ) x\u000d\u000a12 where len(c) > 1\u000d\u000a13 and substring(c,1,1) = ','\u000d\u000a14 )\u000d\u000aDiscussion\u000d\u000aThe first and most important step in this solution is to walk the string. Once you\u2019ve\u000d\u000aaccomplished that, all that\u2019s left is to parse the string into individual numeric values\u000d\u000ausing your DBMS\u2019s provided functions.\u000d\u000aDB2 and SQL Server\u000d\u000aThe inline view X (lines 6\u201311) walks the string. The idea in this solution is to \u201cwalk\u000d\u000athrough\u201d the string so that each row has one less character than the one before it:\u000d\u000a,7654,7698,7782,7788,\u000d\u000a7654,7698,7782,7788,\u000d\u000a654,7698,7782,7788,\u000d\u000a54,7698,7782,7788,\u000d\u000a4,7698,7782,7788,\u000d\u000a,7698,7782,7788,\u000d\u000a7698,7782,7788,\u000d\u000a698,7782,7788,\u000d\u000a98,7782,7788,\u000d\u000a8,7782,7788,\u000d\u000a,7782,7788,\u000d\u000a7782,7788,\u000d\u000a782,7788,\u000d\u000a82,7788,\u000d\u000a2,7788,\u000d\u000a138 | Chapter 6: Working with Strings",",7788,\u000d\u000a7788,\u000d\u000a788,\u000d\u000a88,\u000d\u000a8,\u000d\u000a,\u000d\u000aNotice that by enclosing the string in commas (the delimiter), there\u2019s no need to make\u000d\u000aspecial checks as to where the beginning or end of the string is.\u000d\u000aThe next step is to keep only the values you want to use in the IN-list. The values to\u000d\u000akeep are the ones with leading commas, with the exception of the last row with its\u000d\u000alone comma. Use SUBSTR or SUBSTRING to identify which rows have a leading\u000d\u000acomma, then keep all characters found before the next comma in that row. Once\u000d\u000athat\u2019s done, cast the string to a number so it can be properly evaluated against the\u000d\u000anumeric column EMPNO (lines 4\u201314):\u000d\u000a EMPNO\u000d\u000a------\u000d\u000a 7654\u000d\u000a 7698\u000d\u000a 7782\u000d\u000a 7788\u000d\u000aThe final step is to use the results in a subquery to return the desired rows.\u000d\u000aMySQL\u000d\u000aThe inline view (lines 5\u20139) walks the string. The expression on line 10 determines\u000d\u000ahow many values are in the string by finding the number of commas (the delimiter)\u000d\u000aand adding one. The function SUBSTRING_INDEX (line 6) returns all characters in\u000d\u000athe string before (to the left of ) the nth occurrence of a comma (the delimiter):\u000d\u000a+---------------------+\u000d\u000a| empno |\u000d\u000a+---------------------+\u000d\u000a| 7654 |\u000d\u000a| 7654,7698 |\u000d\u000a| 7654,7698,7782 |\u000d\u000a| 7654,7698,7782,7788 |\u000d\u000a+---------------------+\u000d\u000aThose rows are then passed to another call to SUBSTRING_INDEX (line 5); this time\u000d\u000athe nth occurrence of the delimited is \u20131, which causes all values to the right of the\u000d\u000anth occurrence of the delimiter to be kept:\u000d\u000a6.11 Converting Delimited Data into a Multivalued IN-List | 139","+-------+\u000d\u000a| empno |\u000d\u000a+-------+\u000d\u000a| 7654 |\u000d\u000a| 7698 |\u000d\u000a| 7782 |\u000d\u000a| 7788 |\u000d\u000a+-------+\u000d\u000aThe final step is to plug the results into a subquery.\u000d\u000aOracle\u000d\u000aThe first step is to walk the string:\u000d\u000aselect emps,pos\u000d\u000a from (select ','||'7654,7698,7782,7788'||',' emps\u000d\u000a from t1) csv,\u000d\u000a (select rownum pos from emp) iter\u000d\u000a where iter.pos <=\u000d\u000a ((length(csv.emps)-length(replace(csv.emps,',')))/length(','))-1\u000d\u000aEMPS POS\u000d\u000a--------------------- ----------\u000d\u000a,7654,7698,7782,7788, 1\u000d\u000a,7654,7698,7782,7788, 2\u000d\u000a,7654,7698,7782,7788, 3\u000d\u000a,7654,7698,7782,7788, 4\u000d\u000aThe number of rows returned represents the number of values in your list. The values\u000d\u000afor POS are crucial to the query as they are needed to parse the string into individual\u000d\u000avalues. The strings are parsed using SUBSTR and INSTR. POS is used to locate the\u000d\u000anth occurrence of the delimiter in each string. By enclosing the strings in commas, no\u000d\u000aspecial checks are necessary to determine the beginning or end of a string. The values\u000d\u000apassed to SUBSTR and INSTR (lines 7\u20139) locate the nth and nth+1 occurrence of the\u000d\u000adelimiter. By subtracting the value returned for the current comma (the location in\u000d\u000athe string where the current comma is) from the value returned by the next comma\u000d\u000a(the location in the string where the next comma is) you can extract each value from\u000d\u000athe string:\u000d\u000aselect substr(emps,\u000d\u000a instr(emps,',',1,iter.pos)+1,\u000d\u000a instr(emps,',',1,iter.pos+1)\u000d\u000a instr(emps,',',1,iter.pos)) emps\u000d\u000a from (select ','||'7654,7698,7782,7788'||',' emps\u000d\u000a from t1) csv,\u000d\u000a (select rownum pos from emp) iter\u000d\u000a where iter.pos <=\u000d\u000a ((length(csv.emps)-length(replace(csv.emps,',')))/length(','))-1\u000d\u000a140 | Chapter 6: Working with Strings"," EMPS\u000d\u000a -----------\u000d\u000a 7654,\u000d\u000a 7698,\u000d\u000a 7782,\u000d\u000a 7788,\u000d\u000aThe final step is to remove the trailing comma from each value, cast it to a number,\u000d\u000aand plug it into a subquery.\u000d\u000aPostgreSQL\u000d\u000aThe inline view Z (lines 6\u20139) walks the string. The number of rows returned is deter\u2010\u000d\u000amined by how many values are in the string. To find the number of values in the\u000d\u000astring, subtract the size of the string without the delimiter from the size of the string\u000d\u000awith the delimiter (line 9). The function SPLIT_PART does the work of parsing the\u000d\u000astring. It looks for the value that comes before the nth occurrence of the delimiter:\u000d\u000aselect list.vals,\u000d\u000a split_part(list.vals,',',iter.pos) as empno,\u000d\u000a iter.pos\u000d\u000a from (select id as pos from t10) iter,\u000d\u000a (select ','||'7654,7698,7782,7788'||',' as vals\u000d\u000a from t1) list\u000d\u000a where iter.pos <=\u000d\u000a length(list.vals)-length(replace(list.vals,',',''))\u000d\u000a vals | empno | pos\u000d\u000a----------------------+-------+-----\u000d\u000a,7654,7698,7782,7788, | | 1\u000d\u000a,7654,7698,7782,7788, | 7654 | 2\u000d\u000a,7654,7698,7782,7788, | 7698 | 3\u000d\u000a,7654,7698,7782,7788, | 7782 | 4\u000d\u000a,7654,7698,7782,7788, | 7788 | 5\u000d\u000aThe final step is to cast the values (EMPNO) to a number and plug it into a subquery.\u000d\u000a6.12 Alphabetizing a String\u000d\u000aProblem\u000d\u000aYou want alphabetize the individual characters within strings in your tables. Consider\u000d\u000athe following result set:\u000d\u000aENAME\u000d\u000a----------\u000d\u000aADAMS\u000d\u000aALLEN\u000d\u000aBLAKE\u000d\u000aCLARK\u000d\u000a6.12 Alphabetizing a String | 141","FORD\u000d\u000aJAMES\u000d\u000aJONES\u000d\u000aKING\u000d\u000aMARTIN\u000d\u000aMILLER\u000d\u000aSCOTT\u000d\u000aSMITH\u000d\u000aTURNER\u000d\u000aWARD\u000d\u000aYou would like the result to be:\u000d\u000aOLD_NAME NEW_NAME\u000d\u000a---------- --------\u000d\u000aADAMS AADMS\u000d\u000aALLEN AELLN\u000d\u000aBLAKE ABEKL\u000d\u000aCLARK ACKLR\u000d\u000aFORD DFOR\u000d\u000aJAMES AEJMS\u000d\u000aJONES EJNOS\u000d\u000aKING GIKN\u000d\u000aMARTIN AIMNRT\u000d\u000aMILLER EILLMR\u000d\u000aSCOTT COSTT\u000d\u000aSMITH HIMST\u000d\u000aTURNER ENRRTU\u000d\u000aWARD ADRW\u000d\u000aSolution\u000d\u000aThis problem is a good example of the way increased standardization allows for more\u000d\u000asimilar, and therefore portable solutions.\u000d\u000aDB2\u000d\u000aTo alphabetize rows of strings, it is necessary to walk each string and then order its\u000d\u000acharacters:\u000d\u000a 1 select ename,\u000d\u000a 2 listagg(c,'') WITHIN GROUP( ORDER BY c)\u000d\u000a 3 from (\u000d\u000a 4 select a.ename,\u000d\u000a 5 substr(a.ename,iter.pos,1\u000d\u000a 6 ) as c\u000d\u000a 7 from emp a,\u000d\u000a 8 (select id as pos from t10) iter\u000d\u000a 9 where iter.pos <= length(a.ename)\u000d\u000a 10 order by 1,2\u000d\u000a 11 ) x\u000d\u000a 12 Group By c\u000d\u000a142 | Chapter 6: Working with Strings","MySQL\u000d\u000aThe key here is the GROUP_CONCAT function, which allows you to not only con\u2010\u000d\u000acatenate the characters that make up each name but also order them:\u000d\u000a1 select ename, group_concat(c order by c separator '')\u000d\u000a2 from (\u000d\u000a3 select ename, substr(a.ename,iter.pos,1) c\u000d\u000a4 from emp a,\u000d\u000a5 ( select id pos from t10 ) iter\u000d\u000a6 where iter.pos <= length(a.ename)\u000d\u000a7 ) x\u000d\u000a8 group by ename\u000d\u000aOracle\u000d\u000aThe function SYS_CONNECT_BY_PATH allows you to iteratively build a list:\u000d\u000a 1 select old_name, new_name\u000d\u000a 2 from (\u000d\u000a 3 select old_name, replace(sys_connect_by_path(c,' '),' ') new_name\u000d\u000a 4 from (\u000d\u000a 5 select e.ename old_name,\u000d\u000a 6 row_number() over(partition by e.ename\u000d\u000a 7 order by substr(e.ename,iter.pos,1)) rn,\u000d\u000a 8 substr(e.ename,iter.pos,1) c\u000d\u000a 9 from emp e,\u000d\u000a10 ( select rownum pos from emp ) iter\u000d\u000a11 where iter.pos <= length(e.ename)\u000d\u000a12 order by 1\u000d\u000a13 ) x\u000d\u000a14 start with rn = 1\u000d\u000a15 connect by prior rn = rn-1 and prior old_name = old_name\u000d\u000a16 )\u000d\u000a17 where length(old_name) = length(new_name)\u000d\u000aPostgreSQL\u000d\u000aPostgreSQL has now added STRING_AGG to order characters within a string.\u000d\u000a select ename, string_agg(c , ''\u000d\u000a ORDER BY c)\u000d\u000afrom (\u000d\u000a select a.ename,\u000d\u000a substr(a.ename,iter.pos,1) as c\u000d\u000a from emp a,\u000d\u000a (select id as pos from t10) iter\u000d\u000a where iter.pos <= length(a.ename)\u000d\u000a order by 1,2\u000d\u000a ) x\u000d\u000a Group By c\u000d\u000a6.12 Alphabetizing a String | 143","SQL Server\u000d\u000aIf you are using SQL Server 2017 or beyond, the PostgreSQL solution with\u000d\u000aSTRING_AGG will work. Otherwise, to alphabetize rows of strings, it is necessary to\u000d\u000awalk each string and then order their characters:\u000d\u000a 1 select ename,\u000d\u000a 2 max(case when pos=1 then c else '' end)+\u000d\u000a 3 max(case when pos=2 then c else '' end)+\u000d\u000a 4 max(case when pos=3 then c else '' end)+\u000d\u000a 5 max(case when pos=4 then c else '' end)+\u000d\u000a 6 max(case when pos=5 then c else '' end)+\u000d\u000a 7 max(case when pos=6 then c else '' end)\u000d\u000a 8 from (\u000d\u000a 9 select e.ename,\u000d\u000a10 substring(e.ename,iter.pos,1) as c,\u000d\u000a11 row_number() over (\u000d\u000a12 partition by e.ename\u000d\u000a13 order by substring(e.ename,iter.pos,1)) as pos\u000d\u000a14 from emp e,\u000d\u000a15 (select row_number()over(order by ename) as pos\u000d\u000a16 from emp) iter\u000d\u000a17 where iter.pos <= len(e.ename)\u000d\u000a18 ) x\u000d\u000a19 group by ename\u000d\u000aDiscussion\u000d\u000aSQL Server\u000d\u000aThe inline view X returns each character in each name as a row. The function\u000d\u000aSUBSTR or SUBSTRING extracts each character from each name, and the function\u000d\u000aROW_NUMBER ranks each character alphabetically:\u000d\u000aENAME C POS\u000d\u000a----- - ---\u000d\u000aADAMS A 1\u000d\u000aADAMS A 2\u000d\u000aADAMS D 3\u000d\u000aADAMS M 4\u000d\u000aADAMS S 5\u000d\u000a\u2026\u000d\u000aTo return each letter of a string as a row, you must walk the string. This is accom\u2010\u000d\u000aplished with inline view ITER.\u000d\u000aNow that the letters in each name have been alphabetized, the last step is to put those\u000d\u000aletters back together, into a string, in the order they are ranked. Each letter\u2019s position\u000d\u000ais evaluated by the CASE statements (lines 2\u20137). If a character is found at a particular\u000d\u000aposition, it is then concatenated to the result of the next evaluation (the following\u000d\u000aCASE statement). Because the aggregate function MAX is used as well, only one\u000d\u000a144 | Chapter 6: Working with Strings","character per position POS is returned so that only one row per name is returned.\u000d\u000aThe CASE evaluation goes up to the number six, which is the maximum number of\u000d\u000acharacters in any name in table EMP.\u000d\u000aMySQL\u000d\u000aThe inline view X (lines 3\u20136) returns each character in each name as a row. The func\u2010\u000d\u000ation SUBSTR extracts each character from each name:\u000d\u000aENAME C\u000d\u000a----- -\u000d\u000aADAMS A\u000d\u000aADAMS A\u000d\u000aADAMS D\u000d\u000aADAMS M\u000d\u000aADAMS S\u000d\u000a\u2026\u000d\u000aInline view ITER is used to walk the string. From there, the rest of the work is done\u000d\u000aby the GROUP_CONCAT function. By specifying an order, the function not only\u000d\u000aconcatenates each letter, it does so alphabetically.\u000d\u000aOracle\u000d\u000aThe real work is done by inline view X (lines 5\u201311), where the characters in each\u000d\u000aname are extracted and put into alphabetical order. This is accomplished by walking\u000d\u000athe string and then imposing order on those characters. The rest of the query merely\u000d\u000aglues the names back together.\u000d\u000aThe tearing apart of names can be seen by executing only inline view X:\u000d\u000aOLD_NAME RN C\u000d\u000a---------- --------- -\u000d\u000aADAMS 1 A\u000d\u000aADAMS 2 A\u000d\u000aADAMS 3 D\u000d\u000aADAMS 4 M\u000d\u000aADAMS 5 S\u000d\u000a\u2026\u000d\u000aThe next step is to take the alphabetized characters and rebuild each name. This is\u000d\u000adone with the function SYS_CONNECT_BY_PATH by appending each character to\u000d\u000athe ones before it:\u000d\u000a6.12 Alphabetizing a String | 145","OLD_NAME NEW_NAME\u000d\u000a---------- ---------\u000d\u000aADAMS A\u000d\u000aADAMS AA\u000d\u000aADAMS AAD\u000d\u000aADAMS AADM\u000d\u000aADAMS AADMS\u000d\u000a\u2026\u000d\u000aThe final step is to keep only the strings that have the same length as the names they\u000d\u000awere built from.\u000d\u000aPostgreSQL\u000d\u000aFor readability, view V is used in this solution to walk the string. The function\u000d\u000aSUBSTR, in the view definition, extracts each character from each name so that the\u000d\u000aview returns:\u000d\u000aENAME C\u000d\u000a----- -\u000d\u000aADAMS A\u000d\u000aADAMS A\u000d\u000aADAMS D\u000d\u000aADAMS M\u000d\u000aADAMS S\u000d\u000a\u2026\u000d\u000aThe view also orders the results by ENAME and by each letter in each name. The\u000d\u000ainline view X (lines 15\u201318) returns the names and characters from view V, the num\u2010\u000d\u000aber of times each character occurs in each name, and its position (alphabetically):\u000d\u000aename | c | cnt | pos\u000d\u000a------+---+-----+-----\u000d\u000aADAMS | A | 2 | 1\u000d\u000aADAMS | A | 2 | 1\u000d\u000aADAMS | D | 1 | 3\u000d\u000aADAMS | M | 1 | 4\u000d\u000aADAMS | S | 1 | 5\u000d\u000aThe extra columns CNT and POS, returned by the inline view X, are crucial to the\u000d\u000asolution. POS is used to rank each character, and CNT is used to determine the num\u2010\u000d\u000aber of times the character exists in each name. The final step is to evaluate the posi\u2010\u000d\u000ation of each character and rebuild the name. You\u2019ll notice that each case statement is\u000d\u000aactually two case statements. This is to determine whether a character occurs more\u000d\u000athan once in a name; if it does, then rather than return that character, what is\u000d\u000areturned is that character appended to itself CNT times. The aggregate function,\u000d\u000aMAX, is used to ensure there is only one row per name.\u000d\u000a146 | Chapter 6: Working with Strings","6.13 Identifying Strings That Can Be Treated as Numbers\u000d\u000aProblem\u000d\u000aYou have a column that is defined to hold character data. Unfortunately, the rows\u000d\u000acontain mixed numeric and character data. Consider view V:\u000d\u000acreate view V as\u000d\u000aselect replace(mixed,' ','') as mixed\u000d\u000a from (\u000d\u000aselect substr(ename,1,2)||\u000d\u000a cast(deptno as char(4))||\u000d\u000a substr(ename,3,2) as mixed\u000d\u000a from emp\u000d\u000a where deptno = 10\u000d\u000a union all\u000d\u000aselect cast(empno as char(4)) as mixed\u000d\u000a from emp\u000d\u000a where deptno = 20\u000d\u000a union all\u000d\u000aselect ename as mixed\u000d\u000a from emp\u000d\u000a where deptno = 30\u000d\u000a ) x\u000d\u000aselect * from v\u000d\u000a MIXED\u000d\u000a --------------\u000d\u000a CL10AR\u000d\u000a KI10NG\u000d\u000a MI10LL\u000d\u000a 7369\u000d\u000a 7566\u000d\u000a 7788\u000d\u000a 7876\u000d\u000a 7902\u000d\u000a ALLEN\u000d\u000a WARD\u000d\u000a MARTIN\u000d\u000a BLAKE\u000d\u000a TURNER\u000d\u000a JAMES\u000d\u000aYou want to return rows that are numbers only, or that contain at least one number. If\u000d\u000athe numbers are mixed with character data, you want to remove the characters and\u000d\u000areturn only the numbers. For the sample data shown previously, you want the follow\u2010\u000d\u000aing result set:\u000d\u000a6.13 Identifying Strings That Can Be Treated as Numbers | 147"," MIXED\u000d\u000a--------\u000d\u000a 10\u000d\u000a 10\u000d\u000a 10\u000d\u000a 7369\u000d\u000a 7566\u000d\u000a 7788\u000d\u000a 7876\u000d\u000a 7902\u000d\u000aSolution\u000d\u000aThe functions REPLACE and TRANSLATE are extremely useful for manipulating\u000d\u000astrings and individual characters. The key is to convert all numbers to a single char\u2010\u000d\u000aacter, which then makes it easy to isolate and identify any number by referring to a\u000d\u000asingle character.\u000d\u000aDB2\u000d\u000aUse functions TRANSLATE, REPLACE, and POSSTR to isolate the numeric charac\u2010\u000d\u000aters in each row. The calls to CAST are necessary in view V; otherwise, the view will\u000d\u000afail to be created due to type conversion errors. You\u2019ll need the function REPLACE to\u000d\u000aremove extraneous whitespace due to casting to the fixed-length CHAR:\u000d\u000a 1 select mixed old,\u000d\u000a 2 cast(\u000d\u000a 3 case\u000d\u000a 4 when\u000d\u000a 5 replace(\u000d\u000a 6 translate(mixed,'9999999999','0123456789'),'9','') = ''\u000d\u000a 7 then\u000d\u000a 8 mixed\u000d\u000a 9 else replace(\u000d\u000a10 translate(mixed,\u000d\u000a11 repeat('#',length(mixed)),\u000d\u000a12 replace(\u000d\u000a13 translate(mixed,'9999999999','0123456789'),'9','')),\u000d\u000a14 '#','')\u000d\u000a15 end as integer ) mixed\u000d\u000a16 from V\u000d\u000a17 where posstr(translate(mixed,'9999999999','0123456789'),'9') > 0\u000d\u000aMySQL\u000d\u000aThe syntax for MySQL is slightly different and will define view V as:\u000d\u000acreate view V as\u000d\u000aselect concat(\u000d\u000a substr(ename,1,2),\u000d\u000a replace(cast(deptno as char(4)),' ',''),\u000d\u000a148 | Chapter 6: Working with Strings"," substr(ename,3,2)\u000d\u000a ) as mixed\u000d\u000a from emp\u000d\u000a where deptno = 10\u000d\u000a union all\u000d\u000aselect replace(cast(empno as char(4)), ' ', '')\u000d\u000a from emp where deptno = 20\u000d\u000a union all\u000d\u000aselect ename from emp where deptno = 30\u000d\u000aBecause MySQL does not support the TRANSLATE function, you must walk each\u000d\u000arow and evaluate it on a character-by-character basis.\u000d\u000a 1 select cast(group_concat(c order by pos separator '') as unsigned)\u000d\u000a 2 as MIXED1\u000d\u000a 3 from (\u000d\u000a 4 select v.mixed, iter.pos, substr(v.mixed,iter.pos,1) as c\u000d\u000a 5 from V,\u000d\u000a 6 ( select id pos from t10 ) iter\u000d\u000a 7 where iter.pos <= length(v.mixed)\u000d\u000a 8 and ascii(substr(v.mixed,iter.pos,1)) between 48 and 57\u000d\u000a 9 ) y\u000d\u000a10 group by mixed\u000d\u000a11 order by 1\u000d\u000aOracle\u000d\u000aUse functions TRANSLATE, REPLACE, and INSTR to isolate the numeric characters\u000d\u000ain each row. The calls to CAST are not necessary in view V. Use the function\u000d\u000aREPLACE to remove extraneous whitespace due to casting to the fixed-length\u000d\u000aCHAR. If you decide you would like to keep the explicit type conversion calls in the\u000d\u000aview definition, it is suggested you cast to VARCHAR2:\u000d\u000a 1 select to_number (\u000d\u000a 2 case\u000d\u000a 3 when\u000d\u000a 4 replace(translate(mixed,'0123456789','9999999999'),'9')\u000d\u000a 5 is not null\u000d\u000a 6 then\u000d\u000a 7 replace(\u000d\u000a 8 translate(mixed,\u000d\u000a 9 replace(\u000d\u000a10 translate(mixed,'0123456789','9999999999'),'9'),\u000d\u000a11 rpad('#',length(mixed),'#')),'#')\u000d\u000a12 else\u000d\u000a13 mixed\u000d\u000a14 end\u000d\u000a15 ) mixed\u000d\u000a16 from V\u000d\u000a17 where instr(translate(mixed,'0123456789','9999999999'),'9') > 0\u000d\u000a6.13 Identifying Strings That Can Be Treated as Numbers | 149","PostgreSQL\u000d\u000aUse functions TRANSLATE, REPLACE, and STRPOS to isolate the numeric charac\u2010\u000d\u000aters in each row. The calls to CAST are not necessary in view V. Use the function\u000d\u000aREPLACE to remove extraneous whitespace due to casting to the fixed-length\u000d\u000aCHAR. If you decide you would like to keep the explicit type conversion calls in the\u000d\u000aview definition, it is suggested you cast to VARCHAR:\u000d\u000a 1 select cast(\u000d\u000a 2 case\u000d\u000a 3 when\u000d\u000a 4 replace(translate(mixed,'0123456789','9999999999'),'9','')\u000d\u000a 5 is not null\u000d\u000a 6 then\u000d\u000a 7 replace(\u000d\u000a 8 translate(mixed,\u000d\u000a 9 replace(\u000d\u000a10 translate(mixed,'0123456789','9999999999'),'9',''),\u000d\u000a11 rpad('#',length(mixed),'#')),'#','')\u000d\u000a12 else\u000d\u000a13 mixed\u000d\u000a14 end as integer ) as mixed\u000d\u000a15 from V\u000d\u000a16 where strpos(translate(mixed,'0123456789','9999999999'),'9') > 0\u000d\u000aSQL Server\u000d\u000aThe built-in function ISNUMERIC along with a wildcard search allows you to easily\u000d\u000aidentify strings that contain numbers, but getting numeric characters out of a string is\u000d\u000anot particularly efficient because the TRANSLATE function is not supported.\u000d\u000aDiscussion\u000d\u000aThe TRANSLATE function is useful here as it allows you to easily isolate and identify\u000d\u000anumbers and characters. The trick is to convert all numbers to a single character; this\u000d\u000away, rather than searching for different numbers, you search for only one character.\u000d\u000aDB2, Oracle, and PostgreSQL\u000d\u000aThe syntax differs slightly among these DBMSs, but the technique is the same. We\u2019ll\u000d\u000ause the solution for PostgreSQL for the discussion.\u000d\u000aThe real work is done by functions TRANSLATE and REPLACE. Getting the final\u000d\u000aresult set requires several function calls, each listed here in one query:\u000d\u000aselect mixed as orig,\u000d\u000atranslate(mixed,'0123456789','9999999999') as mixed1,\u000d\u000areplace(translate(mixed,'0123456789','9999999999'),'9','') as mixed2,\u000d\u000a translate(mixed,\u000d\u000a replace(\u000d\u000a150 | Chapter 6: Working with Strings"," translate(mixed,'0123456789','9999999999'),'9',''),\u000d\u000a rpad('#',length(mixed),'#')) as mixed3, \u000d\u000a replace(\u000d\u000a translate(mixed,\u000d\u000a replace( \u000d\u000atranslate(mixed,'0123456789','9999999999'),'9',''),\u000d\u000a rpad('#',length(mixed),'#')),'#','') as mixed4\u000d\u000a from V \u000d\u000a where strpos(translate(mixed,'0123456789','9999999999'),'9') > 0\u000d\u000a ORIG | MIXED1 | MIXED2 | MIXED3 | MIXED4 | MIXED5\u000d\u000a--------+--------+--------+--------+--------+--------\u000d\u000a CL10AR | CL99AR | CLAR | ##10## | 10 | 10\u000d\u000a KI10NG | KI99NG | KING | ##10## | 10 | 10\u000d\u000a MI10LL | MI99LL | MILL | ##10## | 10 | 10\u000d\u000a 7369 | 9999 | | 7369 | 7369 | 7369\u000d\u000a 7566 | 9999 | | 7566 | 7566 | 7566\u000d\u000a 7788 | 9999 | | 7788 | 7788 | 7788\u000d\u000a 7876 | 9999 | | 7876 | 7876 | 7876\u000d\u000a 7902 | 9999 | | 7902 | 7902 | 7902\u000d\u000aFirst, notice that any rows without at least one number are removed. How this is\u000d\u000aaccomplished will become clear as you examine each of the columns in the previous\u000d\u000aresult set. The rows that are kept are the values in the ORIG column and are the rows\u000d\u000athat will eventually make up the result set. The first step to extracting the numbers is\u000d\u000ato use the function TRANSLATE to convert any number to a 9 (you can use any digit;\u000d\u000a9 is arbitrary); this is represented by the values in MIXED1. Now that all numbers are\u000d\u000a9s, they can be treated as a single unit. The next step is to remove all of the numbers\u000d\u000aby using the function REPLACE. Because all digits are now 9, REPLACE simply looks\u000d\u000afor any 9s and removes them. This is represented by the values in MIXED2. The next\u000d\u000astep, MIXED3, uses values that are returned by MIXED2. These values are then com\u2010\u000d\u000apared to the values in ORIG. If any characters from MIXED2 are found in ORIG,\u000d\u000athey are converted to the # character by TRANSLATE. The result set from MIXED3\u000d\u000ashows that the letters, not the numbers, have now been singled out and converted to a\u000d\u000asingle character. Now that all nonnumeric characters are represented by #s, they can\u000d\u000abe treated as a single unit. The next step, MIXED4, uses REPLACE to find and\u000d\u000aremove any # characters in each row; what\u2019s left are numbers only. The final step is to\u000d\u000acast the numeric characters as numbers. Now that you\u2019ve gone through the steps, you\u000d\u000acan see how the WHERE clause works. The results from MIXED1 are passed to\u000d\u000aSTRPOS, and if a 9 is found (the position in the string where the first 9 is located),\u000d\u000athe result must be greater than 0. For rows that return a value greater than zero, it\u000d\u000ameans there\u2019s at least one number in that row and it should be kept.\u000d\u000aMySQL\u000d\u000aThe first step is to walk each string, evaluate each character, and determine whether\u000d\u000ait\u2019s a number:\u000d\u000a6.13 Identifying Strings That Can Be Treated as Numbers | 151","select v.mixed, iter.pos, substr(v.mixed,iter.pos,1) as c\u000d\u000a from V,\u000d\u000a ( select id pos from t10 ) iter\u000d\u000a where iter.pos <= length(v.mixed) \u000d\u000a order by 1,2\u000d\u000a+--------+------+------+\u000d\u000a| mixed | pos | c |\u000d\u000a+--------+------+------+\u000d\u000a| 7369 | 1 | 7 |\u000d\u000a| 7369 | 2 | 3 |\u000d\u000a| 7369 | 3 | 6 |\u000d\u000a| 7369 | 4 | 9 |\u000d\u000a\u2026\u000d\u000a| ALLEN | 1 | A |\u000d\u000a| ALLEN | 2 | L |\u000d\u000a| ALLEN | 3 | L |\u000d\u000a| ALLEN | 4 | E |\u000d\u000a| ALLEN | 5 | N |\u000d\u000a\u2026\u000d\u000a| CL10AR | 1 | C |\u000d\u000a| CL10AR | 2 | L |\u000d\u000a| CL10AR | 3 | 1 |\u000d\u000a| CL10AR | 4 | 0 |\u000d\u000a| CL10AR | 5 | A |\u000d\u000a| CL10AR | 6 | R |\u000d\u000a+--------+------+------+\u000d\u000aNow that each character in each string can be evaluated individually, the next step is\u000d\u000ato keep only the rows that have a number in the C column:\u000d\u000aselect v.mixed, iter.pos, substr(v.mixed,iter.pos,1) as c\u000d\u000a from V,\u000d\u000a ( select id pos from t10 ) iter\u000d\u000a where iter.pos <= length(v.mixed)\u000d\u000a and ascii(substr(v.mixed,iter.pos,1)) between 48 and 57\u000d\u000a order by 1,2\u000d\u000a+--------+------+------+\u000d\u000a| mixed | pos | c |\u000d\u000a+--------+------+------+\u000d\u000a| 7369 | 1 | 7 |\u000d\u000a| 7369 | 2 | 3 |\u000d\u000a| 7369 | 3 | 6 |\u000d\u000a| 7369 | 4 | 9 |\u000d\u000a\u2026\u000d\u000a| CL10AR | 3 | 1 |\u000d\u000a| CL10AR | 4 | 0 |\u000d\u000a\u2026\u000d\u000a+--------+------+------+\u000d\u000a152 | Chapter 6: Working with Strings","At this point, all the rows in column C are numbers. The next step is to use\u000d\u000aGROUP_CONCAT to concatenate the numbers to form their respective whole num\u2010\u000d\u000aber in MIXED. The final result is then cast as a number:\u000d\u000aselect cast(group_concat(c order by pos separator '') as unsigned)\u000d\u000a as MIXED1\u000d\u000a from ( \u000d\u000aselect v.mixed, iter.pos, substr(v.mixed,iter.pos,1) as c \u000d\u000a from V, \u000d\u000a ( select id pos from t10 ) iter \u000d\u000a where iter.pos <= length(v.mixed) \u000d\u000a and ascii(substr(x.mixed,iter.pos,1)) between 48 and 57\u000d\u000a ) y\u000d\u000a group by mixed\u000d\u000a order by 1\u000d\u000a+--------+\u000d\u000a| MIXED1 |\u000d\u000a+--------+\u000d\u000a| 10 |\u000d\u000a| 10 |\u000d\u000a| 10 |\u000d\u000a| 7369 |\u000d\u000a| 7566 |\u000d\u000a| 7788 |\u000d\u000a| 7876 |\u000d\u000a| 7902 |\u000d\u000a+--------+\u000d\u000aAs a final note, keep in mind that any digits in each string will be concatenated to\u000d\u000aform one numeric value. For example, an input value of, say, 99Gennick87 will result\u000d\u000ain the value 9987 being returned. This is something to keep in mind, particularly\u000d\u000awhen working with serialized data.\u000d\u000a6.14 Extracting the nth Delimited Substring\u000d\u000aProblem\u000d\u000aYou want to extract a specified, delimited substring from a string. Consider the fol\u2010\u000d\u000alowing view V, which generates source data for this problem:\u000d\u000acreate view V as\u000d\u000aselect 'mo,larry,curly' as name\u000d\u000a from t1\u000d\u000a union all\u000d\u000aselect 'tina,gina,jaunita,regina,leena' as name\u000d\u000a from t1\u000d\u000a6.14 Extracting the nth Delimited Substring | 153","Output from the view is as follows:\u000d\u000aselect * from v\u000d\u000aNAME\u000d\u000a-------------------\u000d\u000amo,larry,curly\u000d\u000atina,gina,jaunita,regina,leena\u000d\u000aYou would like to extract the second name in each row, so the final result set would\u000d\u000abe as follows:\u000d\u000a SUB\u000d\u000a-----\u000d\u000alarry\u000d\u000agina\u000d\u000aSolution\u000d\u000aThe key to solving this problem is to return each name as an individual row while\u000d\u000apreserving the order in which the name exists in the list. Exactly how you do these\u000d\u000athings depends on which DBMS you are using.\u000d\u000aDB2\u000d\u000aAfter walking the NAMEs returned by view V, use the function ROW_NUMBER to\u000d\u000akeep only the second name from each string:\u000d\u000a 1 select substr(c,2,locate(',',c,2)-2)\u000d\u000a 2 from (\u000d\u000a 3 select pos, name, substr(name, pos) c,\u000d\u000a 4 row_number() over( partition by name\u000d\u000a 5 order by length(substr(name,pos)) desc) rn\u000d\u000a 6 from (\u000d\u000a 7 select ',' ||csv.name|| ',' as name,\u000d\u000a 8 cast(iter.pos as integer) as pos\u000d\u000a 9 from V csv,\u000d\u000a10 (select row_number() over() pos from t100 ) iter\u000d\u000a11 where iter.pos <= length(csv.name)+2\u000d\u000a12 ) x\u000d\u000a13 where length(substr(name,pos)) > 1\u000d\u000a14 and substr(substr(name,pos),1,1) = ','\u000d\u000a15 ) y\u000d\u000a16 where rn = 2\u000d\u000aMySQL\u000d\u000aAfter walking the NAMEs returned by view V, use the position of the commas to\u000d\u000areturn only the second name in each string:\u000d\u000a154 | Chapter 6: Working with Strings"," 1 select name\u000d\u000a 2 from (\u000d\u000a 3 select iter.pos,\u000d\u000a 4 substring_index(\u000d\u000a 5 substring_index(src.name,',',iter.pos),',',-1) name\u000d\u000a 6 from V src,\u000d\u000a 7 (select id pos from t10) iter,\u000d\u000a 8 where iter.pos <=\u000d\u000a 9 length(src.name)-length(replace(src.name,',',''))\u000d\u000a10 ) x\u000d\u000a11 where pos = 2\u000d\u000aOracle\u000d\u000aAfter walking the NAMEs returned by view V, retrieve the second name in each list\u000d\u000aby using SUBSTR and INSTR:\u000d\u000a 1 select sub\u000d\u000a 2 from (\u000d\u000a 3 select iter.pos,\u000d\u000a 4 src.name,\u000d\u000a 5 substr( src.name,\u000d\u000a 6 instr( src.name,',',1,iter.pos )+1,\u000d\u000a 7 instr( src.name,',',1,iter.pos+1 ) -\u000d\u000a 8 instr( src.name,',',1,iter.pos )-1) sub\u000d\u000a 9 from (select ','||name||',' as name from V) src,\u000d\u000a 10 (select rownum pos from emp) iter\u000d\u000a 11 where iter.pos < length(src.name)-length(replace(src.name,','))\u000d\u000a 12 )\u000d\u000a 13 where pos = 2\u000d\u000aPostgreSQL\u000d\u000aUse the function SPLIT_PART to help return each individual name as a row:\u000d\u000a 1 select name\u000d\u000a 2 from (\u000d\u000a 3 select iter.pos, split_part(src.name,',',iter.pos) as name\u000d\u000a 4 from (select id as pos from t10) iter,\u000d\u000a 5 (select cast(name as text) as name from v) src\u000d\u000a 7 where iter.pos <=\u000d\u000a 8 length(src.name)-length(replace(src.name,',',''))+1\u000d\u000a 9 ) x\u000d\u000a10 where pos = 2\u000d\u000aSQL Server\u000d\u000aThe SQL Server STRING_SPLIT function will do the whole job, but can only take a\u000d\u000asingle cell. Hence, we use a STRING_AGG within a CTE to present the data the way\u000d\u000aSTRING_SPLIT requires.\u000d\u000a6.14 Extracting the nth Delimited Substring | 155","1 with agg_tab(name)\u000d\u000a2 as\u000d\u000a3 (select STRING_AGG(name,',') from V)\u000d\u000a4 select value from\u000d\u000a5 STRING_SPLIT(\u000d\u000a6 (select name from agg_tab),',')\u000d\u000aDiscussion\u000d\u000aDB2\u000d\u000aThe syntax is slightly different between these two DBMSs, but the technique is the\u000d\u000asame. We will use the solution for DB2 for the discussion. The strings are walked and\u000d\u000athe results are represented by inline view X:\u000d\u000aselect ','||csv.name|| ',' as name,\u000d\u000a iter.pos\u000d\u000a from v csv,\u000d\u000a (select row_number() over() pos from t100 ) iter\u000d\u000a where iter.pos <= length(csv.name)+2\u000d\u000aEMPS POS\u000d\u000a------------------------------- ----\u000d\u000a,tina,gina,jaunita,regina,leena, 1\u000d\u000a,tina,gina,jaunita,regina,leena, 2\u000d\u000a,tina,gina,jaunita,regina,leena, 3\u000d\u000a\u2026\u000d\u000aThe next step is to then step through each character in each string:\u000d\u000aselect pos, name, substr(name, pos) c,\u000d\u000a row_number() over(partition by name\u000d\u000a order by length(substr(name, pos)) desc) rn\u000d\u000a from (\u000d\u000aselect ','||csv.name||',' as name,\u000d\u000a cast(iter.pos as integer) as pos\u000d\u000a from v csv,\u000d\u000a (select row_number() over() pos from t100 ) iter\u000d\u000a where iter.pos <= length(csv.name)+2\u000d\u000a ) x\u000d\u000a where length(substr(name,pos)) > 1\u000d\u000aPOS EMPS C RN\u000d\u000a--- --------------- ---------------- --\u000d\u000a 1 ,mo,larry,curly, ,mo,larry,curly, 1\u000d\u000a 2 ,mo,larry,curly, mo,larry,curly, 2\u000d\u000a 3 ,mo,larry,curly, o,larry,curly, 3\u000d\u000a 4 ,mo,larry,curly, ,larry,curly, 4\u000d\u000a \u2026\u000d\u000a156 | Chapter 6: Working with Strings","Now that different portions of the string are available to you, simply identify which\u000d\u000arows to keep. The rows you are interested in are the ones that begin with a comma;\u000d\u000athe rest can be discarded:\u000d\u000aselect pos, name, substr(name,pos) c,\u000d\u000a row_number() over(partition by name\u000d\u000a order by length(substr(name, pos)) desc) rn\u000d\u000a from (\u000d\u000aselect ','||csv.name||',' as name,\u000d\u000a cast(iter.pos as integer) as pos\u000d\u000a from v csv,\u000d\u000a (select row_number() over() pos from t100 ) iter \u000d\u000a where iter.pos <= length(csv.name)+2\u000d\u000a ) x \u000d\u000a where length(substr(name,pos)) > 1 \u000d\u000a and substr(substr(name,pos),1,1) = ','\u000d\u000aPOS EMPS C RN\u000d\u000a --- -------------- ---------------- --\u000d\u000a 1 ,mo,larry,curly, ,mo,larry,curly, 1\u000d\u000a 4 ,mo,larry,curly, ,larry,curly, 2\u000d\u000a 10 ,mo,larry,curly, ,curly, 3\u000d\u000a 1 ,tina,gina,jaunita,regina,leena, ,tina,gina,jaunita,regina,leena, 1\u000d\u000a 6 ,tina,gina,jaunita,regina,leena, ,gina,jaunita,regina,leena, 2\u000d\u000a 11 ,tina,gina,jaunita,regina,leena, ,jaunita,regina,leena, 3\u000d\u000a 19 ,tina,gina,jaunita,regina,leena, ,regina,leena, 4\u000d\u000a 26 ,tina,gina,jaunita,regina,leena, ,leena, 5\u000d\u000aThis is an important step as it sets up how you will get the nth substring. Notice that\u000d\u000amany rows have been eliminated from this query because of the following condition\u000d\u000ain the WHERE clause:\u000d\u000asubstr(substr(name,pos),1,1) = ','\u000d\u000aYou\u2019ll notice that ,mo,larry,curly, was ranked 4, but now is ranked 2. Remember,\u000d\u000athe WHERE clause is evaluated before the SELECT, so the rows with leading commas\u000d\u000aare kept, then ROW_NUMBER performs its ranking. At this point it\u2019s easy to see that,\u000d\u000ato get the nth substring, you want rows where RN equals n. The last step is to keep\u000d\u000aonly the rows you are interested in (in this case where RN equals two) and use\u000d\u000aSUBSTR to extract the name from that row. The name to keep is the first name in the\u000d\u000arow: larry from ,larry,curly, and gina from ,gina,jaunita,regina,leena,.\u000d\u000aMySQL\u000d\u000aThe inline view X walks each string. You can determine how many values are in each\u000d\u000astring by counting the delimiters in the string:\u000d\u000aselect iter.pos, src.name\u000d\u000a from (select id pos from t10) iter,\u000d\u000a V src\u000d\u000a6.14 Extracting the nth Delimited Substring | 157"," where iter.pos <=\u000d\u000a length(src.name)-length(replace(src.name,',',''))\u000d\u000a+------+--------------------------------+\u000d\u000a| pos | name |\u000d\u000a+------+--------------------------------+\u000d\u000a| 1 | mo,larry,curly |\u000d\u000a| 2 | mo,larry,curly |\u000d\u000a| 1 | tina,gina,jaunita,regina,leena |\u000d\u000a| 2 | tina,gina,jaunita,regina,leena |\u000d\u000a| 3 | tina,gina,jaunita,regina,leena |\u000d\u000a| 4 | tina,gina,jaunita,regina,leena |\u000d\u000a+------+--------------------------------+\u000d\u000aIn this case, there is one fewer row than values in each string because that\u2019s all that is\u000d\u000aneeded. The function SUBSTRING_INDEX takes care of parsing the needed values:\u000d\u000a select iter.pos,src.name name1,\u000d\u000a substring_index(src.name,',',iter.pos) name2,\u000d\u000a substring_index(\u000d\u000a substring_index(src.name,',',iter.pos),',',-1) name3\u000d\u000a from (select id pos from t10) iter,\u000d\u000a V src\u000d\u000a where iter.pos <=\u000d\u000a length(src.name)-length(replace(src.name,',',''))\u000d\u000a+------+--------------------------------+--------------------------+---------+\u000d\u000a| pos | name1 | name2 | name3 |\u000d\u000a+------+--------------------------------+--------------------------+---------+\u000d\u000a| 1 | mo,larry,curly | mo | mo |\u000d\u000a| 2 | mo,larry,curly | mo,larry | larry |\u000d\u000a| 1 | tina,gina,jaunita,regina,leena | tina | tina |\u000d\u000a| 2 | tina,gina,jaunita,regina,leena | tina,gina | gina |\u000d\u000a| 3 | tina,gina,jaunita,regina,leena | tina,gina,jaunita | jaunita |\u000d\u000a| 4 | tina,gina,jaunita,regina,leena | tina,gina,jaunita,regina | regina |\u000d\u000a+------+--------------------------------+--------------------------+---------+\u000d\u000aWe\u2019ve shown three name fields, so you can see how the nested SUBSTRING_INDEX\u000d\u000acalls work. The inner call returns all characters to the left of the nth occurrence of a\u000d\u000acomma. The outer call returns everything to the right of the first comma it finds\u000d\u000a(starting from the end of the string). The final step is to keep the value for NAME3\u000d\u000awhere POS equals n, in this case 2.\u000d\u000aSQL Server\u000d\u000aSTRING_SPLIT is the workhorse here, but needs its data the right way. The CTE is\u000d\u000amerely to turn the two rows of the V.names column into a single value, as required by\u000d\u000aSTRING_SPLIT being a table-valued function.\u000d\u000a158 | Chapter 6: Working with Strings","Oracle\u000d\u000aThe inline view walks each string. The number of times each string is returned is\u000d\u000adetermined by how many values are in each string. The solution finds the number of\u000d\u000avalues in each string by counting the number of delimiters in it. Because each string is\u000d\u000aenclosed in commas, the number of values in a string is the number of commas\u000d\u000aminus one. The strings are then UNIONed and joined to a table with a cardinality\u000d\u000athat is at least the number of values in the largest string. The functions SUBSTR and\u000d\u000aINSTR use the value of POS to parse each string:\u000d\u000aselect iter.pos, src.name,\u000d\u000a substr( src.name,\u000d\u000a instr( src.name,',',1,iter.pos )+1,\u000d\u000a instr( src.name,',',1,iter.pos+1 )\u000d\u000a instr( src.name,',',1,iter.pos )-1) sub\u000d\u000a from (select ','||name||',' as name from v) src,\u000d\u000a (select rownum pos from emp) iter\u000d\u000a where iter.pos < length(src.name)-length(replace(src.name,','))\u000d\u000aPOS NAME SUB\u000d\u000a--- --------------------------------- -------------\u000d\u000a 1 ,mo,larry,curly, mo\u000d\u000a 1 , tina,gina,jaunita,regina,leena, tina\u000d\u000a 2 ,mo,larry,curly, larry\u000d\u000a 2 , tina,gina,jaunita,regina,leena, gina\u000d\u000a 3 ,mo,larry,curly, curly\u000d\u000a 3 , tina,gina,jaunita,regina,leena, jaunita\u000d\u000a 4 , tina,gina,jaunita,regina,leena, regina\u000d\u000a 5 , tina,gina,jaunita,regina,leena, leena\u000d\u000aThe first call to INSTR within SUBSTR determines the start position of the substring\u000d\u000ato extract. The next call to INSTR within SUBSTR finds the position of the nth\u000d\u000acomma (same as the start position) as well the position of the nth + 1 comma. Sub\u2010\u000d\u000atracting the two values returns the length of the substring to extract. Because every\u000d\u000avalue is parsed into its own row, simply specify WHERE POS = n to keep the nth sub\u2010\u000d\u000astring (in this case, where POS = 2, so the second substring in the list).\u000d\u000aPostgreSQL\u000d\u000aThe inline view X walks each string. The number of rows returned is determined by\u000d\u000ahow many values are in each string. To find the number of values in each string, find\u000d\u000athe number of delimiters in each string and add one. The function SPLIT_PART uses\u000d\u000athe values in POS to find the nth occurrence of the delimiter and parse the string into\u000d\u000avalues:\u000d\u000aselect iter.pos, src.name as name1,\u000d\u000a split_part(src.name,',',iter.pos) as name2\u000d\u000a from (select id as pos from t10) iter,\u000d\u000a (select cast(name as text) as name from v) src\u000d\u000a6.14 Extracting the nth Delimited Substring | 159"," where iter.pos <=\u000d\u000a length(src.name)-length(replace(src.name,',',''))+1\u000d\u000a pos | name1 | name2\u000d\u000a-----+--------------------------------+---------\u000d\u000a 1 | mo,larry,curly | mo\u000d\u000a 2 | mo,larry,curly | larry\u000d\u000a 3 | mo,larry,curly | curly\u000d\u000a 1 | tina,gina,jaunita,regina,leena | tina\u000d\u000a 2 | tina,gina,jaunita,regina,leena | gina\u000d\u000a 3 | tina,gina,jaunita,regina,leena | jaunita\u000d\u000a 4 | tina,gina,jaunita,regina,leena | regina\u000d\u000a 5 | tina,gina,jaunita,regina,leena | leena\u000d\u000aWe\u2019ve shown NAME twice so you can see how SPLIT_PART parses each string using\u000d\u000aPOS. Once each string is parsed, the final step is to keep the rows where POS equals\u000d\u000athe nth substring you are interested in, in this case, 2.\u000d\u000a6.15 Parsing an IP Address\u000d\u000aProblem\u000d\u000aYou want to parse an IP address\u2019s fields into columns. Consider the following IP\u000d\u000aaddress:\u000d\u000a111.22.3.4\u000d\u000aYou would like the result of your query to be:\u000d\u000aA B C D\u000d\u000a----- ----- ----- ---\u000d\u000a111 22 3 4\u000d\u000aSolution\u000d\u000aThe solution depends on the built-in functions provided by your DBMS. Regardless\u000d\u000aof your DBMS, being able to locate periods and the numbers immediately surround\u2010\u000d\u000aing them are the keys to the solution.\u000d\u000aDB2\u000d\u000aUse the recursive WITH clause to simulate an iteration through the IP address while\u000d\u000ausing SUBSTR to easily parse it. A leading period is added to the IP address so that\u000d\u000aevery set of numbers has a period in front of it and can be treated the same way.\u000d\u000a 1 with x (pos,ip) as (\u000d\u000a 2 values (1,'.92.111.0.222')\u000d\u000a 3 union all\u000d\u000a 4 select pos+1,ip from x where pos+1 <= 20\u000d\u000a 5 )\u000d\u000a160 | Chapter 6: Working with Strings"," 6 select max(case when rn=1 then e end) a,\u000d\u000a 7 max(case when rn=2 then e end) b,\u000d\u000a 8 max(case when rn=3 then e end) c,\u000d\u000a 9 max(case when rn=4 then e end) d\u000d\u000a10 from (\u000d\u000a11 select pos,c,d,\u000d\u000a12 case when posstr(d,'.') > 0 then substr(d,1,posstr(d,'.')-1)\u000d\u000a13 else d\u000d\u000a14 end as e,\u000d\u000a15 row_number() over( order by pos desc) rn\u000d\u000a16 from (\u000d\u000a17 select pos, ip,right(ip,pos) as c, substr(right(ip,pos),2) as d\u000d\u000a18 from x\u000d\u000a19 where pos <= length(ip)\u000d\u000a20 and substr(right(ip,pos),1,1) = '.'\u000d\u000a21 ) x\u000d\u000a22 ) y\u000d\u000aMySQL\u000d\u000aThe function SUBSTR_INDEX makes parsing an IP address an easy operation:\u000d\u000a1 select substring_index(substring_index(y.ip,'.',1),'.',-1) a,\u000d\u000a2 substring_index(substring_index(y.ip,'.',2),'.',-1) b,\u000d\u000a3 substring_index(substring_index(y.ip,'.',3),'.',-1) c,\u000d\u000a4 substring_index(substring_index(y.ip,'.',4),'.',-1) d\u000d\u000a5 from (select '92.111.0.2' as ip from t1) y\u000d\u000aOracle\u000d\u000aUse the built-in function SUBSTR and INSTR to parse and navigate through the IP\u000d\u000aaddress:\u000d\u000a1 select ip,\u000d\u000a2 substr(ip, 1, instr(ip,'.')-1 ) a,\u000d\u000a3 substr(ip, instr(ip,'.')+1,\u000d\u000a4 instr(ip,'.',1,2)-instr(ip,'.')-1 ) b,\u000d\u000a5 substr(ip, instr(ip,'.',1,2)+1,\u000d\u000a6 instr(ip,'.',1,3)-instr(ip,'.',1,2)-1 ) c,\u000d\u000a7 substr(ip, instr(ip,'.',1,3)+1 ) d\u000d\u000a8 from (select '92.111.0.2' as ip from t1)\u000d\u000aPostgreSQL\u000d\u000aUse the built-in function SPLIT_PART to parse an IP address:\u000d\u000a1 select split_part(y.ip,'.',1) as a,\u000d\u000a2 split_part(y.ip,'.',2) as b,\u000d\u000a3 split_part(y.ip,'.',3) as c,\u000d\u000a4 split_part(y.ip,'.',4) as d\u000d\u000a5 from (select cast('92.111.0.2' as text) as ip from t1) as y\u000d\u000a6.15 Parsing an IP Address | 161","SQL Server\u000d\u000aUse the recursive WITH clause to simulate an iteration through the IP address while\u000d\u000ausing SUBSTR to easily parse it. A leading period is added to the IP address so that\u000d\u000aevery set of numbers has a period in front of it and can be treated the same way:\u000d\u000a 1 with x (pos,ip) as (\u000d\u000a 2 select 1 as pos,'.92.111.0.222' as ip from t1\u000d\u000a 3 union all\u000d\u000a 4 select pos+1,ip from x where pos+1 <= 20\u000d\u000a 5 )\u000d\u000a 6 select max(case when rn=1 then e end) a,\u000d\u000a 7 max(case when rn=2 then e end) b,\u000d\u000a 8 max(case when rn=3 then e end) c,\u000d\u000a 9 max(case when rn=4 then e end) d\u000d\u000a10 from (\u000d\u000a11 select pos,c,d,\u000d\u000a12 case when charindex('.',d) > 0\u000d\u000a13 then substring(d,1,charindex('.',d)-1)\u000d\u000a14 else d\u000d\u000a15 end as e,\u000d\u000a16 row_number() over(order by pos desc) rn\u000d\u000a17 from (\u000d\u000a18 select pos, ip,right(ip,pos) as c,\u000d\u000a19 substring(right(ip,pos),2,len(ip)) as d\u000d\u000a20 from x\u000d\u000a21 where pos <= len(ip)\u000d\u000a22 and substring(right(ip,pos),1,1) = '.'\u000d\u000a23 ) x\u000d\u000a24 ) y\u000d\u000aDiscussion\u000d\u000aBy using the built-in functions for your database, you can easily walk through parts of\u000d\u000aa string. The key is being able to locate each of the periods in the address. Then you\u000d\u000acan parse the numbers between each.\u000d\u000aIn Recipe 6.17 we will see how regular expressions can be used with most RDBMSs\u2014\u000d\u000aparsing an IP address is also a good area to apply this idea.\u000d\u000a6.16 Comparing Strings by Sound\u000d\u000aProblem\u000d\u000aBetween spelling mistakes and legitimate ways to spell words differently, such as Brit\u2010\u000d\u000aish versus American spelling, there are many times that two words that you want to\u000d\u000amatch are represented by different strings of characters. Fortunately, SQL provides a\u000d\u000away to represent the way words sound, which allows you to find strings that sound\u000d\u000athe same even though the underlying characters aren\u2019t identical.\u000d\u000a162 | Chapter 6: Working with Strings","For example, you have a list of authors\u2019 names, including some from an earlier era\u000d\u000awhen spelling wasn\u2019t as fixed as it is now, combined with some extra misspellings and\u000d\u000atypos. The following column of names is an example:\u000d\u000a a_name\u000d\u000a----\u000d\u000a1 Johnson\u000d\u000a2 Jonson\u000d\u000a3 Jonsen\u000d\u000a4 Jensen\u000d\u000a5 Johnsen\u000d\u000a6 Shakespeare\u000d\u000a7 Shakspear\u000d\u000a8 Shaekspir\u000d\u000a9 Shakespar\u000d\u000aAlthough this is likely part of a longer list, you\u2019d like to identify which of these names\u000d\u000aare plausible phonetic matches for other names on the list. While this is an exercise\u000d\u000awhere there is more than one possible solution, your solution will look something\u000d\u000alike this (the meaning of the last column will become clearer by the end of the recipe):\u000d\u000aa_name1 a_name2 soundex_name\u000d\u000a---- ---- ----\u000d\u000aJensen Johnson J525\u000d\u000aJensen Jonson J525\u000d\u000aJensen Jonsen J525\u000d\u000aJensen Johnsen J525\u000d\u000aJohnsen Johnson J525\u000d\u000aJohnsen Jonson J525\u000d\u000aJohnsen Jonsen J525\u000d\u000aJohnsen Jensen J525\u000d\u000a...\u000d\u000aJonson Jensen J525\u000d\u000aJonson Johnsen J525\u000d\u000aShaekspir Shakspear S216\u000d\u000aShakespar Shakespeare S221\u000d\u000aShakespeare Shakespar S221\u000d\u000aShakspear Shaekspir S216\u000d\u000aSolution\u000d\u000aUse the SOUNDEX function to convert strings of characters into the way they sound\u000d\u000awhen spoken in English. A simple self-join allows you to compare values from the\u000d\u000asame column.\u000d\u000a1 select an1.a_name as name1, an2.a_name as name2,\u000d\u000a2 SOUNDEX(an1.a_name) as Soundex_Name\u000d\u000a3 from author_names an1\u000d\u000a4 join author_names an2\u000d\u000a5 on (SOUNDEX(an1.a_name)=SOUNDEX(an2.a_name)\u000d\u000a6 and an1.a_name not like an2.a_name)\u000d\u000a6.16 Comparing Strings by Sound | 163","Discussion\u000d\u000aThe thinking behind SOUNDEX predates both databases and computing, as it origi\u2010\u000d\u000anated with the US Census as an attempt to resolve different spellings of proper names\u000d\u000afor both people and places. There are many algorithms that attempt the same task as\u000d\u000aSOUNDEX, and, of course, there are alternative versions for languages other than\u000d\u000aEnglish. However, we cover SOUNDEX, as it comes with most RDBMSs.\u000d\u000aSoundex keeps the first letter of the name and then replaces the remaining values\u000d\u000awith numbers that have the same value if they are phonetically similar. For example,\u000d\u000am and n are both replaced with the number 5.\u000d\u000aIn the previous example, the actual Soundex output is shown in the Soundex_Name\u000d\u000acolumn. This is just to show what is happening, and not necessary for the solution;\u000d\u000asome RDMSs even have a function that hides the Soundex result, such as SQL Serv\u2010\u000d\u000aer\u2019s Difference function, which compares two strings using Soundex and returns a\u000d\u000asimilarity scale from 0 to 4 (e.g., 4 is a perfect match between the Soundex outputs,\u000d\u000arepresenting 4/4 characters in the Soundex version if the two strings match).\u000d\u000aSometimes Soundex will be sufficient for your needs; other times it won\u2019t be. How\u2010\u000d\u000aever, a small amount of research, possibly using texts such as Data Matching (Chris\u2010\u000d\u000aten, 2012), will help you find other algorithms that are frequently (but not always)\u000d\u000asimple to implement as a user-defined function, or in another programming language\u000d\u000ato suit your taste and needs.\u000d\u000a6.17 Finding Text Not Matching a Pattern\u000d\u000aProblem\u000d\u000aYou have a text field that contains some structured text values (e.g., phone numbers),\u000d\u000aand you want to find occurrences where those values are structured incorrectly. For\u000d\u000aexample, you have data like the following:\u000d\u000aselect emp_id, text\u000d\u000a from employee_comment\u000d\u000aEMP_ID TEXT\u000d\u000a---------- ------------------------------------------------------------\u000d\u000a7369 126 Varnum, Edmore MI 48829, 989 313-5351\u000d\u000a7499 1105 McConnell Court\u000d\u000a Cedar Lake MI 48812\u000d\u000a Home: 989-387-4321\u000d\u000a Cell: (237) 438-3333\u000d\u000aand you want to list rows having invalidly formatted phone numbers. For example,\u000d\u000ayou want to list the following row because its phone number uses two different sepa\u2010\u000d\u000arator characters:\u000d\u000a164 | Chapter 6: Working with Strings","7369 126 Varnum, Edmore MI 48829, 989 313-5351\u000d\u000aYou want to consider valid only those phone numbers that use the same character for\u000d\u000aboth delimiters.\u000d\u000aSolution\u000d\u000aThis problem has a multipart solution:\u000d\u000a1. Find a way to describe the universe of apparent phone numbers that you want to\u000d\u000aconsider.\u000d\u000a2. Remove any validly formatted phone numbers from consideration.\u000d\u000a3. See whether you still have any apparent phone numbers left. If you do, you know\u000d\u000athose are invalidly formatted.\u000d\u000aselect emp_id, text\u000d\u000afrom employee_comment\u000d\u000awhere regexp_like(text, '[0-9]{3}[-. ][0-9]{3}[-. ][0-9]{4}')\u000d\u000a and regexp_like(\u000d\u000a regexp_replace(text,\u000d\u000a '[0-9]{3}([-. ])[0-9]{3}\\1[0-9]{4}','***'),\u000d\u000a '[0-9]{3}[-. ][0-9]{3}[-. ][0-9]{4}')\u000d\u000a EMP_ID TEXT\u000d\u000a---------- ------------------------------------------------------------\u000d\u000a 7369 126 Varnum, Edmore MI 48829, 989 313-5351\u000d\u000a 7844 989-387.5359\u000d\u000a 9999 906-387-1698, 313-535.8886\u000d\u000aEach of these rows contains at least one apparent phone number that is not correctly\u000d\u000aformatted.\u000d\u000aDiscussion\u000d\u000aThe key to this solution lies in the detection of an \u201capparent phone number.\u201d Given\u000d\u000athat the phone numbers are stored in a comment field, any text at all in the field\u000d\u000acould be construed to be an invalid phone number. You need a way to narrow the\u000d\u000afield to a more reasonable set of values to consider. You don\u2019t, for example, want to\u000d\u000asee the following row in your output:\u000d\u000a EMP_ID TEXT\u000d\u000a---------- ----------------------------------------------------------\u000d\u000a 7900 Cares for 100-year-old aunt during the day. Schedule only\u000d\u000a for evening and night shifts.\u000d\u000aClearly there\u2019s no phone number at all in this row, much less one that is invalid. We\u000d\u000acan all see that. The question is, how do you get the RDBMS to \u201csee\u201d it? We think\u000d\u000ayou\u2019ll enjoy the answer. Please read on.\u000d\u000a6.17 Finding Text Not Matching a Pattern | 165","This recipe comes (with permission) from an article by Jonathan\u000d\u000aGennick called \u201cRegular Expression Anti-Patterns.\u201d\u000d\u000aThe solution uses Pattern A to define the set of \u201capparent\u201d phone numbers to\u000d\u000aconsider:\u000d\u000aPattern A: [0-9]{3}[-. ][0-9]{3}[-. ][0-9]{4}\u000d\u000aPattern A checks for two groups of three digits followed by one group of four digits.\u000d\u000aAny one of a dash (-), a period (.), or a space is accepted as a delimiter between\u000d\u000agroups. You could come up with a more complex pattern. For example, you could\u000d\u000adecide that you also want to consider seven-digit phone numbers. But don\u2019t get sidetracked. The point now is that somehow you do need to define the universe of possi\u2010\u000d\u000able phone number strings to consider, and for this problem that universe is defined\u000d\u000aby Pattern A. You can define a different Pattern A, and the general solution still\u000d\u000aapplies.\u000d\u000aThe solution uses Pattern A in the WHERE clause to ensure that only rows having\u000d\u000apotential phone numbers (as defined by the pattern!) are considered:\u000d\u000aselect emp_id, text\u000d\u000a from employee_comment\u000d\u000a where regexp_like(text, '[0-9]{3}[-. ][0-9]{3}[-. ][0-9]{4}')\u000d\u000aNext, you need to define what a \u201cgood\u201d phone number looks like. The solution does\u000d\u000athis using Pattern B:\u000d\u000aPattern B: [0-9]{3}([-. ])[0-9]{3}\\1[0-9]{4}\u000d\u000aThis time, the pattern uses \\1 to reference the first subexpression. Whichever charac\u2010\u000d\u000ater is matched by ([-. ]) must also be matched by \\1. Pattern B describes good phone\u000d\u000anumbers, which must be eliminated from consideration (as they are not bad). The\u000d\u000asolution eliminates the well-formatted phone numbers through a call to REGEXP_\u000d\u000aREPLACE:\u000d\u000aregexp_replace(text,\u000d\u000a '[0-9]{3}([-. ])[0-9]{3}\\1[0-9]{4}','***'),\u000d\u000aThis call to REGEXP_REPLACE occurs in the WHERE clause. Any well-formatted\u000d\u000aphone numbers are replaced by a string of three asterisks. Again, Pattern B can be any\u000d\u000apattern that you desire. The point is that Pattern B describes the acceptable pattern\u000d\u000athat you are after.\u000d\u000aHaving replaced well-formatted phone numbers with strings of three asterisks (*),\u000d\u000aany \u201capparent\u201d phone numbers that remain must, by definition, be poorly formatted.\u000d\u000aThe solution applies REGEXP_LIKE to the output from REGEXP_LIKE to see\u000d\u000awhether any poorly formatted phone numbers remain:\u000d\u000a166 | Chapter 6: Working with Strings","and regexp_like(\u000d\u000a regexp_replace(text,\u000d\u000a '[0-9]{3}([-. ])[0-9]{3}\\1[0-9]{4}','***'),\u000d\u000a '[0-9]{3}[-. ][0-9]{3}[-. ][0-9]{4}')\u000d\u000aRegular expressions are a big topic in their own right, requiring\u000d\u000apractice to master. Once you do master them, you will find they\u000d\u000amatch a great variety of string patterns with ease. We recommend\u000d\u000astudying a book such as Mastering Regular Expressions by Jeffrey\u000d\u000aFriedl to get your regular expression skills to the required level.\u000d\u000a6.18 Summing Up\u000d\u000aMatching on strings can be a painful task. SQL has added a range of tools to reduce\u000d\u000athe pain, and mastering them will keep you out of trouble. Although a lot can be\u000d\u000adone with the native SQL string functions, using the regular expression functions that\u000d\u000aare increasingly available takes it to another level altogether.\u000d\u000a6.18 Summing Up | 167","","CHAPTER 7\u000d\u000aWorking with Numbers\u000d\u000aThis chapter focuses on common operations involving numbers, including numeric\u000d\u000acomputations. While SQL is not typically considered the first choice for complex\u000d\u000acomputations, it is efficient for day-to-day numeric chores. More importantly, as\u000d\u000adatabases and datawarehouses supporting SQL probably remain the most common\u000d\u000aplace to find an organization\u2019s data, using SQL to explore and evaluate that data is\u000d\u000aessential for anyone putting that data to work. The techniques in this section have\u000d\u000aalso been chosen to help data scientists decide which data is the most promising for\u000d\u000afurther analysis.\u000d\u000aSome recipes in this chapter make use of aggregate functions and\u000d\u000athe GROUP BY clause. If you are not familiar with grouping,\u000d\u000aplease read at least the first major section, called \u201cGrouping,\u201d in\u000d\u000aAppendix A.\u000d\u000a7.1 Computing an Average\u000d\u000aProblem\u000d\u000aYou want to compute the average value in a column, either for all rows in a table or\u000d\u000afor some subset of rows. For example, you might want to find the average salary for\u000d\u000aall employees as well as the average salary for each department.\u000d\u000aSolution\u000d\u000aWhen computing the average of all employee salaries, simply apply the AVG function\u000d\u000ato the column containing those salaries.\u000d\u000a169","By excluding a WHERE clause, the average is computed against all non-NULL values:\u000d\u000a1 select avg(sal) as avg_sal\u000d\u000a2 from emp\u000d\u000a AVG_SAL\u000d\u000a----------\u000d\u000a2073.21429\u000d\u000aTo compute the average salary for each department, use the GROUP BY clause to cre\u2010\u000d\u000aate a group corresponding to each department:\u000d\u000a1 select deptno, avg(sal) as avg_sal\u000d\u000a2 from emp\u000d\u000a3 group by deptno\u000d\u000a DEPTNO AVG_SAL\u000d\u000a---------- ----------\u000d\u000a 10 2916.66667\u000d\u000a 20 2175\u000d\u000a 30 1566.66667\u000d\u000aDiscussion\u000d\u000aWhen finding an average where the whole table is the group or window, simply apply\u000d\u000athe AVG function to the column you are interested in without using the GROUP BY\u000d\u000aclause. It is important to realize that the function AVG ignores NULLs. The effect of\u000d\u000aNULL values being ignored can be seen here:\u000d\u000acreate table t2(sal integer)\u000d\u000ainsert into t2 values (10)\u000d\u000ainsert into t2 values (20)\u000d\u000ainsert into t2 values (null)\u000d\u000aselect avg(sal) select distinct 30/2\u000d\u000a from t2 from t2\u000d\u000a AVG(SAL) 30/2\u000d\u000a---------- ----------\u000d\u000a 15 15\u000d\u000aselect avg(coalesce(sal,0)) select distinct 30/3\u000d\u000a from t2 from t2\u000d\u000aAVG(COALESCE(SAL,0)) 30/3\u000d\u000a-------------------- ----------\u000d\u000a 10 10\u000d\u000aThe COALESCE function will return the first non-NULL value found in the list of\u000d\u000avalues that you pass. When NULL SAL values are converted to zero, the average\u000d\u000achanges. When invoking aggregate functions, always give thought to how you want\u000d\u000aNULLs handled.\u000d\u000a170 | Chapter 7: Working with Numbers","The second part of the solution uses GROUP BY (line 3) to divide employee records\u000d\u000ainto groups based on department affiliation. GROUP BY automatically causes aggre\u2010\u000d\u000agate functions such as AVG to execute and return a result for each group. In this\u000d\u000aexample, AVG would execute once for each department-based group of employee\u000d\u000arecords.\u000d\u000aIt is not necessary, by the way, to include GROUP BY columns in your select list. For\u000d\u000aexample:\u000d\u000aselect avg(sal)\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000a AVG(SAL)\u000d\u000a----------\u000d\u000a2916.66667\u000d\u000a 2175\u000d\u000a1566.66667\u000d\u000aYou are still grouping by DEPTNO even though it is not in the SELECT clause.\u000d\u000aIncluding the column you are grouping by in the SELECT clause often improves\u000d\u000areadability, but is not mandatory. It is mandatory, however, to avoid placing columns\u000d\u000ain your SELECT list that are not also in your GROUP BY clause.\u000d\u000aSee Also\u000d\u000aSee Appendix A for a refresher on GROUP BY functionality.\u000d\u000a7.2 Finding the Min/Max Value in a Column\u000d\u000aProblem\u000d\u000aYou want to find the highest and lowest values in a given column. For example, you\u000d\u000awant to find the highest and lowest salaries for all employees, as well as the highest\u000d\u000aand lowest salaries for each department.\u000d\u000aSolution\u000d\u000aWhen searching for the lowest and highest salaries for all employees, simply use the\u000d\u000afunctions MIN and MAX, respectively:\u000d\u000a1 select min(sal) as min_sal, max(sal) as max_sal\u000d\u000a 2 from emp\u000d\u000a MIN_SAL MAX_SAL\u000d\u000a---------- ----------\u000d\u000a 800 5000\u000d\u000a7.2 Finding the Min/Max Value in a Column | 171","When searching for the lowest and highest salaries for each department, use the func\u2010\u000d\u000ations MIN and MAX with the GROUP BY clause:\u000d\u000a1 select deptno, min(sal) as min_sal, max(sal) as max_sal\u000d\u000a 2 from emp\u000d\u000a 3 group by deptno\u000d\u000a DEPTNO MIN_SAL MAX_SAL\u000d\u000a ---------- ---------- ----------\u000d\u000a 10 1300 5000\u000d\u000a 20 800 3000\u000d\u000a 30 950 2850\u000d\u000aDiscussion\u000d\u000aWhen searching for the highest or lowest values, and in cases where the whole table is\u000d\u000athe group or window, simply apply the MIN or MAX function to the column you are\u000d\u000ainterested in without using the GROUP BY clause.\u000d\u000aRemember that the MIN and MAX functions ignore NULLs, and that you can have\u000d\u000aNULL groups as well as NULL values for columns in a group. The following are\u000d\u000aexamples that ultimately lead to a query using GROUP BY that returns NULL values\u000d\u000afor two groups (DEPTNO 10 and 20):\u000d\u000aselect deptno, comm\u000d\u000a from emp\u000d\u000a where deptno in (10,30)\u000d\u000a order by 1\u000d\u000a DEPTNO COMM\u000d\u000a ---------- ----------\u000d\u000a 10\u000d\u000a 10\u000d\u000a 10\u000d\u000a 30 300\u000d\u000a 30 500\u000d\u000a 30\u000d\u000a 30 0\u000d\u000a 30 1300\u000d\u000a 30\u000d\u000aselect min(comm), max(comm)\u000d\u000a from emp\u000d\u000a MIN(COMM) MAX(COMM)\u000d\u000a---------- ----------\u000d\u000a 0 1300\u000d\u000a172 | Chapter 7: Working with Numbers","select deptno, min(comm), max(comm)\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000a DEPTNO MIN(COMM) MAX(COMM)\u000d\u000a ---------- ---------- ----------\u000d\u000a 10\u000d\u000a 20\u000d\u000a 30 0 1300\u000d\u000aRemember, as Appendix A points out, even if nothing other than aggregate functions\u000d\u000aare listed in the SELECT clause, you can still group by other columns in the table; for\u000d\u000aexample:\u000d\u000aselect min(comm), max(comm)\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000a MIN(COMM) MAX(COMM)\u000d\u000a---------- ----------\u000d\u000a 0 1300\u000d\u000aHere you are still grouping by DEPTNO even though it is not in the SELECT clause.\u000d\u000aIncluding the column you are grouping by in the SELECT clause often improves\u000d\u000areadability, but is not mandatory. It is mandatory, however, that any column in the\u000d\u000aSELECT list of a GROUP BY query also be listed in the GROUP BY clause.\u000d\u000aSee Also\u000d\u000aSee Appendix A for a refresher on GROUP BY functionality.\u000d\u000a7.3 Summing the Values in a Column\u000d\u000aProblem\u000d\u000aYou want to compute the sum of all values, such as all employee salaries, in a column.\u000d\u000aSolution\u000d\u000aWhen computing a sum where the whole table is the group or window, just apply the\u000d\u000aSUM function to the columns you are interested in without using the GROUP BY\u000d\u000aclause:\u000d\u000a1 select sum(sal)\u000d\u000a2 from emp\u000d\u000a SUM(SAL)\u000d\u000a----------\u000d\u000a 29025\u000d\u000a7.3 Summing the Values in a Column | 173","When creating multiple groups or windows of data, use the SUM function with the\u000d\u000aGROUP BY clause. The following example sums employee salaries by department:\u000d\u000a1 select deptno, sum(sal) as total_for_dept\u000d\u000a2 from emp\u000d\u000a3 group by deptno\u000d\u000a DEPTNO TOTAL_FOR_DEPT\u000d\u000a---------- --------------\u000d\u000a 10 8750\u000d\u000a 20 10875\u000d\u000a 30 9400\u000d\u000aDiscussion\u000d\u000aWhen searching for the sum of all salaries for each department, you are creating\u000d\u000agroups or \u201cwindows\u201d of data. Each employee\u2019s salary is added together to produce a\u000d\u000atotal for their respective department. This is an example of aggregation in SQL\u000d\u000abecause detailed information, such as each individual employee\u2019s salary, is not the\u000d\u000afocus; the focus is the end result for each department. It is important to note that the\u000d\u000aSUM function will ignore NULLs, but you can have NULL groups, which can be seen\u000d\u000ahere. DEPTNO 10 does not have any employees who earn a commission; thus,\u000d\u000agrouping by DEPTNO 10 while attempting to SUM the values in COMM will result\u000d\u000ain a group with a NULL value returned by SUM:\u000d\u000aselect deptno, comm\u000d\u000a from emp\u000d\u000a where deptno in (10,30)\u000d\u000a order by 1\u000d\u000a DEPTNO COMM\u000d\u000a---------- ----------\u000d\u000a 10\u000d\u000a 10\u000d\u000a 10\u000d\u000a 30 300\u000d\u000a 30 500\u000d\u000a 30\u000d\u000a 30 0\u000d\u000a 30 1300\u000d\u000a 30\u000d\u000aselect sum(comm)\u000d\u000a from emp\u000d\u000a SUM(COMM)\u000d\u000a----------\u000d\u000a 2100\u000d\u000a174 | Chapter 7: Working with Numbers","select deptno, sum(comm)\u000d\u000a from emp\u000d\u000a where deptno in (10,30)\u000d\u000a group by deptno\u000d\u000a DEPTNO SUM(COMM)\u000d\u000a---------- ----------\u000d\u000a 10\u000d\u000a 30 2100\u000d\u000aSee Also\u000d\u000aSee Appendix A for a refresher on GROUP BY functionality.\u000d\u000a7.4 Counting Rows in a Table\u000d\u000aProblem\u000d\u000aYou want to count the number of rows in a table, or you want to count the number of\u000d\u000avalues in a column. For example, you want to find the total number of employees as\u000d\u000awell as the number of employees in each department.\u000d\u000aSolution\u000d\u000aWhen counting rows where the whole table is the group or window, simply use the\u000d\u000aCOUNT function along with the * character:\u000d\u000a1 select count(*)\u000d\u000a2 from emp\u000d\u000a COUNT(*)\u000d\u000a----------\u000d\u000a 14\u000d\u000aWhen creating multiple groups, or windows of data, use the COUNT function with\u000d\u000athe GROUP BY clause:\u000d\u000a1 select deptno, count(*)\u000d\u000a2 from emp\u000d\u000a3 group by deptno\u000d\u000a DEPTNO COUNT(*)\u000d\u000a---------- ----------\u000d\u000a 10 3\u000d\u000a 20 5\u000d\u000a 30 6\u000d\u000a7.4 Counting Rows in a Table | 175","Discussion\u000d\u000aWhen counting the number of employees for each department, you are creating\u000d\u000agroups or \u201cwindows\u201d of data. Each employee found increments the count by one to\u000d\u000aproduce a total for their respective department. This is an example of aggregation in\u000d\u000aSQL because detailed information, such as each individual employee\u2019s salary or job, is\u000d\u000anot the focus; the focus is the end result for each department. It is important to note\u000d\u000athat the COUNT function will ignore NULLs when passed a column name as an\u000d\u000aargument, but will include NULLs when passed the * character or any constant; con\u2010\u000d\u000asider the following:\u000d\u000aselect deptno, comm\u000d\u000a from emp\u000d\u000a DEPTNO COMM\u000d\u000a---------- ----------\u000d\u000a 20\u000d\u000a 30 300\u000d\u000a 30 500\u000d\u000a 20\u000d\u000a 30 1300\u000d\u000a 30\u000d\u000a 10\u000d\u000a 20\u000d\u000a 10\u000d\u000a 30 0\u000d\u000a 20\u000d\u000a 30\u000d\u000a 20\u000d\u000a 10\u000d\u000aselect count(*), count(deptno), count(comm), count('hello')\u000d\u000a from emp\u000d\u000a COUNT(*) COUNT(DEPTNO) COUNT(COMM) COUNT('HELLO')\u000d\u000a---------- ------------- ----------- --------------\u000d\u000a 14 14 4 14\u000d\u000aselect deptno, count(*), count(comm), count('hello')\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000a DEPTNO COUNT(*) COUNT(COMM) COUNT('HELLO')\u000d\u000a ---------- ---------- ----------- --------------\u000d\u000a 10 3 0 3\u000d\u000a 20 5 0 5\u000d\u000a 30 6 4 6\u000d\u000a176 | Chapter 7: Working with Numbers","If all rows are null for the column passed to COUNT or if the table is empty, COUNT\u000d\u000awill return zero. It should also be noted that, even if nothing other than aggregate\u000d\u000afunctions are specified in the SELECT clause, you can still group by other columns in\u000d\u000athe table, for example:\u000d\u000aselect count(*)\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000a COUNT(*)\u000d\u000a ----------\u000d\u000a 3\u000d\u000a 5\u000d\u000a 6\u000d\u000aNotice that you are still grouping by DEPTNO even though it is not in the SELECT\u000d\u000aclause. Including the column you are grouping by in the SELECT clause often\u000d\u000aimproves readability, but is not mandatory. If you do include it (in the SELECT list),\u000d\u000ait is mandatory that it is listed in the GROUP BY clause.\u000d\u000aSee Also\u000d\u000aSee Appendix A for a refresher on GROUP BY functionality.\u000d\u000a7.5 Counting Values in a Column\u000d\u000aProblem\u000d\u000aYou want to count the number of non-NULL values in a column. For example, you\u2019d\u000d\u000alike to find out how many employees are on commission.\u000d\u000aSolution\u000d\u000aCount the number of non-NULL values in the EMP table\u2019s COMM column:\u000d\u000aselect count(comm)\u000d\u000a from emp\u000d\u000aCOUNT(COMM)\u000d\u000a-----------\u000d\u000a 4\u000d\u000aDiscussion\u000d\u000aWhen you \u201ccount star,\u201d as in COUNT(*), what you are really counting is rows\u000d\u000a(regardless of actual value, which is why rows containing NULL and non-NULL val\u2010\u000d\u000aues are counted). But when you COUNT a column, you are counting the number of\u000d\u000anon-NULL values in that column. The previous recipe\u2019s discussion touches on this\u000d\u000a7.5 Counting Values in a Column | 177","distinction. In this solution, COUNT(COMM) returns the number of non-NULL\u000d\u000avalues in the COMM column. Since only commissioned employees have commis\u2010\u000d\u000asions, the result of COUNT(COMM) is the number of such employees.\u000d\u000a7.6 Generating a Running Total\u000d\u000aProblem\u000d\u000aYou want to calculate a running total of values in a column.\u000d\u000aSolution\u000d\u000aAs an example, the following solutions show how to compute a running total of salar\u2010\u000d\u000aies for all employees. For readability, results are ordered by SAL whenever possible so\u000d\u000athat you can easily eyeball the progression of the running total.\u000d\u000a1 select ename, sal,\u000d\u000a2 sum(sal) over (order by sal,empno) as running_total\u000d\u000a3 from emp\u000d\u000a4 order by 2\u000d\u000aENAME SAL RUNNING_TOTAL\u000d\u000a---------- ---------- -------------\u000d\u000aSMITH 800 800\u000d\u000aJAMES 950 1750\u000d\u000aADAMS 1100 2850\u000d\u000aWARD 1250 4100\u000d\u000aMARTIN 1250 5350\u000d\u000aMILLER 1300 6650\u000d\u000aTURNER 1500 8150\u000d\u000aALLEN 1600 9750\u000d\u000aCLARK 2450 12200\u000d\u000aBLAKE 2850 15050\u000d\u000aJONES 2975 18025\u000d\u000aSCOTT 3000 21025\u000d\u000aFORD 3000 24025\u000d\u000aKING 5000 29025\u000d\u000aDiscussion\u000d\u000aThe windowing function SUM OVER makes generating a running total a simple task. \u000d\u000aThe ORDER BY clause in the solution includes not only the SAL column, but also the\u000d\u000aEMPNO column (which is the primary key) to avoid duplicate values in the running\u000d\u000atotal. The column RUNNING_TOTAL2 in the following example illustrates the\u000d\u000aproblem that you might otherwise have with duplicates:\u000d\u000a178 | Chapter 7: Working with Numbers","select empno, sal,\u000d\u000a sum(sal)over(order by sal,empno) as running_total1,\u000d\u000a sum(sal)over(order by sal) as running_total2\u000d\u000a from emp\u000d\u000a order by 2\u000d\u000aENAME SAL RUNNING_TOTAL1 RUNNING_TOTAL2\u000d\u000a---------- ---------- -------------- --------------\u000d\u000aSMITH 800 800 800\u000d\u000aJAMES 950 1750 1750\u000d\u000aADAMS 1100 2850 2850\u000d\u000aWARD 1250 4100 5350\u000d\u000aMARTIN 1250 5350 5350\u000d\u000aMILLER 1300 6650 6650\u000d\u000aTURNER 1500 8150 8150\u000d\u000aALLEN 1600 9750 9750\u000d\u000aCLARK 2450 12200 12200\u000d\u000aBLAKE 2850 15050 15050\u000d\u000aJONES 2975 18025 18025\u000d\u000aSCOTT 3000 21025 24025\u000d\u000aFORD 3000 24025 24025\u000d\u000aKING 5000 29025 29025\u000d\u000aThe values in RUNNING_TOTAL2 for WARD, MARTIN, SCOTT, and FORD are\u000d\u000aincorrect. Their salaries occur more than once, and those duplicates are summed and\u000d\u000aadded to the running total. This is why EMPNO (which is unique) is needed to pro\u2010\u000d\u000aduce the (correct) results that you see in RUNNING_TOTAL1. Consider this: for\u000d\u000aADAMS you see 2850 for RUNNING_TOTAL1 and RUNNING_TOTAL2. Add\u000d\u000aWARD\u2019s salary of 1250 to 2850 and you get 4100, yet RUNNING_TOTAL2 returns\u000d\u000a5350. Why? Since WARD and MARTIN have the same SAL, their two 1250 salaries\u000d\u000aare added together to yield 2500, which is then added to 2850 to arrive at 5350 for\u000d\u000aboth WARD and MARTIN. By specifying a combination of columns to order by that\u000d\u000acannot result in duplicate values (e.g., any combination of SAL and EMPNO is\u000d\u000aunique), you ensure the correct progression of the running total.\u000d\u000a7.7 Generating a Running Product\u000d\u000aProblem\u000d\u000aYou want to compute a running product on a numeric column. The operation is simi\u2010\u000d\u000alar to Recipe 7.6, but using multiplication instead of addition.\u000d\u000aSolution\u000d\u000aBy way of example, the solutions all compute running products of employee salaries.\u000d\u000aWhile a running product of salaries may not be all that useful, the technique can\u000d\u000aeasily be applied to other, more useful domains.\u000d\u000a7.7 Generating a Running Product | 179","Use the windowing function SUM OVER and take advantage of the fact that you can\u000d\u000asimulate multiplication by adding logarithms:\u000d\u000a1 select empno,ename,sal,\u000d\u000a2 exp(sum(ln(sal))over(order by sal,empno)) as running_prod\u000d\u000a3 from emp\u000d\u000a4 where deptno = 10\u000d\u000aEMPNO ENAME SAL RUNNING_PROD\u000d\u000a----- ---------- ---- --------------------\u000d\u000a 7934 MILLER 1300 1300\u000d\u000a 7782 CLARK 2450 3185000\u000d\u000a 7839 KING 5000 15925000000\u000d\u000aIt is not valid in SQL (or, formally speaking, in mathematics) to compute logarithms\u000d\u000aof values less than or equal to zero. If you have such values in your tables, you need to\u000d\u000aavoid passing those invalid values to SQL\u2019s LN function. Precautions against invalid\u000d\u000avalues and NULLs are not provided in this solution for the sake of readability, but\u000d\u000ayou should consider whether to place such precautions in production code that you\u000d\u000awrite. If you absolutely must work with negative and zero values, then this solution\u000d\u000amay not work for you. At the same time, if you have zeros (but no values below zero),\u000d\u000aa common workaround is to add 1 to all values, noting that the logarithm of 1 is\u000d\u000aalways zero regardless of base.\u000d\u000aSQL Server users use LOG instead of LN.\u000d\u000aDiscussion\u000d\u000aThe solution takes advantage of the fact that you can multiply two numbers by:\u000d\u000a1. Computing their respective natural logarithms\u000d\u000a2. Summing those logarithms\u000d\u000a3. Raising the result to the power of the mathematical constant e (using the EXP\u000d\u000afunction)\u000d\u000aThe one caveat when using this approach is that it doesn\u2019t work for summing zero or\u000d\u000anegative values, because any value less than or equal to zero is out of range for an\u000d\u000aSQL logarithm.\u000d\u000aFor an explanation of how the window function SUM OVER works, see Recipe 7.6.\u000d\u000a180 | Chapter 7: Working with Numbers","7.8 Smoothing a Series of Values\u000d\u000aProblem\u000d\u000aYou have a series of values that appear over time, such as monthly sales figures. As is\u000d\u000acommon, the data shows a lot of variation from point to point, but you are interested\u000d\u000ain the overall trend. Therefore, you want to implement a simple smoother, such as\u000d\u000aweighted running average to better identify the trend.\u000d\u000aImagine you have daily sales totals, in dollars, such as from a newsstand:\u000d\u000aDATE1 SALES\u000d\u000a2020-01-01 647\u000d\u000a2020-01-02 561\u000d\u000a2020-01-03 741\u000d\u000a2020-01-04 978\u000d\u000a2020-01-05 1062\u000d\u000a2020-01-06 1072\u000d\u000a... ...\u000d\u000aHowever, you know that there is volatility to the sales data that makes it difficult to\u000d\u000adiscern an underlying trend. Possibly different days of the week or month are known\u000d\u000ato have especially high or low sales. Alternatively, maybe you are aware that due to\u000d\u000athe way the data is collected, sometimes sales for one day are moved into the next day,\u000d\u000acreating a trough followed by a peak, but there is no practical way to allocate the sales\u000d\u000ato their correct day. Therefore, you need to smooth the data over a number of days to\u000d\u000aachieve a proper view of what\u2019s happening.\u000d\u000aA moving average can be calculated by summing the current value and the preceding\u000d\u000an-1 values and dividing by n. If you also display the previous values for reference, you\u000d\u000aexpect something like this:\u000d\u000aDATE1 sales salesLagOne SalesLagTwo MovingAverage\u000d\u000a----- ------ ----------- ------------ --------------\u000d\u000a2020-01-01 647 NULL NULl NULL\u000d\u000a2020-01-02 561 647 NULL NULL\u000d\u000a2020-01-03 741 561 647 649.667\u000d\u000a2020-01-04 978 741 561 760\u000d\u000a2020-01-05 1062 978 741 927\u000d\u000a2020-01-06 1072 1062 978 1037.333\u000d\u000a2020-01-07 805 1072 1062 979.667\u000d\u000a2020-01-08 662 805 1072 846.333\u000d\u000a2020-01-09 1083 662 805 850\u000d\u000a2020-01-10 970 1083 662 905\u000d\u000a7.8 Smoothing a Series of Values | 181","Solution\u000d\u000aThe formula for the mean is well known. By applying a simple weighting to the for\u2010\u000d\u000amula, we can make it more relevant for this task by giving more weight to more\u000d\u000arecent values. Use the window function LAG to create a moving average:\u000d\u000aselect date1, sales,lag(sales,1) over(order by date1) as salesLagOne,\u000d\u000alag(sales,2) over(order by date1) as salesLagTwo,\u000d\u000a(sales\u000d\u000a+ (lag(sales,1) over(order by date1))\u000d\u000a+ lag(sales,2) over(order by date1))/3 as MovingAverage\u000d\u000afrom sales\u000d\u000aDiscussion\u000d\u000aA weighted moving average is one of the simplest ways to analyze time-series data\u000d\u000a(data that appears at particular time intervals). This is just one way to calculate a sim\u2010\u000d\u000aple moving average\u2014you can also use a partition with average. Although we have\u000d\u000aselected a simple three-point moving average, there are different formulas with differ\u2010\u000d\u000aing numbers of points according to the characteristics of the data you apply them\u000d\u000a[.keep-together]#to\u2014#that\u2019s where this technique really comes into its own.\u000d\u000aFor example, a simple three-point weighted moving average that emphasizes the most\u000d\u000arecent data point could be implemented with the following variant on the solution,\u000d\u000awhere coefficients and the denominator have been updated:\u000d\u000aselect date1, sales,lag(sales,1) over(order by date1),\u000d\u000alag(sales,2) over(order by date1),\u000d\u000a((3*sales)\u000d\u000a+ (2*(lag(sales,1) over(order by date1)))\u000d\u000a+ (lag(sales,2) over(order by date1)))/6 as SalesMA\u000d\u000afrom sales\u000d\u000a7.9 Calculating a Mode\u000d\u000aProblem\u000d\u000aYou want to find the mode (for those of you who don\u2019t recall, the mode in mathemat\u2010\u000d\u000aics is the element that appears most frequently for a given set of data) of the values in\u000d\u000aa column. For example, you want to find the mode of the salaries in DEPTNO 20.\u000d\u000aBased on the following salaries:\u000d\u000aselect sal\u000d\u000a from emp\u000d\u000a where deptno = 20\u000d\u000a order by sal\u000d\u000a182 | Chapter 7: Working with Numbers"," SAL\u000d\u000a----------\u000d\u000a 800\u000d\u000a 1100\u000d\u000a 2975\u000d\u000a 3000\u000d\u000a 3000\u000d\u000athe mode is 3000.\u000d\u000aSolution\u000d\u000aDB2, MySQL, PostgreSQL, and SQL Server\u000d\u000aUse the window function DENSE_RANK to rank the counts of the salaries to facili\u2010\u000d\u000atate extracting the mode:\u000d\u000a 1 select sal\u000d\u000a 2 from (\u000d\u000a 3 select sal,\u000d\u000a 4 dense_rank()over( order by cnt desc) as rnk\u000d\u000a 5 from (\u000d\u000a 6 select sal, count(*) as cnt\u000d\u000a 8 from emp\u000d\u000a 9 where deptno = 20\u000d\u000a10 group by sal\u000d\u000a11 ) x\u000d\u000a12 ) y\u000d\u000a13 where rnk = 1\u000d\u000aOracle\u000d\u000aYou can use the KEEP extension to the aggregate function MAX to find the mode\u000d\u000aSAL. One important note is that if there are ties, i.e., multiple rows that are the mode,\u000d\u000athe solution using KEEP will keep only one, and that is the one with the highest sal\u2010\u000d\u000aary. If you want to see all modes (if more than one exists), you must modify this solu\u2010\u000d\u000ation or simply use the DB2 solution presented earlier. In this case, since 3000 is the\u000d\u000amode SAL in DEPTNO 20 and is also the highest SAL, this solution is sufficient:\u000d\u000a1 select max(sal)\u000d\u000a2 keep(dense_rank first order by cnt desc) sal\u000d\u000a3 from (\u000d\u000a4 select sal, count(*) cnt\u000d\u000a5 from emp\u000d\u000a6 where deptno=20\u000d\u000a7 group by sal\u000d\u000a8 )\u000d\u000a7.9 Calculating a Mode | 183","Discussion\u000d\u000aDB2 and SQL Server\u000d\u000aThe inline view X returns each SAL and the number of times it occurs. Inline view Y\u000d\u000auses the window function DENSE_RANK (which allows for ties) to sort the results.\u000d\u000aThe results are ranked based on the number of times each SAL occurs, as shown here:\u000d\u000a1 select sal,\u000d\u000a2 dense_rank()over(order by cnt desc) as rnk\u000d\u000a3 from (\u000d\u000a4 select sal,count(*) as cnt\u000d\u000a5 from emp\u000d\u000a6 where deptno = 20\u000d\u000a7 group by sal\u000d\u000a8 ) x\u000d\u000a SAL RNK\u000d\u000a----- ----------\u000d\u000a 3000 1\u000d\u000a 800 2\u000d\u000a 1100 2\u000d\u000a 2975 2\u000d\u000aThe outermost portion of query simply keeps the row(s) where RNK is 1.\u000d\u000aOracle\u000d\u000aThe inline view returns each SAL and the number of times it occurs and is shown\u000d\u000ahere:\u000d\u000aselect sal, count(*) cnt\u000d\u000a from emp\u000d\u000a where deptno=20\u000d\u000a group by sal\u000d\u000a SAL CNT\u000d\u000a ----- ----------\u000d\u000a 800 1\u000d\u000a 1100 1\u000d\u000a 2975 1\u000d\u000a 3000 2\u000d\u000aThe next step is to use the KEEP extension of the aggregate function MAX to find the\u000d\u000amode. If you analyze the KEEP clause shown here, you will notice three subclauses,\u000d\u000aDENSE_RANK, FIRST, and ORDER BY CNT DESC:\u000d\u000akeep(dense_rank first order by cnt desc)\u000d\u000a184 | Chapter 7: Working with Numbers","This makes finding the mode extremely convenient. The KEEP clause determines\u000d\u000awhich SAL will be returned by MAX by looking at the value of CNT returned by the\u000d\u000ainline view. Working from right to left, the values for CNT are ordered in descending\u000d\u000aorder; then the first is kept of all the values for CNT returned in DENSE_RANK\u000d\u000aorder. Looking at the result set from the inline view, you can see that 3000 has the\u000d\u000ahighest CNT of 2. The MAX(SAL) returned is the greatest SAL that has the greatest\u000d\u000aCNT, in this case 3000.\u000d\u000aSee Also\u000d\u000aSee Chapter 11, particularly the section on \u201cFinding Knight Values,\u201d for a deeper dis\u2010\u000d\u000acussion of Oracle\u2019s KEEP extension of aggregate functions.\u000d\u000a7.10 Calculating a Median\u000d\u000aProblem\u000d\u000aYou want to calculate the median (for those of who do not recall, the median is the\u000d\u000avalue of the middle member of a set of ordered elements) value for a column of\u000d\u000anumeric values. For example, you want to find the median of the salaries in DEPTNO\u000d\u000a20. Based on the following salaries:\u000d\u000aselect sal\u000d\u000a from emp\u000d\u000a where deptno = 20\u000d\u000a order by sal\u000d\u000a SAL\u000d\u000a----------\u000d\u000a 800\u000d\u000a 1100\u000d\u000a 2975\u000d\u000a 3000\u000d\u000a 3000\u000d\u000athe median is 2975.\u000d\u000aSolution\u000d\u000aOther than the Oracle solution (which uses supplied functions to compute a median),\u000d\u000athe introduction of window functions allows for a more efficient solution compared\u000d\u000ato the traditional self-join.\u000d\u000aDB2 and PostgreSQL\u000d\u000aUse the window function PERCENTILE_CONT to find the median:\u000d\u000a7.10 Calculating a Median | 185","1 select percentile_cont(0.5)\u000d\u000a2 within group(order by sal)\u000d\u000a3 from emp\u000d\u000a4 where deptno=20\u000d\u000aSQL Server\u000d\u000aUse the window function PERCENTILE_CONT to find the median:\u000d\u000a1 select percentile_cont(0.5)\u000d\u000a 2 within group(order by sal)\u000d\u000a 3 over()\u000d\u000a 4 from emp\u000d\u000a 5 where deptno=20\u000d\u000aThe SQL Server solution works on the same principle but requires an OVER clause.\u000d\u000aMySQL\u000d\u000aMySQL doesn\u2019t have the PERCENTILE_CONT function, so a workaround is\u000d\u000arequired. One way is to use the CUME_DIST function in conjunction with a CTE,\u000d\u000aeffectively re-creating the PERCENTILE_CONT function:\u000d\u000awith rank_tab (sal, rank_sal) as\u000d\u000a(\u000d\u000aselect sal, cume_dist() over (order by sal)\u000d\u000a from emp\u000d\u000a where deptno=20\u000d\u000a),\u000d\u000ainter as\u000d\u000a(\u000d\u000a select sal, rank_sal from rank_tab\u000d\u000a where rank_sal>=0.5\u000d\u000aunion\u000d\u000a select sal, rank_sal from rank_tab\u000d\u000a where rank_sal<=0.5\u000d\u000a)\u000d\u000a select avg(sal) as MedianSal\u000d\u000a from inter\u000d\u000aOracle\u000d\u000aUse the functions MEDIAN or PERCENTILE_CONT:\u000d\u000a1 select median(sal)\u000d\u000a2 from emp\u000d\u000a3 where deptno=20\u000d\u000a1 select percentile_cont(0.5)\u000d\u000a2 within group(order by sal)\u000d\u000a186 | Chapter 7: Working with Numbers","3 from emp\u000d\u000a4 where deptno=20\u000d\u000aDiscussion\u000d\u000aOracle, PostgreSQL, SQL Server, and DB2\u000d\u000aOther than Oracle\u2019s MEDIAN function, the structure of all the solutions is the same.\u000d\u000aThe PERCENTILE_CONT function allows you to directly apply the definition of a\u000d\u000amedian, as the median is by definition the 50th percentile. Hence, applying this func\u2010\u000d\u000ation with the appropriate syntax and using 0.5 as the argument finds the median.\u000d\u000aOf course, other percentiles are also available from this function. For example, you\u000d\u000acan look for the 5th and/or 95th percentiles to find outliers (another method of find\u2010\u000d\u000aing outliers is outlined later in this chapter when we discuss the median absolute\u000d\u000adeviation).\u000d\u000aMySQL\u000d\u000aMySQL doesn\u2019t have a PERCENTILE_CONT function, which makes things trickier.\u000d\u000aTo find the median, the values for SAL must be ordered from lowest to highest. The\u000d\u000aCUME_DIST function achieves this goal and labels each row with its percentile.\u000d\u000aHence, it can be used to achieve the same outcome as the PERCENTILE_CONT\u000d\u000afunction used in the solution for the other databases.\u000d\u000aThe only difficulty is that the CUME_DIST function is not permitted in a WHERE\u000d\u000aclause. As a result, you need to apply it first in a CTE.\u000d\u000aThe only trap here is that if the number of rows is even, there won\u2019t be a row exactly\u000d\u000aon the median. Hence, the solution is written to find the average of the highest value\u000d\u000abelow or equal to the median, and the lowest value above or equal to the median.\u000d\u000aThis method works for both odd and even numbers of rows, and if there is an odd\u000d\u000anumber of rows giving an exact median, it will take average of two numbers that are\u000d\u000aequal.\u000d\u000a7.11 Determining the Percentage of a Total\u000d\u000aProblem\u000d\u000aYou want to determine the percentage that values in a specific column represent\u000d\u000aagainst a total. For example, you want to determine what percentage of all salaries are\u000d\u000athe salaries in DEPTNO 10 (the percentage that DEPTNO 10 salaries contribute to\u000d\u000athe total).\u000d\u000a7.11 Determining the Percentage of a Total | 187","Solution\u000d\u000aIn general, computing a percentage against a total in SQL is no different than doing\u000d\u000aso on paper: simply divide, then multiply. In this example you want to find the per\u2010\u000d\u000acentage of total salaries in table EMP that come from DEPTNO 10. To do that, simply\u000d\u000afind the salaries for DEPTNO 10, and then divide by the total salary for the table. As\u000d\u000athe last step, multiply by 100 to return a value that represents a percent.\u000d\u000aMySQL and PostgreSQL\u000d\u000aDivide the sum of the salaries in DEPTNO 10 by the sum of all salaries:\u000d\u000a1 select (sum(\u000d\u000a2 case when deptno = 10 then sal end)/sum(sal)\u000d\u000a3 )*100 as pct\u000d\u000a4 from emp\u000d\u000aDB2, Oracle, and SQL Server\u000d\u000aUse an inline view with the window function SUM OVER to find the sum of all salar\u2010\u000d\u000aies along with the sum of all salaries in DEPTNO 10. Then do the division and multi\u2010\u000d\u000aplication in the outer query:\u000d\u000a1 select distinct (d10/total)*100 as pct\u000d\u000a2 from (\u000d\u000a3 select deptno,\u000d\u000a4 sum(sal)over() total,\u000d\u000a5 sum(sal)over(partition by deptno) d10\u000d\u000a6 from emp\u000d\u000a7 ) x\u000d\u000a8 where deptno=10\u000d\u000aDiscussion\u000d\u000aMySQL and PostgreSQL\u000d\u000aThe CASE statement conveniently returns only the salaries from DEPTNO 10. They\u000d\u000aare then summed and divided by the sum of all the salaries. Because NULLs are\u000d\u000aignored by aggregates, an ELSE clause is not needed in the CASE statement. To see\u000d\u000aexactly which values are divided, execute the query without the division:\u000d\u000aselect sum(case when deptno = 10 then sal end) as d10,\u000d\u000a sum(sal)\u000d\u000a from emp\u000d\u000aD10 SUM(SAL)\u000d\u000a---- ---------\u000d\u000a8750 29025\u000d\u000a188 | Chapter 7: Working with Numbers","Depending on how you define SAL, you may need to explicitly use CAST when per\u2010\u000d\u000aforming division to ensure the correct data type. For example, on DB2, SQL Server,\u000d\u000aand PostgreSQL, if SAL is stored as an integer, you can apply CAST to ensure a deci\u2010\u000d\u000amal value is returned, as shown here:\u000d\u000aselect (cast(\u000d\u000a sum(case when deptno = 10 then sal end)\u000d\u000a as decimal)/sum(sal)\u000d\u000a )*100 as pct\u000d\u000a from emp\u000d\u000aDB2, Oracle, and SQL Server\u000d\u000aAs an alternative to the traditional solution, this solution uses window functions to\u000d\u000acompute a percentage relative to the total. For DB2 and SQL Server, if you\u2019ve stored\u000d\u000aSAL as an integer, you\u2019ll need to use CAST before dividing:\u000d\u000aselect distinct\u000d\u000a cast(d10 as decimal)/total*100 as pct\u000d\u000a from (\u000d\u000aselect deptno,\u000d\u000a sum(sal)over() total,\u000d\u000a sum(sal)over(partition by deptno) d10\u000d\u000a from emp\u000d\u000a ) x\u000d\u000a where deptno=10\u000d\u000aIt is important to keep in mind that window functions are applied after the WHERE\u000d\u000aclause is evaluated. Thus, the filter on DEPTNO cannot be performed in inline view\u000d\u000aX. Consider the results of inline view X without and with the filter on DEPTNO. First\u000d\u000awithout:\u000d\u000aselect deptno,\u000d\u000a sum(sal)over() total,\u000d\u000a sum(sal)over(partition by deptno) d10\u000d\u000a from emp\u000d\u000aDEPTNO TOTAL D10\u000d\u000a------- --------- ---------\u000d\u000a 10 29025 8750\u000d\u000a 10 29025 8750\u000d\u000a 10 29025 8750\u000d\u000a 20 29025 10875\u000d\u000a 20 29025 10875\u000d\u000a 20 29025 10875\u000d\u000a 20 29025 10875\u000d\u000a 20 29025 10875\u000d\u000a 30 29025 9400\u000d\u000a 30 29025 9400\u000d\u000a 30 29025 9400\u000d\u000a 30 29025 9400\u000d\u000a7.11 Determining the Percentage of a Total | 189"," 30 29025 9400\u000d\u000a 30 29025 9400\u000d\u000aand now with:\u000d\u000aselect deptno,\u000d\u000a sum(sal)over() total,\u000d\u000a sum(sal)over(partition by deptno) d10\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000aDEPTNO TOTAL D10\u000d\u000a------ --------- ---------\u000d\u000a 10 8750 8750\u000d\u000a 10 8750 8750\u000d\u000a 10 8750 8750\u000d\u000aBecause window functions are applied after the WHERE clause, the value for TOTAL\u000d\u000arepresents the sum of all salaries in DEPTNO 10 only. But to solve the problem you\u000d\u000awant the TOTAL to represent the sum of all salaries, period. That\u2019s why the filter on\u000d\u000aDEPTNO must happen outside of inline view X.\u000d\u000a7.12 Aggregating Nullable Columns\u000d\u000aProblem\u000d\u000aYou want to perform an aggregation on a column, but the column is nullable. You\u000d\u000awant the accuracy of your aggregation to be preserved, but are concerned because\u000d\u000aaggregate functions ignore NULLs. For example, you want to determine the average\u000d\u000acommission for employees in DEPTNO 30, but there are some employees who do not\u000d\u000aearn a commission (COMM is NULL for those employees). Because NULLs are\u000d\u000aignored by aggregates, the accuracy of the output is compromised. You would like to\u000d\u000asomehow include NULL values in your aggregation.\u000d\u000aSolution\u000d\u000aUse the COALESCE function to convert NULLs to zero so they will be included in\u000d\u000athe aggregation:\u000d\u000a1 select avg(coalesce(comm,0)) as avg_comm\u000d\u000a2 from emp\u000d\u000a3 where deptno=30\u000d\u000aDiscussion\u000d\u000aWhen working with aggregate functions, keep in mind that NULLs are ignored. Con\u2010\u000d\u000asider the output of the solution without using the COALESCE function:\u000d\u000a190 | Chapter 7: Working with Numbers","select avg(comm)\u000d\u000a from emp\u000d\u000a where deptno=30\u000d\u000a AVG(COMM)\u000d\u000a ---------\u000d\u000a 550\u000d\u000aThis query shows an average commission of 550 for DEPTNO 30, but a quick exami\u2010\u000d\u000anation of those rows:\u000d\u000aselect ename, comm\u000d\u000a from emp\u000d\u000a where deptno=30\u000d\u000aorder by comm desc\u000d\u000aENAME COMM\u000d\u000a---------- ---------\u000d\u000aBLAKE\u000d\u000aJAMES\u000d\u000aMARTIN 1400\u000d\u000aWARD 500\u000d\u000aALLEN 300\u000d\u000aTURNER 0\u000d\u000ashows that only four of the six employees can earn a commission. The sum of all\u000d\u000acommissions in DEPTNO 30 is 2200, and the average should be 2200/6, not 2200/4.\u000d\u000aBy excluding the COALESCE function, you answer the question \u201cWhat is the average\u000d\u000acommission of employees in DEPTNO 30 who can earn a commission?\u201d rather than\u000d\u000a\u201cWhat is the average commission of all employees in DEPTNO 30?\u201d When working\u000d\u000awith aggregates, remember to treat NULLs accordingly.\u000d\u000a7.13 Computing Averages Without High and Low Values\u000d\u000aProblem\u000d\u000aYou want to compute an average, but you want to exclude the highest and lowest val\u2010\u000d\u000aues to (hopefully) reduce the effect of skew. In statistical language, this is known as a\u000d\u000atrimmed mean. For example, you want to compute the average salary of all employees\u000d\u000aexcluding the highest and lowest salaries.\u000d\u000aSolution\u000d\u000aMySQL and PostgreSQL\u000d\u000aUse subqueries to exclude high and low values:\u000d\u000a1 select avg(sal)\u000d\u000a2 from emp\u000d\u000a7.13 Computing Averages Without High and Low Values | 191","3 where sal not in (\u000d\u000a4 (select min(sal) from emp),\u000d\u000a5 (select max(sal) from emp)\u000d\u000a6 )\u000d\u000aDB2, Oracle, and SQL Server\u000d\u000aUse an inline view with the windowing functions MAX OVER and MIN OVER to\u000d\u000agenerate a result set from which you can easily eliminate the high and low values:\u000d\u000a1 select avg(sal)\u000d\u000a2 from (\u000d\u000a3 select sal, min(sal)over() min_sal, max(sal)over() max_sal\u000d\u000a4 from emp\u000d\u000a5 ) x\u000d\u000a6 where sal not in (min_sal,max_sal)\u000d\u000aDiscussion\u000d\u000aMySQL and PostgreSQL\u000d\u000aThe subqueries return the highest and lowest salaries in the table. By using NOT IN\u000d\u000aagainst the values returned, you exclude the highest and lowest salaries from the aver\u2010\u000d\u000aage. Keep in mind that if there are duplicates (if multiple employees have the highest\u000d\u000aor lowest salaries), they will all be excluded from the average. If your goal is to\u000d\u000aexclude only a single instance of the high and low values, simply subtract them from\u000d\u000athe SUM and then divide:\u000d\u000aselect (sum(sal)-min(sal)-max(sal))/(count(*)-2)\u000d\u000a from emp\u000d\u000aDB2, Oracle, and SQL Server\u000d\u000aInline view X returns each salary along with the highest and lowest salaries:\u000d\u000aselect sal, min(sal)over() min_sal, max(sal)over() max_sal\u000d\u000a from emp\u000d\u000a SAL MIN_SAL MAX_SAL\u000d\u000a--------- --------- ---------\u000d\u000a 800 800 5000\u000d\u000a 1600 800 5000\u000d\u000a 1250 800 5000\u000d\u000a 2975 800 5000\u000d\u000a 1250 800 5000\u000d\u000a 2850 800 5000\u000d\u000a 2450 800 5000\u000d\u000a 3000 800 5000\u000d\u000a 5000 800 5000\u000d\u000a 1500 800 5000\u000d\u000a 1100 800 5000\u000d\u000a192 | Chapter 7: Working with Numbers"," 950 800 5000\u000d\u000a 3000 800 5000\u000d\u000a 1300 800 5000\u000d\u000aYou can access the high and low salaries at every row, so finding which salaries are\u000d\u000ahighest and/or lowest is trivial. The outer query filters the rows returned from inline\u000d\u000aview X such that any salary that matches either MIN_SAL or MAX_SAL is excluded\u000d\u000afrom the average.\u000d\u000aRobust Statistics\u000d\u000aIn statistical parlance, a mean calculated with the largest and small\u2010\u000d\u000aest values removed is called a trimmed mean. This can be consid\u2010\u000d\u000aered a safer estimate of the average, and is an example of a robust\u000d\u000astatistic, so called because they are less sensitive to problems such\u000d\u000aas bias. Recipe 7.16 is another example of a robust statistical tool.\u000d\u000aIn both cases, these approaches are valuable to someone analyzing\u000d\u000adata within an RDBMS because they don\u2019t require the analyst to\u000d\u000amake assumptions that are difficult to test with the relatively limi\u2010\u000d\u000ated range of statistical tools available in SQL.\u000d\u000a7.14 Converting Alphanumeric Strings into Numbers\u000d\u000aProblem\u000d\u000aYou have alphanumeric data and would like to return numbers only. You want to\u000d\u000areturn the number 123321 from the string \u201cpaul123f321.\u201d\u000d\u000aSolution\u000d\u000aDB2\u000d\u000aUse the functions TRANSLATE and REPLACE to extract numeric characters from an\u000d\u000aalphanumeric string:\u000d\u000a1 select cast(\u000d\u000a2 replace(\u000d\u000a3 translate( 'paul123f321',\u000d\u000a4 repeat('#',26),\u000d\u000a5 'abcdefghijklmnopqrstuvwxyz'),'#','')\u000d\u000a6 as integer ) as num\u000d\u000a7 from t1\u000d\u000aOracle, SQL Server, and PostgreSQL\u000d\u000aUse the functions TRANSLATE and REPLACE to extract numeric characters from an\u000d\u000aalphanumeric string:\u000d\u000a7.14 Converting Alphanumeric Strings into Numbers | 193","1 select cast(\u000d\u000a2 replace(\u000d\u000a3 translate( 'paul123f321',\u000d\u000a4 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a5 rpad('#',26,'#')),'#','')\u000d\u000a6 as integer ) as num\u000d\u000a7 from t1\u000d\u000aMySQL\u000d\u000aAs of the time of this writing, MySQL doesn\u2019t support the TRANSLATE function;\u000d\u000athus, a solution will not be provided.\u000d\u000aDiscussion\u000d\u000aThe only difference between the two solutions is syntax; DB2 uses the function\u000d\u000aREPEAT rather than RPAD, and the parameter list for TRANSLATE is in a different\u000d\u000aorder. The following explanation uses the Oracle/PostgreSQL solution but is relevant\u000d\u000ato DB2 as well. If you run query inside out (starting with TRANSLATE only), you\u2019ll\u000d\u000asee this is simple. First, TRANSLATE converts any nonnumeric character to an\u000d\u000ainstance of #:\u000d\u000aselect translate( 'paul123f321',\u000d\u000a 'abcdefghijklmnopqrstuvwxyz',\u000d\u000a rpad('#',26,'#')) as num\u000d\u000a from t1\u000d\u000aNUM\u000d\u000a-----------\u000d\u000a####123#321\u000d\u000aSince all nonnumeric characters are now represented by #, simply use REPLACE to\u000d\u000aremove them, then use CAST the return the result as a number. This particular exam\u2010\u000d\u000aple is extremely simple because the data is alphanumeric. If additional characters can\u000d\u000abe stored, rather than fishing for those characters, it is easier to approach this prob\u2010\u000d\u000alem differently: rather than finding nonnumeric characters and then removing them,\u000d\u000afind all numeric characters and remove anything that is not among them. The follow\u2010\u000d\u000aing example will help clarify this technique:\u000d\u000aselect replace(\u000d\u000a translate('paul123f321',\u000d\u000a replace(translate( 'paul123f321',\u000d\u000a '0123456789',\u000d\u000a rpad('#',10,'#')),'#',''),\u000d\u000a rpad('#',length('paul123f321'),'#')),'#','') as num\u000d\u000a from t1\u000d\u000aNUM\u000d\u000a-----------\u000d\u000a123321\u000d\u000a194 | Chapter 7: Working with Numbers","This solution looks a bit more convoluted than the original but is not so bad once you\u000d\u000abreak it down. Observe the innermost call to TRANSLATE:\u000d\u000aselect translate( 'paul123f321',\u000d\u000a '0123456789',\u000d\u000a rpad('#',10,'#'))\u000d\u000a from t1\u000d\u000aTRANSLATE('\u000d\u000a-----------\u000d\u000apaul###f###\u000d\u000aSo, the initial approach is different; rather than replacing each nonnumeric character\u000d\u000awith an instance of #, you replace each numeric character with an instance of #. The\u000d\u000anext step removes all instances of #, thus leaving only nonnumeric characters:\u000d\u000aselect replace(translate( 'paul123f321',\u000d\u000a '0123456789',\u000d\u000a rpad('#',10,'#')),'#','')\u000d\u000a from t1\u000d\u000aREPLA\u000d\u000a-----\u000d\u000apaulf\u000d\u000aThe next step is to call TRANSLATE again, this time to replace each of the nonnu\u2010\u000d\u000americ characters (from the previous query) with an instance of # in the original\u000d\u000astring:\u000d\u000aselect translate('paul123f321',\u000d\u000a replace(translate( 'paul123f321',\u000d\u000a '0123456789',\u000d\u000a rpad('#',10,'#')),'#',''),\u000d\u000a rpad('#',length('paul123f321'),'#'))\u000d\u000a from t1\u000d\u000aTRANSLATE('\u000d\u000a-----------\u000d\u000a####123#321\u000d\u000aAt this point, stop and examine the outermost call to TRANSLATE. The second\u000d\u000aparameter to RPAD (or the second parameter to REPEAT for DB2) is the length of\u000d\u000athe original string. This is convenient to use since no character can occur enough\u000d\u000atimes to be greater than the string it is part of. Now that all nonnumeric characters\u000d\u000aare replaced by instances of #, the last step is to use REPLACE to remove all instances\u000d\u000aof #. Now you are left with a number.\u000d\u000a7.14 Converting Alphanumeric Strings into Numbers | 195","7.15 Changing Values in a Running Total\u000d\u000aProblem\u000d\u000aYou want to modify the values in a running total depending on the values in another\u000d\u000acolumn. Consider a scenario where you want to display the transaction history of a\u000d\u000acredit card account along with the current balance after each transaction. The follow\u2010\u000d\u000aing view, V, will be used in this example:\u000d\u000acreate view V (id,amt,trx)\u000d\u000aas\u000d\u000aselect 1, 100, 'PR' from t1 union all\u000d\u000aselect 2, 100, 'PR' from t1 union all\u000d\u000aselect 3, 50, 'PY' from t1 union all\u000d\u000aselect 4, 100, 'PR' from t1 union all\u000d\u000aselect 5, 200, 'PY' from t1 union all\u000d\u000aselect 6, 50, 'PY' from t1\u000d\u000a select * from V\u000d\u000aID AMT TR\u000d\u000a-- ---------- --\u000d\u000a 1 100 PR\u000d\u000a 2 100 PR\u000d\u000a 3 50 PY\u000d\u000a 4 100 PR\u000d\u000a 5 200 PY\u000d\u000a 6 50 PY\u000d\u000aThe ID column uniquely identifies each transaction. The AMT column represents the\u000d\u000aamount of money involved in each transaction (either a purchase or a payment). The\u000d\u000aTRX column defines the type of transaction; a payment is \u201cPY\u201d and a purchase is\u000d\u000a\u201cPR.\u201d If the value for TRX is PY, you want the current value for AMT subtracted from\u000d\u000athe running total; if the value for TRX is PR, you want the current value for AMT\u000d\u000aadded to the running total. Ultimately you want to return the following result set:\u000d\u000aTRX_TYPE AMT BALANCE\u000d\u000a-------- ---------- ----------\u000d\u000aPURCHASE 100 100\u000d\u000aPURCHASE 100 200\u000d\u000aPAYMENT 50 150\u000d\u000aPURCHASE 100 250\u000d\u000aPAYMENT 200 50\u000d\u000aPAYMENT 50 0\u000d\u000aSolution\u000d\u000aUse the window function SUM OVER to create the running total along with a CASE\u000d\u000aexpression to determine the type of transaction:\u000d\u000a196 | Chapter 7: Working with Numbers"," 1 select case when trx = 'PY'\u000d\u000a 2 then 'PAYMENT'\u000d\u000a 3 else 'PURCHASE'\u000d\u000a 4 end trx_type,\u000d\u000a 5 amt,\u000d\u000a 6 sum(\u000d\u000a 7 case when trx = 'PY'\u000d\u000a 8 then -amt else amt\u000d\u000a 9 end\u000d\u000a10 ) over (order by id,amt) as balance\u000d\u000a11 from V\u000d\u000aDiscussion\u000d\u000aThe CASE expression determines whether the current AMT is added or deducted\u000d\u000afrom the running total. If the transaction is a payment, the AMT is changed to a neg\u2010\u000d\u000aative value, thus reducing the amount of the running total. The result of the CASE\u000d\u000aexpression is shown here:\u000d\u000aselect case when trx = 'PY'\u000d\u000a then 'PAYMENT'\u000d\u000a else 'PURCHASE'\u000d\u000a end trx_type,\u000d\u000a case when trx = 'PY'\u000d\u000a then -amt else amt\u000d\u000a end as amt\u000d\u000a from V\u000d\u000aTRX_TYPE AMT\u000d\u000a-------- ---------\u000d\u000aPURCHASE 100\u000d\u000aPURCHASE 100\u000d\u000aPAYMENT -50\u000d\u000aPURCHASE 100\u000d\u000aPAYMENT -200\u000d\u000aPAYMENT -50\u000d\u000aAfter evaluating the transaction type, the values for AMT are then added to or sub\u2010\u000d\u000atracted from the running total. For an explanation on how the window function,\u000d\u000aSUM OVER, or the scalar subquery creates the running total, see recipe Recipe 7.6.\u000d\u000a7.16 Finding Outliers Using the Median Absolute\u000d\u000aDeviation\u000d\u000aProblem\u000d\u000aYou want to identify values in your data that may be suspect. There are various rea\u2010\u000d\u000asons why values could be suspect\u2014there could be a data collection issue, such as an\u000d\u000aerror with the meter that records the value. There could be a data entry error such as\u000d\u000a7.16 Finding Outliers Using the Median Absolute Deviation | 197","a typo or similar. There could also be unusual circumstances when the data was gen\u2010\u000d\u000aerated that mean the data point is correct, but they still require you to use caution in\u000d\u000aany conclusion you make from the data. Therefore, you want to detect outliers.\u000d\u000aA common way to detect outliers, taught in many statistics courses aimed at nonstatisticians, is to calculate the standard deviation of the data and decide that data\u000d\u000apoints more than three standard deviations (or some other similar distance) are outli\u2010\u000d\u000aers. However, this method can misidentify outliers if the data don\u2019t follow a normal\u000d\u000adistribution, especially if the spread of data isn\u2019t symmetrical or doesn\u2019t thin out in\u000d\u000athe same way as a normal distribution as you move further from the mean.\u000d\u000aSolution\u000d\u000aFirst find the median of the values using the recipe for finding the median from ear\u2010\u000d\u000alier in this chapter. You will need to put this query into a CTE to make it available for\u000d\u000afurther querying. The deviation is the absolute difference between the median and\u000d\u000aeach value; the median absolute deviation is the median of this value, so we need to\u000d\u000acalculate the median again.\u000d\u000aSQL Server\u000d\u000aSQL Server has the PERCENTILE_CONT function, which simplifies finding the\u000d\u000amedian. As we need to find two different medians and manipulate them, we need a\u000d\u000aseries of CTEs:\u000d\u000awith median (median)\u000d\u000aas\u000d\u000a(select distinct percentile_cont(0.5) within group(order by sal)\u000d\u000a over()\u000d\u000afrom emp),\u000d\u000aDeviation (Deviation)\u000d\u000a as\u000d\u000a(Select abs(sal-median)\u000d\u000afrom emp join median on 1=1),\u000d\u000aMAD (MAD) as\u000d\u000a(select DISTINCT PERCENTILE_CONT(0.5) within group(order by deviation) over()\u000d\u000afrom Deviation )\u000d\u000aselect abs(sal-MAD)/MAD, sal, ename, job\u000d\u000afrom MAD join emp on 1=1\u000d\u000aPostgreSQL and DB2\u000d\u000aThe overall pattern is the same, but there is different syntax for PERCEN\u2010\u000d\u000aTILE_CONT, as PostgreSQL and DB2 treat PERCENTILE_CONT as an aggregate\u000d\u000afunction rather than strictly a window function:\u000d\u000a198 | Chapter 7: Working with Numbers","with median (median)\u000d\u000aas\u000d\u000a(select percentile_cont(0.5) within group(order by sal)\u000d\u000afrom emp),\u000d\u000adevtab (deviation)\u000d\u000a as\u000d\u000a(select abs(sal-median)\u000d\u000afrom emp join median),\u000d\u000aMedAbsDeviation (MAD) as\u000d\u000a(select percentile_cont (0.5) within group(order by deviation)\u000d\u000afrom devtab)\u000d\u000aselect abs(sal-MAD)/MAD, sal, ename, job\u000d\u000aFROM MedAbsDeviation join emp\u000d\u000aOracle\u000d\u000aThe recipe is simplified for Oracle users due to the existence of a median function.\u000d\u000aHowever, we still need to use a CTE to handle the scalar value of deviation:\u000d\u000awith\u000d\u000aDeviation (Deviation)\u000d\u000a as\u000d\u000a(select abs(sal-median(sal))\u000d\u000afrom emp),\u000d\u000aMAD (MAD) as\u000d\u000a(select median(Deviation)\u000d\u000afrom Deviation )\u000d\u000aselect abs(sal-MAD)/MAD, sal, ename, job\u000d\u000aFROM MAD join emp\u000d\u000aMySQL\u000d\u000aAs we saw in the earlier section on the median, there is unfortunately no MEDIAN or\u000d\u000aPERCENTILE_CONT function in MySQL. This means that each of the medians we\u000d\u000aneed to find to compute the median absolute deviation is two subqueries within a\u000d\u000aCTE. This makes the MySQL a little long-winded:\u000d\u000awith rank_tab (sal, rank_sal) as (\u000d\u000aselect sal, cume_dist() over (order by sal)\u000d\u000afrom emp),\u000d\u000ainter as\u000d\u000a(\u000d\u000aselect sal, rank_sal from rank_tab\u000d\u000awhere rank_sal>=0.5\u000d\u000aunion\u000d\u000aselect sal, rank_sal from rank_tab\u000d\u000awhere rank_sal<=0.5\u000d\u000a7.16 Finding Outliers Using the Median Absolute Deviation | 199",")\u000d\u000a,\u000d\u000amedianSal (medianSal) as\u000d\u000a(\u000d\u000aselect (max(sal)+min(sal))/2\u000d\u000afrom inter),\u000d\u000adeviationSal (Sal,deviationSal) as\u000d\u000a(select Sal,abs(sal-medianSal)\u000d\u000afrom emp join medianSal\u000d\u000aon 1=1\u000d\u000a)\u000d\u000a,\u000d\u000adistDevSal (sal,deviationSal,distDeviationSal) as\u000d\u000a(\u000d\u000aselect sal,deviationSal,cume_dist() over (order by deviationSal)\u000d\u000afrom deviationSal\u000d\u000a),\u000d\u000aDevInter (DevInter, sal) as\u000d\u000a(\u000d\u000aselect min(deviationSal), sal\u000d\u000afrom distDevSal\u000d\u000awhere distDeviationSal >= 0.5\u000d\u000aunion\u000d\u000aselect max(DeviationSal), sal\u000d\u000afrom distDevSal\u000d\u000awhere distDeviationSal <= 0.5\u000d\u000a),\u000d\u000aMAD (MedianAbsoluteDeviance) as\u000d\u000a(\u000d\u000aselect abs(emp.sal-(min(devInter)+max(devInter))/2)\u000d\u000afrom emp join DevInter on 1=1\u000d\u000a)\u000d\u000aselect emp.sal,MedianAbsoluteDeviance,\u000d\u000a(emp.sal-deviationSal)/MedianAbsoluteDeviance\u000d\u000afrom (emp join MAD on 1=1)\u000d\u000a join deviationSal on emp.sal=deviationSal.sal\u000d\u000aDiscussion\u000d\u000aIn each case the recipe follows a similar strategy. First we need to calculate the\u000d\u000amedian, and then we need to calculate the median of the difference between each\u000d\u000avalue and the median, which is the actual median absolute deviation. Finally, we need\u000d\u000a200 | Chapter 7: Working with Numbers","to use a query to find the ratio of the deviation of each value to the median deviation.\u000d\u000aAt that point, we can use the outcome in a similar way to the standard deviation. For\u000d\u000aexample, if a value is three or more deviations from the median, it can be considered\u000d\u000aan outlier, to use a common interpretation.\u000d\u000aAs mentioned earlier, the benefit of this approach over the standard deviation is that\u000d\u000athe interpretation is still valid even if the data doesn\u2019t display a normal distribution.\u000d\u000aFor example, it can be lopsided, and the median absolute deviation will still give a\u000d\u000asound answer.\u000d\u000aIn our salary data, there is one salary that is more than three absolute deviations from\u000d\u000athe median: the CEO\u2019s.\u000d\u000aAlthough there are differing opinions about the fairness of CEO salaries versus those\u000d\u000aof most other workers, given that the outlier salary belongs to the CEO, it fits with\u000d\u000aour understanding of the data. In other contexts, if there wasn\u2019t a clear explanation of\u000d\u000awhy the value differed so much, it could lead us to question whether that value was\u000d\u000acorrect or whether the value made sense when taken with the rest of the values (e.g.,\u000d\u000aif it not actually an error, it might make us think we need to analyze our data within\u000d\u000amore than one subgroup).\u000d\u000aMany of the common statistics, such as the mean and the standard\u000d\u000adeviation, assume that the shape of the data is a bell curve\u2014a nor\u2010\u000d\u000amal distribution. This is true for many data sets, and also not true\u000d\u000afor many data sets.\u000d\u000aThere are a number of methods for testing whether a data set fol\u2010\u000d\u000alows a normal distribution, both by visualizing the data and\u000d\u000athrough calculations. Statistical packages commonly contain func\u2010\u000d\u000ations for these tests, but they are nonexistent and hard to replicate\u000d\u000ain SQL. However, there are often alternative statistical tools that\u000d\u000adon\u2019t assume the data takes a particular form\u2014nonparametric sta\u2010\u000d\u000atistics\u2014and these are safer to use.\u000d\u000a7.17 Finding Anomalies Using Benford\u2019s Law\u000d\u000aProblem\u000d\u000aAlthough outliers, as shown in the previous recipe, are a readily identifiable form of\u000d\u000aanomalous data, some other data is less easy to identify as problematic. One way to\u000d\u000adetect situations where there are anomalous data but no obvious outliers is to look at\u000d\u000athe frequency of digits, which is usually expected to follow Benford\u2019s law. Although\u000d\u000ausing Benford\u2019s law is most often associated with detecting fraud in situations where\u000d\u000ahumans have added fake numbers to a data set, it can be used more generally to\u000d\u000a7.17 Finding Anomalies Using Benford\u2019s Law | 201","detect data that doesn\u2019t follow expected patterns. For example, it can detect errors\u000d\u000asuch as duplicated data points, which won\u2019t necessarily stand out as outliers.\u000d\u000aSolution\u000d\u000aTo use Benford\u2019s law, you need to calculate the expected distribution of digits and\u000d\u000athen the actual distribution to compare. Although the most sophisticated uses look at\u000d\u000afirst, second, and combinations of digits, in this example we will stick to just the first\u000d\u000adigits.\u000d\u000aYou compare the frequency predicted by Benford\u2019s law with the actual frequency of\u000d\u000ayour data. Ultimately you want four columns\u2014the first digit, the count of how many\u000d\u000atimes each first digit appears, the frequency of first digits predicted by Benford\u2019s law,\u000d\u000aand the actual frequency:\u000d\u000awith\u000d\u000aFirstDigits (FirstDigit)\u000d\u000aas\u000d\u000a(select left(cast(SAL as CHAR),1) as FirstDigit\u000d\u000a from emp),\u000d\u000aTotalCount (Total)\u000d\u000aas\u000d\u000a(select count(*)\u000d\u000a from emp),\u000d\u000aExpectedBenford (Digit,Expected)\u000d\u000aas\u000d\u000a (select value,(log10(value + 1) - log10(value)) as expected\u000d\u000a from t10\u000d\u000a where value < 10)\u000d\u000aselect count(FirstDigit),Digit\u000d\u000a,coalesce(count(*)/Total,0) as ActualProportion,Expected\u000d\u000aFrom FirstDigits\u000d\u000a Join TotalCount\u000d\u000a Right Join ExpectedBenford\u000d\u000a on FirstDigits.FirstDigit=ExpectedBenford.Digit\u000d\u000agroup by Digit\u000d\u000aorder by Digit;\u000d\u000aDiscussion\u000d\u000aBecause we need to make use of two different counts\u2014one of the total rows, and\u000d\u000aanother of the number of rows containing each different first digit\u2014we need to use a\u000d\u000aCTE. Strictly speaking, we don\u2019t need to put the expected Benford\u2019s law results into a\u000d\u000aseparate query within the CTE, but we have done so in this case as it allows us to\u000d\u000aidentify the digits with a zero count and display them in the table via the right join.\u000d\u000a202 | Chapter 7: Working with Numbers","It\u2019s also possible to produce the FirstDigits count in the main query, but we have\u000d\u000achosen not to improve readability through not needing to repeat the LEFT(CAST\u2026\u000d\u000aexpression in the GROUP BY clause.\u000d\u000aThe math behind Benford\u2019s law is simple:\u000d\u000aExpected frequency = log10\u000d\u000ad + 1\u000d\u000ad\u000d\u000aWe can use the T10 pivot table to generate the appropriate values. From there we just\u000d\u000aneed to calculate the actual frequencies for comparison, which first requires us to\u000d\u000aidentify the first digit.\u000d\u000aBenford\u2019s law works best when there is a relatively large collection of values to apply it\u000d\u000ato, and when those values span more than one order of magnitude (10, 100, 1,000,\u000d\u000aetc.). Those conditions aren\u2019t entirely met here. At the same time, the deviation from\u000d\u000aexpected should still make us suspicious that these values are in some sense made-up\u000d\u000avalues and worth investigating further.\u000d\u000a7.18 Summing Up\u000d\u000aAn enterprise\u2019s data is frequently found in a database supported by SQL, so it makes\u000d\u000asense to use SQL to try to understand that data. SQL doesn\u2019t have the full array of\u000d\u000astatistical tools you would expect in a purpose-built package such as SAS, the statisti\u2010\u000d\u000acal programming language R, or Python\u2019s statistical libraries. However, it does have a\u000d\u000arich set of tools for calculation that as we have seen can provide a deep understanding\u000d\u000aof the statistical properties of your data.\u000d\u000a7.18 Summing Up | 203","","CHAPTER 8\u000d\u000aDate Arithmetic\u000d\u000aThis chapter introduces techniques for performing simple date arithmetic. Recipes\u000d\u000acover common tasks such as adding days to dates, finding the number of business\u000d\u000adays between dates, and finding the difference between dates in days.\u000d\u000aBeing able to successfully manipulate dates with your RDBMS\u2019s built-in functions can\u000d\u000agreatly improve your productivity. For all the recipes in this chapter, we try to take\u000d\u000aadvantage of each RDBMS\u2019s built-in functions. In addition, we have chosen to use\u000d\u000aone date format for all the recipes, DD-MON-YYYY. Of course, there are a number\u000d\u000aof other commonly used formats, such as DD-MM-YYYY, the ISO standard format.\u000d\u000aWe chose to standardize on DD-MON-YYYY to benefit those of you who work with\u000d\u000aone RDBMS and want to learn others. Seeing one standard format will help you focus\u000d\u000aon the different techniques and functions provided by each RDBMS without having\u000d\u000ato worry about default date formats.\u000d\u000aThis chapter focuses on basic date arithmetic. You\u2019ll find more\u000d\u000aadvanced date recipes in the following chapter. The recipes presen\u2010\u000d\u000ated in this chapter use simple date data types. If you are using more\u000d\u000acomplex date data types, you will need to adjust the solutions\u000d\u000aaccordingly.\u000d\u000a8.1 Adding and Subtracting Days, Months, and Years\u000d\u000aProblem\u000d\u000aYou need to add or subtract some number of days, months, or years from a date. For\u000d\u000aexample, using the HIREDATE for employee CLARK, you want to return six differ\u2010\u000d\u000aent dates: five days before and after CLARK was hired, five months before and after\u000d\u000a205","CLARK was hired, and, finally, five years before and after CLARK was hired. CLARK\u000d\u000awas hired on 09-JUN-2006, so you want to return the following result set:\u000d\u000aHD_MINUS_5D HD_PLUS_5D HD_MINUS_5M HD_PLUS_5M HD_MINUS_5Y HD_PLUS_5Y\u000d\u000a----------- ----------- ----------- ----------- ----------- -----------\u000d\u000a04-JUN-2006 14-JUN-2006 09-JAN-2006 09-NOV-2006 09-JUN-2001 09-JUN-2001\u000d\u000a12-NOV-2006 22-NOV-2006 17-JUN-2006 17-APR-2007 17-NOV-2001 17-NOV-2001\u000d\u000a18-JAN-2007 28-JAN-2007 23-AUG-2006 23-JUN-2007 23-JAN-2002 23-JAN-2002\u000d\u000aSolution\u000d\u000aDB2\u000d\u000aStandard addition and subtraction is allowed on date values, but any value that you\u000d\u000aadd to or subtract from a date must be followed by the unit of time it represents:\u000d\u000a1 select hiredate -5 day as hd_minus_5D,\u000d\u000a2 hiredate +5 day as hd_plus_5D,\u000d\u000a3 hiredate -5 month as hd_minus_5M,\u000d\u000a4 hiredate +5 month as hd_plus_5M,\u000d\u000a5 hiredate -5 year as hd_minus_5Y,\u000d\u000a6 hiredate +5 year as hd_plus_5Y\u000d\u000a7 from emp\u000d\u000a8 where deptno = 10\u000d\u000aOracle\u000d\u000aUse standard addition and subtraction for days, and use the ADD_MONTHS func\u2010\u000d\u000ation to add and subtract months and years:\u000d\u000a1 select hiredate-5 as hd_minus_5D,\u000d\u000a2 hiredate+5 as hd_plus_5D,\u000d\u000a3 add_months(hiredate,-5) as hd_minus_5M,\u000d\u000a4 add_months(hiredate,5) as hd_plus_5M,\u000d\u000a5 add_months(hiredate,-5*12) as hd_minus_5Y,\u000d\u000a6 add_months(hiredate,5*12) as hd_plus_5Y\u000d\u000a7 from emp\u000d\u000a8 where deptno = 10\u000d\u000aPostgreSQL\u000d\u000aUse standard addition and subtraction with the INTERVAL keyword specifying the\u000d\u000aunit of time to add or subtract. Single quotes are required when specifying an\u000d\u000aINTERVAL value:\u000d\u000a1 select hiredate - interval '5 day' as hd_minus_5D,\u000d\u000a2 hiredate + interval '5 day' as hd_plus_5D,\u000d\u000a3 hiredate - interval '5 month' as hd_minus_5M,\u000d\u000a4 hiredate + interval '5 month' as hd_plus_5M,\u000d\u000a5 hiredate - interval '5 year' as hd_minus_5Y,\u000d\u000a6 hiredate + interval '5 year' as hd_plus_5Y\u000d\u000a206 | Chapter 8: Date Arithmetic","7 from emp\u000d\u000a8 where deptno=10\u000d\u000aMySQL\u000d\u000aUse standard addition and subtraction with the INTERVAL keyword specifying the\u000d\u000aunit of time to add or subtract. Unlike the PostgreSQL solution, you do not place sin\u2010\u000d\u000agle quotes around the INTERVAL value:\u000d\u000a1 select hiredate - interval 5 day as hd_minus_5D,\u000d\u000a2 hiredate + interval 5 day as hd_plus_5D,\u000d\u000a3 hiredate - interval 5 month as hd_minus_5M,\u000d\u000a4 hiredate + interval 5 month as hd_plus_5M,\u000d\u000a5 hiredate - interval 5 year as hd_minus_5Y,\u000d\u000a6 hiredate + interval 5 year as hd_plus_5Y\u000d\u000a7 from emp\u000d\u000a8 where deptno=10\u000d\u000aAlternatively, you can use the DATE_ADD function, which is shown here:\u000d\u000a1 select date_add(hiredate,interval -5 day) as hd_minus_5D,\u000d\u000a2 date_add(hiredate,interval 5 day) as hd_plus_5D,\u000d\u000a3 date_add(hiredate,interval -5 month) as hd_minus_5M,\u000d\u000a4 date_add(hiredate,interval 5 month) as hd_plus_5M,\u000d\u000a5 date_add(hiredate,interval -5 year) as hd_minus_5Y,\u000d\u000a6 date_add(hiredate,interval 5 year) as hd_plus_5DY\u000d\u000a7 from emp\u000d\u000a8 where deptno=10\u000d\u000aSQL Server\u000d\u000aUse the DATEADD function to add or subtract different units of time to/from a date:\u000d\u000a1 select dateadd(day,-5,hiredate) as hd_minus_5D,\u000d\u000a2 dateadd(day,5,hiredate) as hd_plus_5D,\u000d\u000a3 dateadd(month,-5,hiredate) as hd_minus_5M,\u000d\u000a4 dateadd(month,5,hiredate) as hd_plus_5M,\u000d\u000a5 dateadd(year,-5,hiredate) as hd_minus_5Y,\u000d\u000a6 dateadd(year,5,hiredate) as hd_plus_5Y\u000d\u000a7 from emp\u000d\u000a8 where deptno = 10\u000d\u000aDiscussion\u000d\u000aThe Oracle solution takes advantage of the fact that integer values represent days\u000d\u000awhen performing date arithmetic. However, that\u2019s true only of arithmetic with DATE\u000d\u000atypes. Oracle also has TIMESTAMP types. For those, you should use the INTERVAL\u000d\u000asolution shown for PostgreSQL. Beware too, of passing TIMESTAMPs to old-style\u000d\u000adate functions such as ADD_MONTHS. By doing so, you can lose any fractional sec\u2010\u000d\u000aonds that such TIMESTAMP values may contain.\u000d\u000a8.1 Adding and Subtracting Days, Months, and Years | 207","The INTERVAL keyword and the string literals that go with it represent ISOstandard SQL syntax. The standard requires that interval values be enclosed within\u000d\u000asingle quotes. PostgreSQL (and Oracle9i Database and later) complies with the stan\u2010\u000d\u000adard. MySQL deviates somewhat by omitting support for the quotes.\u000d\u000a8.2 Determining the Number of Days Between Two Dates\u000d\u000aProblem\u000d\u000aYou want to find the difference between two dates and represent the result in days.\u000d\u000aFor example, you want to find the difference in days between the HIREDATEs of\u000d\u000aemployee ALLEN and employee WARD.\u000d\u000aSolution\u000d\u000aDB2\u000d\u000aUse two inline views to find the HIREDATEs for WARD and ALLEN. Then subtract\u000d\u000aone HIREDATE from the other using the DAYS function:\u000d\u000a 1 select days(ward_hd) - days(allen_hd)\u000d\u000a 2 from (\u000d\u000a 3 select hiredate as ward_hd\u000d\u000a 4 from emp\u000d\u000a 5 where ename = 'WARD'\u000d\u000a 6 ) x,\u000d\u000a 7 (\u000d\u000a 8 select hiredate as allen_hd\u000d\u000a 9 from emp\u000d\u000a10 where ename = 'ALLEN'\u000d\u000a11 ) y\u000d\u000aOracle and PostgreSQL\u000d\u000aUse two inline views to find the HIREDATEs for WARD and ALLEN, and then sub\u2010\u000d\u000atract one date from the other:\u000d\u000a 1 select ward_hd - allen_hd\u000d\u000a 2 from (\u000d\u000a 3 select hiredate as ward_hd\u000d\u000a 4 from emp\u000d\u000a 5 where ename = 'WARD'\u000d\u000a 6 ) x,\u000d\u000a 7 (\u000d\u000a 8 select hiredate as allen_hd\u000d\u000a 9 from emp\u000d\u000a10 where ename = 'ALLEN'\u000d\u000a11 ) y\u000d\u000a208 | Chapter 8: Date Arithmetic","MySQL and SQL Server\u000d\u000aUse the function DATEDIFF to find the number of days between two dates. MySQL\u2019s\u000d\u000aversion of DATEDIFF requires only two parameters (the two dates you want to find\u000d\u000athe difference in days between), and the smaller of the two dates should be passed\u000d\u000afirst to avoid negative values (opposite in SQL Server). SQL Server\u2019s version of the\u000d\u000afunction allows you to specify what you want the return value to represent (in this\u000d\u000aexample you want to return the difference in days). The solution following uses the\u000d\u000aSQL Server version:\u000d\u000a 1 select datediff(day,allen_hd,ward_hd)\u000d\u000a 2 from (\u000d\u000a 3 select hiredate as ward_hd\u000d\u000a 4 from emp\u000d\u000a 5 where ename = 'WARD'\u000d\u000a 6 ) x,\u000d\u000a 7 (\u000d\u000a 8 select hiredate as allen_hd\u000d\u000a 9 from emp\u000d\u000a10 where ename = 'ALLEN'\u000d\u000a11 ) y\u000d\u000aMySQL users can simply remove the first argument of the function and flip-flop the\u000d\u000aorder in which ALLEN_HD and WARD_HD is passed.\u000d\u000aDiscussion\u000d\u000aFor all solutions, inline views X and Y return the HIREDATEs for employees WARD\u000d\u000aand ALLEN, respectively. For example:\u000d\u000aselect ward_hd, allen_hd\u000d\u000a from (\u000d\u000aselect hiredate as ward_hd\u000d\u000a from emp\u000d\u000a where ename = 'WARD'\u000d\u000a ) y,\u000d\u000a (\u000d\u000aselect hiredate as allen_hd\u000d\u000a from emp\u000d\u000a where ename = 'ALLEN'\u000d\u000a ) x\u000d\u000aWARD_HD ALLEN_HD\u000d\u000a----------- ----------\u000d\u000a22-FEB-2006 20-FEB-2006\u000d\u000aYou\u2019ll notice a Cartesian product is created, because there is no join specified between\u000d\u000aX and Y. In this case, the lack of a join is harmless as the cardinalities for X and Y are\u000d\u000aboth 1; thus, the result set will ultimately have one row (obviously, because 1 \u00d7 1 = 1).\u000d\u000a8.2 Determining the Number of Days Between Two Dates | 209","To get the difference in days, simply subtract one of the two values returned from the\u000d\u000aother using methods appropriate for your database.\u000d\u000a8.3 Determining the Number of Business Days Between\u000d\u000aTwo Dates\u000d\u000aProblem\u000d\u000aGiven two dates, you want to find how many \u201cworking\u201d days are between them,\u000d\u000aincluding the two dates themselves. For example, if January 10th is a Tuesday and\u000d\u000aJanuary 11th is a Monday, then the number of working days between these two dates\u000d\u000ais two, as both days are typical workdays. For this recipe, a \u201cbusiness day\u201d is defined\u000d\u000aas any day that is not Saturday or Sunday.\u000d\u000aSolution\u000d\u000aThe solution examples find the number of business days between the HIREDATEs of\u000d\u000aBLAKE and JONES. To determine the number of business days between two dates,\u000d\u000ayou can use a pivot table to return a row for each day between the two dates (includ\u2010\u000d\u000aing the start and end dates). Having done that, finding the number of business days is\u000d\u000asimply counting the dates returned that are not Saturday or Sunday.\u000d\u000aIf you want to exclude holidays as well, you can create a HOLI\u2010\u000d\u000aDAYS table. Then include a simple NOT IN predicate to exclude\u000d\u000adays listed in HOLIDAYS from the solution.\u000d\u000aDB2\u000d\u000aUse the pivot table T500 to generate the required number of rows (representing days)\u000d\u000abetween the two dates. Then count each day that is not a weekend. Use the DAY\u2010\u000d\u000aNAME function to return the weekday name of each date. For example:\u000d\u000a 1 select sum(case when dayname(jones_hd+t500.id day -1 day)\u000d\u000a 2 in ( 'Saturday','Sunday' )\u000d\u000a 3 then 0 else 1\u000d\u000a 4 end) as days\u000d\u000a 5 from (\u000d\u000a 6 select max(case when ename = 'BLAKE'\u000d\u000a 7 then hiredate\u000d\u000a 8 end) as blake_hd,\u000d\u000a 9 max(case when ename = 'JONES'\u000d\u000a10 then hiredate\u000d\u000a11 end) as jones_hd\u000d\u000a12 from emp\u000d\u000a210 | Chapter 8: Date Arithmetic","13 where ename in ( 'BLAKE','JONES' )\u000d\u000a14 ) x,\u000d\u000a15 t500\u000d\u000a16 where t500.id <= blake_hd-jones_hd+1\u000d\u000aMySQL\u000d\u000aUse the pivot table T500 to generate the required number of rows (days) between the\u000d\u000atwo dates. Then count each day that is not a weekend. Use the DATE_ADD function\u000d\u000ato add days to each date. Use the DATE_FORMAT function to obtain the weekday\u000d\u000aname of each date:\u000d\u000a 1 select sum(case when date_format(\u000d\u000a 2 date_add(jones_hd,\u000d\u000a 3 interval t500.id-1 DAY),'%a')\u000d\u000a 4 in ( 'Sat','Sun' )\u000d\u000a 5 then 0 else 1\u000d\u000a 6 end) as days\u000d\u000a 7 from (\u000d\u000a 8 select max(case when ename = 'BLAKE'\u000d\u000a 9 then hiredate\u000d\u000a10 end) as blake_hd,\u000d\u000a11 max(case when ename = 'JONES'\u000d\u000a12 then hiredate\u000d\u000a13 end) as jones_hd\u000d\u000a14 from emp\u000d\u000a15 where ename in ( 'BLAKE','JONES' )\u000d\u000a16 ) x,\u000d\u000a17 t500\u000d\u000a18 where t500.id <= datediff(blake_hd,jones_hd)+1\u000d\u000aOracle\u000d\u000aUse the pivot table T500 to generate the required number of rows (days) between the\u000d\u000atwo dates, and then count each day that is not a weekend. Use the TO_CHAR func\u2010\u000d\u000ation to obtain the weekday name of each date:\u000d\u000a 1 select sum(case when to_char(jones_hd+t500.id-1,'DY')\u000d\u000a 2 in ( 'SAT','SUN' )\u000d\u000a 3 then 0 else 1\u000d\u000a 4 end) as days\u000d\u000a 5 from (\u000d\u000a 6 select max(case when ename = 'BLAKE'\u000d\u000a 7 then hiredate\u000d\u000a 8 end) as blake_hd,\u000d\u000a 9 max(case when ename = 'JONES'\u000d\u000a10 then hiredate\u000d\u000a11 end) as jones_hd\u000d\u000a12 from emp\u000d\u000a13 where ename in ( 'BLAKE','JONES' )\u000d\u000a14 ) x,\u000d\u000a8.3 Determining the Number of Business Days Between Two Dates | 211","15 t500\u000d\u000a16 where t500.id <= blake_hd-jones_hd+1\u000d\u000aPostgreSQL\u000d\u000aUse the pivot table T500 to generate the required number of rows (days) between the\u000d\u000atwo dates. Then count each day that is not a weekend. Use the TO_CHAR function to\u000d\u000aobtain the weekday name of each date:\u000d\u000a 1 select sum(case when trim(to_char(jones_hd+t500.id-1,'DAY'))\u000d\u000a 2 in ( 'SATURDAY','SUNDAY' )\u000d\u000a 3 then 0 else 1\u000d\u000a 4 end) as days\u000d\u000a 5 from (\u000d\u000a 6 select max(case when ename = 'BLAKE'\u000d\u000a 7 then hiredate\u000d\u000a 8 end) as blake_hd,\u000d\u000a 9 max(case when ename = 'JONES'\u000d\u000a10 then hiredate\u000d\u000a11 end) as jones_hd\u000d\u000a12 from emp\u000d\u000a13 where ename in ( 'BLAKE','JONES' )\u000d\u000a14 ) x,\u000d\u000a15 t500\u000d\u000a16 where t500.id <= blake_hd-jones_hd+1\u000d\u000aSQL Server\u000d\u000aUse the pivot table T500 to generate the required number of rows (days) between the\u000d\u000atwo dates, and then count each day that is not a weekend. Use the DATENAME func\u2010\u000d\u000ation to obtain the weekday name of each date:\u000d\u000a 1 select sum(case when datename(dw,jones_hd+t500.id-1)\u000d\u000a 2 in ( 'SATURDAY','SUNDAY' )\u000d\u000a 3 then 0 else 1\u000d\u000a 4 end) as days\u000d\u000a 5 from (\u000d\u000a 6 selectmax(case when ename = 'BLAKE'\u000d\u000a 7 then hiredate\u000d\u000a 8 end) as blake_hd,\u000d\u000a 9 max(case when ename = 'JONES'\u000d\u000a10 then hiredate\u000d\u000a11 end) as jones_hd\u000d\u000a12 from emp\u000d\u000a13 where ename in ( 'BLAKE','JONES' )\u000d\u000a14 ) x,\u000d\u000a15 t500\u000d\u000a16 where t500.id <= datediff(day,jones_hd-blake_hd)+1\u000d\u000a212 | Chapter 8: Date Arithmetic","Discussion\u000d\u000aWhile each RDBMS requires the use of different built-in functions to determine the\u000d\u000aname of a day, the overall solution approach is the same for each. The solution can be\u000d\u000abroken into two steps:\u000d\u000a1. Return the days between the start date and end date (inclusive).\u000d\u000a2. Count how many days (i.e., rows) there are, excluding weekends.\u000d\u000aInline view X performs step one. If you examine inline view X, you\u2019ll notice the use of\u000d\u000athe aggregate function MAX, which the recipe uses to remove NULLs. If the use of\u000d\u000aMAX is unclear, the following output might help you understand. The output shows\u000d\u000athe results from inline view X without MAX:\u000d\u000aselect case when ename = 'BLAKE'\u000d\u000a then hiredate\u000d\u000a end as blake_hd,\u000d\u000a case when ename = 'JONES'\u000d\u000a then hiredate\u000d\u000a end as jones_hd\u000d\u000a from emp\u000d\u000a where ename in ( 'BLAKE','JONES' )\u000d\u000aBLAKE_HD JONES_HD\u000d\u000a----------- -----------\u000d\u000a 02-APR-2006\u000d\u000a01-MAY-2006\u000d\u000aWithout MAX, two rows are returned. By using MAX you return only one row\u000d\u000ainstead of two, and the NULLs are eliminated:\u000d\u000aselect max(case when ename = 'BLAKE'\u000d\u000a then hiredate\u000d\u000a end) as blake_hd,\u000d\u000a max(case when ename = 'JONES'\u000d\u000a then hiredate\u000d\u000a end) as jones_hd\u000d\u000a from emp\u000d\u000a where ename in ( 'BLAKE','JONES' )\u000d\u000aBLAKE_HD JONES_HD\u000d\u000a----------- -----------\u000d\u000a01-MAY-2006 02-APR-2006\u000d\u000aThe number of days (inclusive) between the two dates here is 30. Now that the two\u000d\u000adates are in one row, the next step is to generate one row for each of those 30 days. To\u000d\u000areturn the 30 days (rows), use table T500. Since each value for ID in table T500 is\u000d\u000asimply one greater than the one before it, add each row returned by T500 to the ear\u2010\u000d\u000alier of the two dates (JONES_HD) to generate consecutive days starting from\u000d\u000a8.3 Determining the Number of Business Days Between Two Dates | 213","JONES_HD up to and including BLAKE_HD. The result of this addition is shown\u000d\u000ahere (using Oracle syntax):\u000d\u000aselect x.*, t500.*, jones_hd+t500.id-1\u000d\u000a from (\u000d\u000aselect max(case when ename = 'BLAKE'\u000d\u000a then hiredate\u000d\u000a end) as blake_hd,\u000d\u000a max(case when ename = 'JONES'\u000d\u000a then hiredate\u000d\u000a end) as jones_hd\u000d\u000a from emp\u000d\u000a where ename in ( 'BLAKE','JONES' )\u000d\u000a ) x,\u000d\u000a t500\u000d\u000a where t500.id <= blake_hd-jones_hd+1\u000d\u000aBLAKE_HD JONES_HD ID JONES_HD+T5\u000d\u000a----------- ----------- ---------- -----------\u000d\u000a01-MAY-2006 02-APR-2006 1 02-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 2 03-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 3 04-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 4 05-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 5 06-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 6 07-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 7 08-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 8 09-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 9 10-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 10 11-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 11 12-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 12 13-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 13 14-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 14 15-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 15 16-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 16 17-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 17 18-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 18 19-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 19 20-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 20 21-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 21 22-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 22 23-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 23 24-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 24 25-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 25 26-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 26 27-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 27 28-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 28 29-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 29 30-APR-2006\u000d\u000a01-MAY-2006 02-APR-2006 30 01-MAY-2006\u000d\u000a214 | Chapter 8: Date Arithmetic","If you examine the WHERE clause, you\u2019ll notice that you add 1 to the difference\u000d\u000abetween BLAKE_HD and JONES_HD to generate the required 30 rows (otherwise,\u000d\u000ayou would get 29 rows). You\u2019ll also notice that you subtract 1 from T500.ID in the\u000d\u000aSELECT list of the outer query, since the values for ID start at 1 and adding 1 to\u000d\u000aJONES_HD would cause JONES_HD to be excluded from the final count.\u000d\u000aOnce you generate the number of rows required for the result set, use a CASE expres\u2010\u000d\u000asion to \u201cflag\u201d whether each of the days returned is weekday or weekend (return a 1 for\u000d\u000aa weekday and a 0 for a weekend). The final step is to use the aggregate function SUM\u000d\u000ato tally up the number of 1s to get the final answer.\u000d\u000a8.4 Determining the Number of Months or Years Between\u000d\u000aTwo Dates\u000d\u000aProblem\u000d\u000aYou want to find the difference between two dates in terms of either months or years.\u000d\u000aFor example, you want to find the number of months between the first and last\u000d\u000aemployees hired, and you also want to express that value as some number of years.\u000d\u000aSolution\u000d\u000aSince there are always 12 months in a year, you can find the number of months\u000d\u000abetween 2 dates and then divide by 12 to get the number of years. After getting com\u2010\u000d\u000afortable with the solution, you\u2019ll want to round the results up or down depending on\u000d\u000awhat you want for the year. For example, the first HIREDATE in table EMP is 17-\u000d\u000aDEC-1980 and the last is 12-JAN-1983. If you do the math on the years (1983 minus\u000d\u000a1980), you get 3 years, yet the difference in months is approximately 25 (a little over 2\u000d\u000ayears). You should tweak the solution as you see fit. The following solutions will\u000d\u000areturn 25 months and approximately 2 years.\u000d\u000aDB2 and MySQL\u000d\u000aUse the functions YEAR and MONTH to return the four-digit year and the two-digit\u000d\u000amonth for the dates supplied:\u000d\u000a1 select mnth, mnth/12\u000d\u000a2 from (\u000d\u000a3 select (year(max_hd) - year(min_hd))*12 +\u000d\u000a4 (month(max_hd) - month(min_hd)) as mnth\u000d\u000a5 from (\u000d\u000a6 select min(hiredate) as min_hd, max(hiredate) as max_hd\u000d\u000a7 from emp\u000d\u000a8 ) x\u000d\u000a9 ) y\u000d\u000a8.4 Determining the Number of Months or Years Between Two Dates | 215","Oracle\u000d\u000aUse the function MONTHS_BETWEEN to find the difference between two dates in\u000d\u000amonths (to get years, simply divide by 12):\u000d\u000a1 select months_between(max_hd,min_hd),\u000d\u000a2 months_between(max_hd,min_hd)/12\u000d\u000a3 from (\u000d\u000a4 select min(hiredate) min_hd, max(hiredate) max_hd\u000d\u000a5 from emp\u000d\u000a6 ) x\u000d\u000aPostgreSQL\u000d\u000aUse the function EXTRACT to return the four-digit year and two-digit month for the\u000d\u000adates supplied:\u000d\u000a 1 select mnth, mnth/12\u000d\u000a 2 from (\u000d\u000a 3 select ( extract(year from max_hd)\u000d\u000a 4 extract(year from min_hd) ) * 12\u000d\u000a 5 +\u000d\u000a 6 ( extract(month from max_hd)\u000d\u000a 7 extract(month from min_hd) ) as mnth\u000d\u000a 8 from (\u000d\u000a 9 select min(hiredate) as min_hd, max(hiredate) as max_hd\u000d\u000a10 from emp\u000d\u000a11 ) x\u000d\u000a12 ) y\u000d\u000aSQL Server\u000d\u000aUse the function DATEDIFF to find the difference between two dates, and use the\u000d\u000aDATEPART argument to specify months and years as the time units returned:\u000d\u000a 1 select datediff(month,min_hd,max_hd),\u000d\u000a 2 datediff(year,min_hd,max_hd)\u000d\u000a 3 from (\u000d\u000a 4 select min(hiredate) min_hd, max(hiredate) max_hd\u000d\u000a 5 from emp\u000d\u000a 6 ) x\u000d\u000aDiscussion\u000d\u000aDB2, MySQL, and PostgreSQL\u000d\u000aOnce you extract the year and month for MIN_HD and MAX_HD in the PostgreSQL\u000d\u000asolution, the method for finding the months and years between MIN_HD and\u000d\u000aMAX_HD is the same for all three RDBMs. This discussion will cover all three\u000d\u000asolutions.\u000d\u000a216 | Chapter 8: Date Arithmetic","Inline view X returns the earliest and latest HIREDATEs in table EMP and is shown\u000d\u000ahere:\u000d\u000aselect min(hiredate) as min_hd,\u000d\u000a max(hiredate) as max_hd\u000d\u000a from emp\u000d\u000aMIN_HD MAX_HD\u000d\u000a----------- -----------\u000d\u000a17-DEC-1980 12-JAN-1983\u000d\u000aTo find the months between MAX_HD and MIN_HD, multiply the difference in\u000d\u000ayears between MIN_HD and MAX_HD by 12, and then add the difference in months\u000d\u000abetween MAX_HD and MIN_HD. If you are having trouble seeing how this works,\u000d\u000areturn the date component for each date. The numeric values for the years and\u000d\u000amonths are shown here:\u000d\u000aselect year(max_hd) as max_yr, year(min_hd) as min_yr,\u000d\u000a month(max_hd) as max_mon, month(min_hd) as min_mon\u000d\u000a from (\u000d\u000aselect min(hiredate) as min_hd, max(hiredate) as max_hd\u000d\u000a from emp\u000d\u000a ) x\u000d\u000aMAX_YR MIN_YR MAX_MON MIN_MON\u000d\u000a------ ---------- ---------- ----------\u000d\u000a 1983 1980 1 12\u000d\u000aLooking at these results, finding the months between MAX_HD and MIN_HD is\u000d\u000asimply 1983 \u2212 1980 \u00d7 12 + 1 \u2212 12 . To find the number of years between MIN_HD\u000d\u000aand MAX_HD, divide the number of months by 12. Again, depending on the results\u000d\u000ayou are looking for, you will want to round the values.\u000d\u000aOracle and SQL Server\u000d\u000aInline view X returns the earliest and latest HIREDATEs in table EMP and is shown\u000d\u000ahere:\u000d\u000aselect min(hiredate) as min_hd, max(hiredate) as max_hd\u000d\u000a from emp\u000d\u000aMIN_HD MAX_HD\u000d\u000a----------- -----------\u000d\u000a17-DEC-1980 12-JAN-1983\u000d\u000aThe functions supplied by Oracle and SQL Server (MONTHS_BETWEEN and\u000d\u000aDATEDIFF, respectively) will return the number of months between two given dates.\u000d\u000aTo find the year, divide the number of months by 12.\u000d\u000a8.4 Determining the Number of Months or Years Between Two Dates | 217","8.5 Determining the Number of Seconds, Minutes, or\u000d\u000aHours Between Two Dates\u000d\u000aProblem\u000d\u000aYou want to return the difference in seconds between two dates. For example, you\u000d\u000awant to return the difference between the HIREDATEs of ALLEN and WARD in sec\u2010\u000d\u000aonds, minutes, and hours.\u000d\u000aSolution\u000d\u000aIf you can find the number of days between two dates, you can find seconds, minutes,\u000d\u000aand hours as they are the units of time that make up a day.\u000d\u000aDB2\u000d\u000aUse the function DAYS to find the difference between ALLEN_HD and WARD_HD\u000d\u000ain days. Then multiply to find each unit of time:\u000d\u000a 1 select dy*24 hr, dy*24*60 min, dy*24*60*60 sec\u000d\u000a 2 from (\u000d\u000a 3 select ( days(max(case when ename = 'WARD'\u000d\u000a 4 then hiredate\u000d\u000a 5 end)) -\u000d\u000a 6 days(max(case when ename = 'ALLEN'\u000d\u000a 7 then hiredate\u000d\u000a 8 end))\u000d\u000a 9 ) as dy\u000d\u000a10 from emp\u000d\u000a11 ) x\u000d\u000aMySQL\u000d\u000aUse the DATEDIFF function to return the number of days between ALLEN_HD and\u000d\u000aWARD_HD. Then multiply to find each unit of time:\u000d\u000a 1 select datediff(day,allen_hd,ward_hd)*24 hr,\u000d\u000a 2 datediff(day,allen_hd,ward_hd)*24*60 min,\u000d\u000a 3 datediff(day,allen_hd,ward_hd)*24*60*60 sec\u000d\u000a 4 from (\u000d\u000a 5 select max(case when ename = 'WARD'\u000d\u000a 6 then hiredate\u000d\u000a 7 end) as ward_hd,\u000d\u000a 8 max(case when ename = 'ALLEN'\u000d\u000a 9 then hiredate\u000d\u000a10 end) as allen_hd\u000d\u000a11 from emp\u000d\u000a12 ) x\u000d\u000a218 | Chapter 8: Date Arithmetic","SQL Server\u000d\u000aUse the DATEDIFF function to return the number of days between ALLEN_HD and\u000d\u000aWARD_HD. Then use the DATEPART argument to specify the required time unit:\u000d\u000a 1 select datediff(day,allen_hd,ward_hd,hour) as hr,\u000d\u000a 2 datediff(day,allen_hd,ward_hd,minute) as min,\u000d\u000a 3 datediff(day,allen_hd,ward_hd,second) as sec\u000d\u000a 4 from (\u000d\u000a 5 select max(case when ename = 'WARD'\u000d\u000a 6 then hiredate\u000d\u000a 7 end) as ward_hd,\u000d\u000a 8 max(case when ename = 'ALLEN'\u000d\u000a 9 then hiredate\u000d\u000a10 end) as allen_hd\u000d\u000a11 from emp\u000d\u000a12 ) x\u000d\u000aOracle and PostgreSQL\u000d\u000aUse subtraction to return the number of days between ALLEN_HD and WARD_ HD.\u000d\u000aThen multiply to find each unit of time:\u000d\u000a 1 select dy*24 as hr, dy*24*60 as min, dy*24*60*60 as sec\u000d\u000a 2 from (\u000d\u000a 3 select (max(case when ename = 'WARD'\u000d\u000a 4 then hiredate\u000d\u000a 5 end) -\u000d\u000a 6 max(case when ename = 'ALLEN'\u000d\u000a 7 then hiredate\u000d\u000a 8 end)) as dy\u000d\u000a 9 from emp\u000d\u000a10 ) x\u000d\u000aDiscussion\u000d\u000aInline view X for all solutions returns the HIREDATEs for WARD and ALLEN, as\u000d\u000ashown here:\u000d\u000aselect max(case when ename = 'WARD'\u000d\u000a then hiredate\u000d\u000a end) as ward_hd,\u000d\u000a max(case when ename = 'ALLEN'\u000d\u000a then hiredate\u000d\u000a end) as allen_hd\u000d\u000a from emp\u000d\u000aWARD_HD ALLEN_HD\u000d\u000a----------- -----------\u000d\u000a22-FEB-2006 20-FEB-2006\u000d\u000a8.5 Determining the Number of Seconds, Minutes, or Hours Between Two Dates | 219","Multiply the number of days between WARD_HD and ALLEN_HD by 24 (hours in a\u000d\u000aday), 1440 (minutes in a day), and 86400 (seconds in a day).\u000d\u000a8.6 Counting the Occurrences of Weekdays in a Year\u000d\u000aProblem\u000d\u000aYou want to count the number of times each weekday occurs in one year.\u000d\u000aSolution\u000d\u000aTo find the number of occurrences of each weekday in a year, you must:\u000d\u000a1. Generate all possible dates in the year.\u000d\u000a2. Format the dates such that they resolve to the name of their respective weekdays.\u000d\u000a3. Count the occurrence of each weekday name.\u000d\u000aDB2\u000d\u000aUse recursive WITH to avoid the need to SELECT against a table with at least 366\u000d\u000arows. Use the function DAYNAME to obtain the weekday name for each date, and\u000d\u000athen count the occurrence of each:\u000d\u000a 1 with x (start_date,end_date)\u000d\u000a 2 as (\u000d\u000a 3 select start_date,\u000d\u000a 4 start_date + 1 year end_date\u000d\u000a 5 from (\u000d\u000a 6 select (current_date\u000d\u000a 7 dayofyear(current_date) day)\u000d\u000a 8 +1 day as start_date\u000d\u000a 9 from t1\u000d\u000a10 ) tmp\u000d\u000a11 union all\u000d\u000a12 select start_date + 1 day, end_date\u000d\u000a13 from x\u000d\u000a14 where start_date + 1 day < end_date\u000d\u000a15 )\u000d\u000a16 select dayname(start_date),count(*)\u000d\u000a17 from x\u000d\u000a18 group by dayname(start_date)\u000d\u000aMySQL\u000d\u000aSelect against table T500 to generate enough rows to return every day in the year. Use\u000d\u000athe DATE_FORMAT function to obtain the weekday name of each date, and then\u000d\u000acount the occurrence of each name:\u000d\u000a220 | Chapter 8: Date Arithmetic"," 1 select date_format(\u000d\u000a 2 date_add(\u000d\u000a 3 cast(\u000d\u000a 4 concat(year(current_date),'-01-01')\u000d\u000a 5 as date),\u000d\u000a 6 interval t500.id-1 day),\u000d\u000a 7 '%W') day,\u000d\u000a 8 count(*)\u000d\u000a 9 from t500\u000d\u000a10 where t500.id <= datediff(\u000d\u000a11 cast(\u000d\u000a12 concat(year(current_date)+1,'-01-01')\u000d\u000a13 as date),\u000d\u000a14 cast(\u000d\u000a15 concat(year(current_date),'-01-01')\u000d\u000a16 as date))\u000d\u000a17 group by date_format(\u000d\u000a18 date_add(\u000d\u000a19 cast(\u000d\u000a20 concat(year(current_date),'-01-01')\u000d\u000a21 as date),\u000d\u000a22 interval t500.id-1 day),\u000d\u000a23 '%W')\u000d\u000aOracle\u000d\u000aYou can use the recursive CONNECT BY to return each day in a year:\u000d\u000a 1 with x as (\u000d\u000a 2 select level lvl\u000d\u000a 3 from dual\u000d\u000a 4 connect by level <= (\u000d\u000a 5 add_months(trunc(sysdate,'y'),12)-trunc(sysdate,'y')\u000d\u000a 6 )\u000d\u000a 7 )\u000d\u000a 8 select to_char(trunc(sysdate,'y')+lvl-1,'DAY'), count(*)\u000d\u000a 9 from x\u000d\u000a10 group by to_char(trunc(sysdate,'y')+lvl-1,'DAY')\u000d\u000aPostgreSQL\u000d\u000aUse the built-in function GENERATE_SERIES to generate one row for every day in\u000d\u000athe year. Then use the TO_CHAR function to obtain the weekday name of each date.\u000d\u000aFinally, count the occurrence of each weekday name. For example:\u000d\u000a 1 select to_char(\u000d\u000a 2 cast(\u000d\u000a 3 date_trunc('year',current_date)\u000d\u000a 4 as date) + gs.id-1,'DAY'),\u000d\u000a 5 count(*)\u000d\u000a 6 from generate_series(1,366) gs(id)\u000d\u000a 7 where gs.id <= (cast\u000d\u000a8.6 Counting the Occurrences of Weekdays in a Year | 221"," 8 ( date_trunc('year',current_date) +\u000d\u000a 9 interval '12 month' as date) -\u000d\u000a10 cast(date_trunc('year',current_date)\u000d\u000a11 as date))\u000d\u000a12 group by to_char(\u000d\u000a13 cast(\u000d\u000a14 date_trunc('year',current_date)\u000d\u000a15 as date) + gs.id-1,'DAY')\u000d\u000aSQL Server\u000d\u000aUse the recursive WITH to avoid the need to SELECT against a table with at least 366\u000d\u000arows. Use the DATENAME function to obtain the weekday name of each date, and\u000d\u000athen count the occurrence of each name. For example:\u000d\u000a 1 with x (start_date,end_date)\u000d\u000a 2 as (\u000d\u000a 3 select start_date,\u000d\u000a 4 dateadd(year,1,start_date) end_date\u000d\u000a 5 from (\u000d\u000a 6 select cast(\u000d\u000a 7 cast(year(getdate()) as varchar) + '-01-01'\u000d\u000a 8 as datetime) start_date\u000d\u000a 9 from t1\u000d\u000a10 ) tmp\u000d\u000a11 union all\u000d\u000a12 select dateadd(day,1,start_date), end_date\u000d\u000a13 from x\u000d\u000a14 where dateadd(day,1,start_date) < end_date\u000d\u000a15 )\u000d\u000a16 select datename(dw,start_date),count(*)\u000d\u000a17 from x\u000d\u000a18 group by datename(dw,start_date)\u000d\u000a19 OPTION (MAXRECURSION 366)\u000d\u000aDiscussion\u000d\u000aDB2\u000d\u000aInline view TMP, in the recursive WITH view X, returns the first day of the current\u000d\u000ayear and is shown here:\u000d\u000aselect (current_date\u000d\u000a dayofyear(current_date) day)\u000d\u000a +1 day as start_date\u000d\u000a from t1\u000d\u000aSTART_DATE\u000d\u000a-------------\u000d\u000a01-JAN-2005\u000d\u000a222 | Chapter 8: Date Arithmetic","The next step is to add one year to START_DATE so that you have the beginning and\u000d\u000aend dates. You need to know both because you want to generate every day in a year.\u000d\u000aSTART_DATE and END_DATE are shown here:\u000d\u000aselect start_date,\u000d\u000a start_date + 1 year end_date\u000d\u000a from (\u000d\u000aselect (current_date\u000d\u000a dayofyear(current_date) day)\u000d\u000a +1 day as start_date\u000d\u000a from t1\u000d\u000a ) tmp\u000d\u000a START_DATE END_DATE\u000d\u000a ----------- ------------\u000d\u000a 01-JAN-2005 01-JAN-2006\u000d\u000aThe next step is to recursively increment START_DATE by one day, stopping before\u000d\u000ait equals END_DATE. A portion of the rows returned by the recursive view X is\u000d\u000ashown here:\u000d\u000awith x (start_date,end_date)\u000d\u000aas (\u000d\u000aselect start_date,\u000d\u000a start_date + 1 year end_date\u000d\u000a from (\u000d\u000aselect (current_date -\u000d\u000a dayofyear(current_date) day)\u000d\u000a +1 day as start_date\u000d\u000a from t1\u000d\u000a ) tmp\u000d\u000a union all\u000d\u000aselect start_date + 1 day, end_date\u000d\u000a from x\u000d\u000a where start_date + 1 day < end_date\u000d\u000a)\u000d\u000aselect * from x\u000d\u000aSTART_DATE END_DATE\u000d\u000a----------- -----------\u000d\u000a01-JAN-2005 01-JAN-2006\u000d\u000a02-JAN-2005 01-JAN-2006\u000d\u000a03-JAN-2005 01-JAN-2006\u000d\u000a\u2026\u000d\u000a29-JAN-2005 01-JAN-2006\u000d\u000a30-JAN-2005 01-JAN-2006\u000d\u000a31-JAN-2005 01-JAN-2006\u000d\u000a\u2026\u000d\u000a01-DEC-2005 01-JAN-2006\u000d\u000a02-DEC-2005 01-JAN-2006\u000d\u000a03-DEC-2005 01-JAN-2006\u000d\u000a\u2026\u000d\u000a8.6 Counting the Occurrences of Weekdays in a Year | 223","29-DEC-2005 01-JAN-2006\u000d\u000a30-DEC-2005 01-JAN-2006\u000d\u000a31-DEC-2005 01-JAN-2006\u000d\u000aThe final step is to use the function DAYNAME on the rows returned by the recur\u2010\u000d\u000asive view X and count how many times each weekday occurs. The final result is\u000d\u000ashown here:\u000d\u000awith x (start_date,end_date)\u000d\u000aas (\u000d\u000aselect start_date,\u000d\u000a start_date + 1 year end_date\u000d\u000a from (\u000d\u000aselect (\u000d\u000a current_date -\u000d\u000a dayofyear(current_date) day)\u000d\u000a +1 day as start_date\u000d\u000a from t1\u000d\u000a ) tmp\u000d\u000a union all\u000d\u000aselect start_date + 1 day, end_date\u000d\u000a from x\u000d\u000a where start_date + 1 day < end_date\u000d\u000a)\u000d\u000aselect dayname(start_date),count(*)\u000d\u000a from x\u000d\u000a group by dayname(start_date)\u000d\u000aSTART_DATE COUNT(*)\u000d\u000a---------- ----------\u000d\u000aFRIDAY 52\u000d\u000aMONDAY 52\u000d\u000aSATURDAY 53\u000d\u000aSUNDAY 52\u000d\u000aTHURSDAY 52\u000d\u000aTUESDAY 52\u000d\u000aWEDNESDAY 52\u000d\u000aMySQL\u000d\u000aThis solution selects against table T500 to generate one row for every day in the year.\u000d\u000aThe command on line 4 returns the first day of the current year. It does this by\u000d\u000areturning the year of the date returned by the function CURRENT_DATE and then\u000d\u000aappending a month and day (following MySQL\u2019s default date format). The result is\u000d\u000ashown here:\u000d\u000aselect concat(year(current_date),'-01-01')\u000d\u000a from t1\u000d\u000aSTART_DATE\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000a224 | Chapter 8: Date Arithmetic","Now that you have the first day in the current year, use the DATEADD function to\u000d\u000aadd each value from T500.ID to generate each day in the year. Use the function\u000d\u000aDATE_FORMAT to return the weekday for each date. To generate the required num\u2010\u000d\u000aber of rows from table T500, find the difference in days between the first day of the\u000d\u000acurrent year and the first day of the next year, and return that many rows (will be\u000d\u000aeither 365 or 366). A portion of the results is shown here:\u000d\u000aselect date_format(\u000d\u000a date_add(\u000d\u000a cast(\u000d\u000a concat(year(current_date),'-01-01')\u000d\u000a as date),\u000d\u000a interval t500.id-1 day),\u000d\u000a '%W') day\u000d\u000a from t500\u000d\u000a where t500.id <= datediff(\u000d\u000a cast(\u000d\u000a concat(year(current_date)+1,'-01-01')\u000d\u000a as date),\u000d\u000a cast(\u000d\u000a concat(year(current_date),'-01-01')\u000d\u000a as date))\u000d\u000aDAY\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000a02-JAN-2005\u000d\u000a03-JAN-2005\u000d\u000a\u2026\u000d\u000a29-JAN-2005\u000d\u000a30-JAN-2005\u000d\u000a31-JAN-2005\u000d\u000a\u2026\u000d\u000a01-DEC-2005\u000d\u000a02-DEC-2005\u000d\u000a03-DEC-2005\u000d\u000a\u2026\u000d\u000a29-DEC-2005\u000d\u000a30-DEC-2005\u000d\u000a31-DEC-2005\u000d\u000aNow that you can return every day in the current year, count the occurrences of each\u000d\u000aweekday returned by the function DAYNAME. The final results are shown here:\u000d\u000aselect date_format(\u000d\u000a date_add(\u000d\u000a cast(\u000d\u000a concat(year(current_date),'-01-01')\u000d\u000a as date),\u000d\u000a interval t500.id-1 day),\u000d\u000a '%W') day,\u000d\u000a count(*)\u000d\u000a8.6 Counting the Occurrences of Weekdays in a Year | 225"," from t500\u000d\u000a where t500.id <= datediff(\u000d\u000a cast(\u000d\u000a concat(year(current_date)+1,'-01-01')\u000d\u000a as date),\u000d\u000a cast(\u000d\u000a concat(year(current_date),'-01-01')\u000d\u000a as date))\u000d\u000a group by date_format(\u000d\u000a date_add(\u000d\u000a cast(\u000d\u000a concat(year(current_date),'-01-01')\u000d\u000a as date),\u000d\u000a interval t500.id-1 day),\u000d\u000a '%W')\u000d\u000aDAY COUNT(*)\u000d\u000a--------- ----------\u000d\u000aFRIDAY 52\u000d\u000aMONDAY 52\u000d\u000aSATURDAY 53\u000d\u000aSUNDAY 52\u000d\u000aTHURSDAY 52\u000d\u000aTUESDAY 52\u000d\u000aWEDNESDAY 52\u000d\u000aOracle\u000d\u000aThe solutions provided either select against table T500 (a pivot table), or use the\u000d\u000arecursive CONNECT BY and WITH to generate a row for every day in the current\u000d\u000ayear. The call to the function TRUNC truncates the current date to the first day of the\u000d\u000acurrent year.\u000d\u000aIf you are using the CONNECT BY/WITH solution, you can use the pseudo-column\u000d\u000aLEVEL to generate sequential numbers beginning at one. To generate the required\u000d\u000anumber of rows needed for this solution, filter ROWNUM or LEVEL on the differ\u2010\u000d\u000aence in days between the first day of the current year and the first day of the next year\u000d\u000a(will be 365 or 366 days). The next step is to increment each day by adding ROW\u2010\u000d\u000aNUM or LEVEL to the first day of the current year. Partial results are shown here:\u000d\u000a/* Oracle 9i and later */\u000d\u000awith x as (\u000d\u000aselect level lvl\u000d\u000a from dual\u000d\u000a connect by level <= (\u000d\u000a add_months(trunc(sysdate,'y'),12)-trunc(sysdate,'y')\u000d\u000a )\u000d\u000a)\u000d\u000aselect trunc(sysdate,'y')+lvl-1 from x\u000d\u000a226 | Chapter 8: Date Arithmetic","If you are using the pivot-table solution, you can use any table or view with at least\u000d\u000a366 rows in it. And since Oracle has ROWNUM, there\u2019s no need for a table with\u000d\u000aincrementing values starting from one. Consider the following example, which uses\u000d\u000apivot table T500 to return every day in the current year:\u000d\u000a/* Oracle 8i and earlier */\u000d\u000aselect trunc(sysdate,'y')+rownum-1 start_date\u000d\u000a from t500\u000d\u000a where rownum <= (add_months(trunc(sysdate,'y'),12)\u000d\u000a - trunc(sysdate,'y'))\u000d\u000aSTART_DATE\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000a02-JAN-2005\u000d\u000a03-JAN-2005\u000d\u000a\u2026\u000d\u000a29-JAN-2005\u000d\u000a30-JAN-2005\u000d\u000a31-JAN-2005\u000d\u000a\u2026\u000d\u000a01-DEC-2005\u000d\u000a02-DEC-2005\u000d\u000a03-DEC-2005\u000d\u000a\u2026\u000d\u000a29-DEC-2005\u000d\u000a30-DEC-2005\u000d\u000a31-DEC-2005\u000d\u000aRegardless of which approach you take, you eventually must use the function TO_\u000d\u000aCHAR to return the weekday name for each date and then count the occurrence of\u000d\u000aeach name. The final results are shown here:\u000d\u000a/* Oracle 9i and later */\u000d\u000awith x as (\u000d\u000aselect level lvl\u000d\u000a from dual\u000d\u000a connect by level <= (\u000d\u000a add_months(trunc(sysdate,'y'),12)-trunc(sysdate,'y')\u000d\u000a )\u000d\u000a)\u000d\u000aselect to_char(trunc(sysdate,'y')+lvl-1,'DAY'), count(*)\u000d\u000a from x\u000d\u000a group by to_char(trunc(sysdate,'y')+lvl-1,'DAY')\u000d\u000a/* Oracle 8i and earlier */\u000d\u000aselect to_char(trunc(sysdate,'y')+rownum-1,'DAY') start_date,\u000d\u000a count(*)\u000d\u000a from t500\u000d\u000a where rownum <= (add_months(trunc(sysdate,'y'),12)\u000d\u000a - trunc(sysdate,'y'))\u000d\u000a group by to_char(trunc(sysdate,'y')+rownum-1,'DAY')\u000d\u000a8.6 Counting the Occurrences of Weekdays in a Year | 227","START_DATE COUNT(*)\u000d\u000a---------- ----------\u000d\u000aFRIDAY 52\u000d\u000aMONDAY 52\u000d\u000aSATURDAY 53\u000d\u000aSUNDAY 52\u000d\u000aTHURSDAY 52\u000d\u000aTUESDAY 52\u000d\u000aWEDNESDAY 52\u000d\u000aPostgreSQL\u000d\u000aThe first step is to use the DATE_TRUNC function to return the year of the current\u000d\u000adate (shown here, selecting against T1 so only one row is returned):\u000d\u000aselect cast(\u000d\u000a date_trunc('year',current_date)\u000d\u000a as date) as start_date\u000d\u000a from t1\u000d\u000a START_DATE\u000d\u000a ----------\u000d\u000a 01-JAN-2005\u000d\u000aThe next step is to select against a row source (any table expression, really) with at\u000d\u000aleast 366 rows. The solution uses the function GENERATE_SERIES as the row\u000d\u000asource. You can, of course, use table T500 instead. Then add one day to the first day\u000d\u000aof the current year until you return every day in the year (shown here):\u000d\u000aselect cast( date_trunc('year',current_date)\u000d\u000a as date) + gs.id-1 as start_date\u000d\u000a from generate_series (1,366) gs(id)\u000d\u000a where gs.id <= (cast\u000d\u000a ( date_trunc('year',current_date) +\u000d\u000a interval '12 month' as date) -\u000d\u000a cast(date_trunc('year',current_date)\u000d\u000a as date))\u000d\u000aSTART_DATE\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000a02-JAN-2005\u000d\u000a03-JAN-2005\u000d\u000a\u2026\u000d\u000a29-JAN-2005\u000d\u000a30-JAN-2005\u000d\u000a31-JAN-2005\u000d\u000a\u2026\u000d\u000a01-DEC-2005\u000d\u000a02-DEC-2005\u000d\u000a03-DEC-2005\u000d\u000a228 | Chapter 8: Date Arithmetic","\u2026\u000d\u000a29-DEC-2005\u000d\u000a30-DEC-2005\u000d\u000a31-DEC-2005\u000d\u000aThe final step is to use the function TO_CHAR to return the weekday name for each\u000d\u000adate and then count the occurrence of each name. The final results are shown here:\u000d\u000aselect to_char(\u000d\u000a cast(\u000d\u000a date_trunc('year',current_date)\u000d\u000a as date) + gs.id-1,'DAY') as start_dates,\u000d\u000a count(*)\u000d\u000a from generate_series(1,366) gs(id)\u000d\u000a where gs.id <= (cast\u000d\u000a ( date_trunc('year',current_date) +\u000d\u000a interval '12 month' as date) -\u000d\u000a cast(date_trunc('year',current_date)\u000d\u000a as date))\u000d\u000a group by to_char(\u000d\u000a cast(\u000d\u000a date_trunc('year',current_date)\u000d\u000a as date) + gs.id-1,'DAY')\u000d\u000aSTART_DATE COUNT(*)\u000d\u000a---------- ----------\u000d\u000aFRIDAY 52\u000d\u000aMONDAY 52\u000d\u000aSATURDAY 53\u000d\u000aSUNDAY 52\u000d\u000aTHURSDAY 52\u000d\u000aTUESDAY 52\u000d\u000aWEDNESDAY 52\u000d\u000aSQL Server\u000d\u000aInline view TMP, in the recursive WITH view X, returns the first day of the current\u000d\u000ayear and is shown here:\u000d\u000aselect cast(\u000d\u000a cast(year(getdate()) as varchar) + '-01-01'\u000d\u000a as datetime) start_date\u000d\u000a from t1\u000d\u000aSTART_DATE\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000aOnce you return the first day of the current year, add one year to START_DATE so\u000d\u000athat you have the beginning and end dates. You need to know both because you want\u000d\u000ato generate every day in a year.\u000d\u000aSTART_DATE and END_DATE are shown here:\u000d\u000a8.6 Counting the Occurrences of Weekdays in a Year | 229","select start_date,\u000d\u000a dateadd(year,1,start_date) end_date\u000d\u000a from (\u000d\u000aselect cast(\u000d\u000a cast(year(getdate()) as varchar) + '-01-01'\u000d\u000a as datetime) start_date\u000d\u000a from t1\u000d\u000a ) tmp\u000d\u000aSTART_DATE END_DATE\u000d\u000a----------- -----------\u000d\u000a01-JAN-2005 01-JAN-2006\u000d\u000aNext, recursively increment START_DATE by one day and stop before it equals\u000d\u000aEND_DATE. A portion of the rows returned by the recursive view X is shown below:\u000d\u000awith x (start_date,end_date)\u000d\u000a as (\u000d\u000a select start_date,\u000d\u000a dateadd(year,1,start_date) end_date\u000d\u000a from (\u000d\u000a select cast(\u000d\u000a cast(year(getdate()) as varchar) + '-01-01'\u000d\u000a as datetime) start_date\u000d\u000a from t1\u000d\u000a ) tmp\u000d\u000a union all\u000d\u000a select dateadd(day,1,start_date), end_date\u000d\u000a from x\u000d\u000a where dateadd(day,1,start_date) < end_date\u000d\u000a )\u000d\u000a select * from x\u000d\u000a OPTION (MAXRECURSION 366)\u000d\u000aSTART_DATE END_DATE\u000d\u000a----------- -----------\u000d\u000a01-JAN-2005 01-JAN-2006\u000d\u000a02-JAN-2005 01-JAN-2006\u000d\u000a03-JAN-2005 01-JAN-2006\u000d\u000a\u2026\u000d\u000a29-JAN-2005 01-JAN-2006\u000d\u000a30-JAN-2005 01-JAN-2006\u000d\u000a31-JAN-2005 01-JAN-2006\u000d\u000a\u2026\u000d\u000a01-DEC-2005 01-JAN-2006\u000d\u000a02-DEC-2005 01-JAN-2006\u000d\u000a03-DEC-2005 01-JAN-2006\u000d\u000a\u2026\u000d\u000a29-DEC-2005 01-JAN-2006\u000d\u000a30-DEC-2005 01-JAN-2006\u000d\u000a31-DEC-2005 01-JAN-2006\u000d\u000a230 | Chapter 8: Date Arithmetic","The final step is to use the function DATENAME on the rows returned by the recur\u2010\u000d\u000asive view X and count how many times each weekday occurs. The final result is\u000d\u000ashown here:\u000d\u000awith x(start_date,end_date)\u000d\u000a as (\u000d\u000a select start_date,\u000d\u000a dateadd(year,1,start_date) end_date\u000d\u000a from (\u000d\u000a select cast(\u000d\u000a cast(year(getdate()) as varchar) + '-01-01'\u000d\u000a as datetime) start_date\u000d\u000a from t1\u000d\u000a ) tmp\u000d\u000a union all\u000d\u000a select dateadd(day,1,start_date), end_date\u000d\u000a from x\u000d\u000a where dateadd(day,1,start_date) < end_date\u000d\u000a )\u000d\u000a select datename(dw,start_date), count(*)\u000d\u000a from x\u000d\u000a group by datename(dw,start_date)\u000d\u000a OPTION (MAXRECURSION 366)\u000d\u000aSTART_DATE COUNT(*)\u000d\u000a--------- ----------\u000d\u000aFRIDAY 52\u000d\u000aMONDAY 52\u000d\u000aSATURDAY 53\u000d\u000aSUNDAY 52\u000d\u000aTHURSDAY 52\u000d\u000aTUESDAY 52\u000d\u000aWEDNESDAY 52\u000d\u000a8.7 Determining the Date Difference Between the Current\u000d\u000aRecord and the Next Record\u000d\u000aProblem\u000d\u000aYou want to determine the difference in days between two dates (specifically dates\u000d\u000astored in two different rows). For example, for every employee in DEPTNO 10, you\u000d\u000awant to determine the number of days between the day they were hired and the day\u000d\u000athe next employee (can be in another department) was hired.\u000d\u000a8.7 Determining the Date Difference Between the Current Record and the Next Record | 231","Solution\u000d\u000aThe trick to this problem\u2019s solution is to find the earliest HIREDATE after the current\u000d\u000aemployee was hired. After that, simply use the technique from Recipe 8.2 to find the\u000d\u000adifference in days.\u000d\u000aDB2\u000d\u000aUse a scalar subquery to find the next HIREDATE relative to the current HIREDATE.\u000d\u000aThen use the DAYS function to find the difference in days:\u000d\u000a1 select x.*,\u000d\u000a2 days(x.next_hd) - days(x.hiredate) diff\u000d\u000a3 from (\u000d\u000a4 select e.deptno, e.ename, e.hiredate,\u000d\u000a5 lead(hiredate)over(order by hiredate) next_hd\u000d\u000a6 from emp e\u000d\u000a7 where e.deptno = 10\u000d\u000a8 ) x\u000d\u000aMySQL and SQL Server\u000d\u000aUse the lead function to access the next row. The SQL Server version of DATEDIFF is\u000d\u000aused here:\u000d\u000a1 select x.ename, x.hiredate, x.next_hd,\u000d\u000a2 datediff(x.hiredate,x.next_hd,day) as diff\u000d\u000a3 from (\u000d\u000a4 select deptno, ename, hiredate,\u000d\u000a5 lead(hiredate)over(order by hiredate) as next_hd\u000d\u000a6 from emp e\u000d\u000a7 ) x\u000d\u000a8 where e.deptno=10\u000d\u000aMySQL users can exclude the first argument (\u201cday\u201d) and switch the order of the two\u000d\u000aremaining arguments:\u000d\u000a2 datediff(x.next_hd, x.hiredate) diff\u000d\u000aOracle\u000d\u000aUse the window function LEAD OVER to access the next HIREDATE relative to the\u000d\u000acurrent row, thus facilitating subtraction:\u000d\u000a1 select ename, hiredate, next_hd,\u000d\u000a2 next_hd - hiredate diff\u000d\u000a3 from (\u000d\u000a4 select deptno, ename, hiredate,\u000d\u000a5 lead(hiredate)over(order by hiredate) next_hd\u000d\u000a6 from emp\u000d\u000a7 )\u000d\u000a8 where deptno=10\u000d\u000a232 | Chapter 8: Date Arithmetic","PostgreSQL\u000d\u000aUse a scalar subquery to find the next HIREDATE relative to the current HIREDATE.\u000d\u000aThen use simple subtraction to find the difference in days:\u000d\u000a1 select x.*,\u000d\u000a2 x.next_hd - x.hiredate as diff\u000d\u000a3 from (\u000d\u000a4 select e.deptno, e.ename, e.hiredate,\u000d\u000a5 lead(hiredate)over(order by hiredate) as next_hd\u000d\u000a7 from emp e\u000d\u000a8 where e.deptno = 10\u000d\u000a9 ) x\u000d\u000aDiscussion\u000d\u000aDespite the differences in syntax, the approach is the same for all these solutions: use\u000d\u000athe window function LEAD and then find the difference in days between the two\u000d\u000ausing the technique described in Recipe 8.2.\u000d\u000aThe ability to access rows around your current row without additional joins provides\u000d\u000afor more readable and efficient code. When working with window functions, keep in\u000d\u000amind that they are evaluated after the WHERE clause, hence the need for an inline\u000d\u000aview in the solution. If you were to move the filter on DEPTNO into the inline view,\u000d\u000athe results would change (only the HIREDATEs from DEPTNO 10 would be consid\u2010\u000d\u000aered). One important note to mention about Oracle\u2019s LEAD and LAG functions is\u000d\u000atheir behavior in the presence of duplicates. In the preface we mention that these rec\u2010\u000d\u000aipes are not coded \u201cdefensively\u201d because there are too many conditions that one can\u2019t\u000d\u000apossibly foresee that can break code. Or, even if one can foresee every problem, some\u2010\u000d\u000atimes the resulting SQL becomes unreadable. So in most cases, the goal of a solution\u000d\u000ais to introduce a technique: one that you can use in your production system, but that\u000d\u000amust be tested and many times tweaked to work for your particular data. In this case,\u000d\u000athough, there is a situation that we will discuss simply because the workaround may\u000d\u000anot be all that obvious, particularly for those coming from non-Oracle systems. In\u000d\u000athis example there are no duplicate HIREDATEs in table EMP, but it is certainly pos\u2010\u000d\u000asible (and probably likely) that there are duplicate date values in your tables. Con\u2010\u000d\u000asider the employees in DEPTNO 10 and their HIREDATEs:\u000d\u000aselect ename, hiredate\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a order by 2\u000d\u000aENAME HIREDATE\u000d\u000a------ -----------\u000d\u000aCLARK 09-JUN-2006\u000d\u000aKING 17-NOV-2006\u000d\u000aMILLER 23-JAN-2007\u000d\u000a8.7 Determining the Date Difference Between the Current Record and the Next Record | 233","For the sake of this example, let\u2019s insert four duplicates such that there are five\u000d\u000aemployees (including KING) hired on November 17:\u000d\u000ainsert into emp (empno,ename,deptno,hiredate)\u000d\u000avalues (1,'ant',10,to_date('17-NOV-2006'))\u000d\u000ainsert into emp (empno,ename,deptno,hiredate)\u000d\u000avalues (2,'joe',10,to_date('17-NOV-2006'))\u000d\u000ainsert into emp (empno,ename,deptno,hiredate)\u000d\u000avalues (3,'jim',10,to_date('17-NOV-2006'))\u000d\u000ainsert into emp (empno,ename,deptno,hiredate)\u000d\u000avalues (4,'choi',10,to_date('17-NOV-2006'))\u000d\u000aselect ename, hiredate\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a order by 2\u000d\u000aENAME HIREDATE\u000d\u000a------ -----------\u000d\u000aCLARK 09-JUN-2006\u000d\u000aant 17-NOV-2006\u000d\u000ajoe 17-NOV-2006\u000d\u000aKING 17-NOV-2006\u000d\u000ajim 17-NOV-2006\u000d\u000achoi 17-NOV-2007\u000d\u000aMILLER 23-JAN-2007\u000d\u000aNow there are multiple employees in DEPTNO 10 hired on the same day. If you try\u000d\u000ato use the proposed solution (moving the filter into the inline view so you only are\u000d\u000aconcerned with employees in DEPTNO 10 and their HIREDATEs) on this result set,\u000d\u000ayou get the following output:\u000d\u000aselect ename, hiredate, next_hd,\u000d\u000a next_hd - hiredate diff\u000d\u000a from (\u000d\u000aselect deptno, ename, hiredate,\u000d\u000a lead(hiredate)over(order by hiredate) next_hd\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a )\u000d\u000aENAME HIREDATE NEXT_HD DIFF\u000d\u000a------ ----------- ----------- ----------\u000d\u000aCLARK 09-JUN-2006 17-NOV-2006 161\u000d\u000aant 17-NOV-2006 17-NOV-2006 0\u000d\u000ajoe 17-NOV-2006 17-NOV-2006 0\u000d\u000aKING 17-NOV-2006 17-NOV-2006 0\u000d\u000ajim 17-NOV-2006 17-NOV-2006 0\u000d\u000a234 | Chapter 8: Date Arithmetic","choi 17-NOV-2006 23-JAN-2007 67\u000d\u000aMILLER 23-JAN-2007 (null) (null)\u000d\u000aLooking at the values of DIFF for four of the five employees hired on the same day,\u000d\u000ayou can see that the value is zero. This is not correct. All employees hired on the same\u000d\u000aday should have their dates evaluated against the HIREDATE of the next date on\u000d\u000awhich an employee was hired (i.e., all employees hired on November 17 should be\u000d\u000aevaluated against MILLER\u2019s HIREDATE). The problem here is that the LEAD func\u2010\u000d\u000ation orders the rows by HIREDATE but does not skip duplicates. So, for example,\u000d\u000awhen employee ANT\u2019s HIREDATE is evaluated against employee JOE\u2019s HIREDATE,\u000d\u000athe difference is zero, hence a DIFF value of zero for ANT. Fortunately, Oracle has\u000d\u000aprovided an easy workaround for situations like this one. When invoking the LEAD\u000d\u000afunction, you can pass an argument to LEAD to specify exactly where the future row\u000d\u000ais (i.e., is it the next row, 10 rows later, etc.). So, looking at employee ANT, instead of\u000d\u000alooking ahead one row, you need to look ahead five rows (you want to jump over all\u000d\u000athe other duplicates), because that\u2019s where MILLER is. If you look at employee JOE,\u000d\u000ahe is four rows from MILLER, JIM is three rows from MILLER, KING is two rows\u000d\u000afrom MILLER, and pretty boy CHOI is one row from MILLER. To get the correct\u000d\u000aanswer, simply pass the distance from each employee to MILLER as an argument to\u000d\u000aLEAD. The solution is shown here:\u000d\u000aselect ename, hiredate, next_hd,\u000d\u000a next_hd - hiredate diff\u000d\u000a from (\u000d\u000aselect deptno, ename, hiredate,\u000d\u000a lead(hiredate,cnt-rn+1)over(order by hiredate) next_hd\u000d\u000a from (\u000d\u000aselect deptno,ename,hiredate,\u000d\u000a count(*)over(partition by hiredate) cnt,\u000d\u000a row_number()over(partition by hiredate order by empno) rn\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a )\u000d\u000a )\u000d\u000aENAME HIREDATE NEXT_HD DIFF\u000d\u000a------ ----------- ----------- ----------\u000d\u000aCLARK 09-JUN-2006 17-NOV-2006 161\u000d\u000aant 17-NOV-2006 23-JAN-2007 67\u000d\u000ajoe 17-NOV-2006 23-JAN-2007 67\u000d\u000ajim 17-NOV-2006 23-JAN-2007 67\u000d\u000achoi 17-NOV-2006 23-JAN-2007 67\u000d\u000aKING 17-NOV-2006 23-JAN-2007 67\u000d\u000aMILLER 23-JAN-2007 (null) (null)\u000d\u000aNow the results are correct. All the employees hired on the same day have their HIR\u2010\u000d\u000aEDATEs evaluated against the next HIREDATE, not a HIREDATE that matches their\u000d\u000aown. If the workaround isn\u2019t immediately obvious, simply break down the query.\u000d\u000a8.7 Determining the Date Difference Between the Current Record and the Next Record | 235","Start with the inline view:\u000d\u000aselect deptno,ename,hiredate,\u000d\u000a count(*)over(partition by hiredate) cnt,\u000d\u000a row_number()over(partition by hiredate order by empno) rn\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000aDEPTNO ENAME HIREDATE CNT RN\u000d\u000a------ ------ ----------- ---------- ----------\u000d\u000a 10 CLARK 09-JUN-2006 1 1\u000d\u000a 10 ant 17-NOV-2006 5 1\u000d\u000a 10 joe 17-NOV-2006 5 2\u000d\u000a 10 jim 17-NOV-2006 5 3\u000d\u000a 10 choi 17-NOV-2006 5 4\u000d\u000a 10 KING 17-NOV-2006 5 5\u000d\u000a 10 MILLER 23-JAN-2007 1 1\u000d\u000aThe window function COUNT OVER counts the number of times each HIREDATE\u000d\u000aoccurs and returns this value to each row. For the duplicate HIREDATEs, a value of 5\u000d\u000ais returned for each row with that HIREDATE. The window function ROW_NUM\u2010\u000d\u000aBER OVER ranks each employee by EMPNO. The ranking is partitioned by HIRE\u2010\u000d\u000aDATE, so unless there are duplicate HIREDATEs, each employee will have a rank of\u000d\u000a1. At this point, all the duplicates have been counted and ranked, and the ranking can\u000d\u000aserve as the distance to the next HIREDATE (MILLER\u2019s HIREDATE). You can see\u000d\u000athis by subtracting RN from CNT and adding 1 for each row when calling LEAD:\u000d\u000aselect deptno, ename, hiredate,\u000d\u000a cnt-rn+1 distance_to_miller,\u000d\u000a lead(hiredate,cnt-rn+1)over(order by hiredate) next_hd\u000d\u000a from (\u000d\u000aselect deptno,ename,hiredate,\u000d\u000a count(*)over(partition by hiredate) cnt,\u000d\u000a row_number()over(partition by hiredate order by empno) rn\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a )\u000d\u000aDEPTNO ENAME HIREDATE DISTANCE_TO_MILLER NEXT_HD\u000d\u000a------ ------ ----------- ------------------ -----------\u000d\u000a 10 CLARK 09-JUN-2006 1 17-NOV-2006\u000d\u000a 10 ant 17-NOV-2006 5 23-JAN-2007\u000d\u000a 10 joe 17-NOV-2006 4 23-JAN-2007\u000d\u000a 10 jim 17-NOV-2006 3 23-JAN-2007\u000d\u000a 10 choi 17-NOV-2006 2 23-JAN-2007\u000d\u000a 10 KING 17-NOV-2006 1 23-JAN-2007\u000d\u000a 10 MILLER 23-JAN-2007 1 (null)\u000d\u000aAs you can see, by passing the appropriate distance to jump ahead to, the LEAD func\u2010\u000d\u000ation performs the subtraction on the correct dates.\u000d\u000a236 | Chapter 8: Date Arithmetic","8.8 Summing Up\u000d\u000aDates are a common data type, but have their own quirks, as they have more struc\u2010\u000d\u000ature than simple number data types. In relative terms, there is less standardization\u000d\u000abetween vendors than in many other areas, but every implementation has a core\u000d\u000agroup of functions that perform the same tasks even where the syntax is slightly dif\u2010\u000d\u000aferent. Mastering this core group will ensure your success with dates.\u000d\u000a8.8 Summing Up | 237","","CHAPTER 9\u000d\u000aDate Manipulation\u000d\u000aThis chapter introduces recipes for searching and modifying dates. Queries involving\u000d\u000adates are very common. Thus, you need to know how to think when working with\u000d\u000adates, and you need to have a good understanding of the functions that your RDBMS\u000d\u000aplatform provides for manipulating them. The recipes in this chapter form an impor\u2010\u000d\u000atant foundation for future work as you move on to more complex queries involving\u000d\u000anot only dates, but times, too.\u000d\u000aBefore getting into the recipes, we want to reinforce the concept (mentioned in the\u000d\u000apreface) of using these solutions as guidelines to solving your specific problems. Try\u000d\u000ato think \u201cbig picture.\u201d For example, if a recipe solves a problem for the current\u000d\u000amonth, keep in mind that you may be able to use the recipe for any month (with\u000d\u000aminor modifications), not just the month used in the recipe. Again, these recipes are\u000d\u000aguidelines, the absolute final option. There\u2019s no possible way a book can contain an\u000d\u000aanswer for all your problems, but if you understand what is presented here, modify\u2010\u000d\u000aing these solutions to fit your needs is trivial. Also consider alternative versions of\u000d\u000athese solutions. For instance, if the solution uses one particular function provided by\u000d\u000ayour RDBMS, it is worth the time and effort to find out if there is an alternative\u2014\u000d\u000amaybe one that is more or less efficient than what is presented here. Knowing your\u000d\u000aoptions will make you a better SQL programmer.\u000d\u000aThe recipes presented in this chapter use simple date data types. If\u000d\u000ayou are using more complex date data types, you will need to adjust\u000d\u000athe solutions accordingly.\u000d\u000a239","9.1 Determining Whether a Year Is a Leap Year\u000d\u000aProblem\u000d\u000aYou want to determine whether the current year is a leap year.\u000d\u000aSolution\u000d\u000aIf you\u2019ve worked on SQL for some time, there\u2019s no doubt that you\u2019ve come across sev\u2010\u000d\u000aeral techniques for solving this problem. Just about all the solutions we\u2019ve encoun\u2010\u000d\u000atered work well, but the one presented in this recipe is probably the simplest. This\u000d\u000asolution simply checks the last day of February; if it is the 29th, then the current year\u000d\u000ais a leap year.\u000d\u000aDB2\u000d\u000aUse the recursive WITH clause to return each day in February. Use the aggregate\u000d\u000afunction MAX to determine the last day in February:\u000d\u000a 1 with x (dy,mth)\u000d\u000a 2 as (\u000d\u000a 3 select dy, month(dy)\u000d\u000a 4 from (\u000d\u000a 5 select (current_date -\u000d\u000a 6 dayofyear(current_date) days +1 days)\u000d\u000a 7 +1 months as dy\u000d\u000a 8 from t1\u000d\u000a 9 ) tmp1\u000d\u000a10 union all\u000d\u000a11 select dy+1 days, mth\u000d\u000a12 from x\u000d\u000a13 where month(dy+1 day) = mth\u000d\u000a14 )\u000d\u000a15 select max(day(dy))\u000d\u000a16 from x\u000d\u000aOracle\u000d\u000aUse the function LAST_DAY to find the last day in February:\u000d\u000a1 select to_char(\u000d\u000a2 last_day(add_months(trunc(sysdate,'y'),1)),\u000d\u000a3 'DD')\u000d\u000a4 from t1\u000d\u000a240 | Chapter 9: Date Manipulation","PostgreSQL\u000d\u000aUse the function GENERATE_SERIES to return each day in February, and then use\u000d\u000athe aggregate function MAX to find the last day in February:\u000d\u000a 1 select max(to_char(tmp2.dy+x.id,'DD')) as dy\u000d\u000a 2 from (\u000d\u000a 3 select dy, to_char(dy,'MM') as mth\u000d\u000a 4 from (\u000d\u000a 5 select cast(cast(\u000d\u000a 6 date_trunc('year',current_date) as date)\u000d\u000a 7 + interval '1 month' as date) as dy\u000d\u000a 8 from t1\u000d\u000a 9 ) tmp1\u000d\u000a10 ) tmp2, generate_series (0,29) x(id)\u000d\u000a11 where to_char(tmp2.dy+x.id,'MM') = tmp2.mth\u000d\u000aMySQL\u000d\u000aUse the function LAST_DAY to find the last day in February:\u000d\u000a1 select day(\u000d\u000a2 last_day(\u000d\u000a3 date_add(\u000d\u000a4 date_add(\u000d\u000a5 date_add(current_date,\u000d\u000a6 interval -dayofyear(current_date) day),\u000d\u000a7 interval 1 day),\u000d\u000a8 interval 1 month))) dy\u000d\u000a9 from t1\u000d\u000aSQL Server\u000d\u000aUse the recursive WITH clause to return each day in February. Use the aggregate\u000d\u000afunction MAX to determine the last day in February:\u000d\u000a select coalesce\u000d\u000a (day\u000d\u000a (cast(concat\u000d\u000a (year(getdate()),'-02-29')\u000d\u000a as date))\u000d\u000a ,28);\u000d\u000aDiscussion\u000d\u000aDB2\u000d\u000aThe inline view TMP1 in the recursive view X returns the first day in February by:\u000d\u000a1. Starting with the current date\u000d\u000a9.1 Determining Whether a Year Is a Leap Year | 241","2. Using DAYOFYEAR to determine the number of days into the current year that\u000d\u000athe current date represents\u000d\u000a3. Subtracting that number of days from the current date to get December 31 of the\u000d\u000aprior year and then adding one to get to January 1 of the current year\u000d\u000a4. Adding one month to get to February 1\u000d\u000aThe result of all this math is shown here:\u000d\u000a select (current_date\u000d\u000a dayofyear(current_date) days +1 days) +1 months as dy\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-FEB-2005\u000d\u000aThe next step is to return the month of the date returned by inline view TMP1 by\u000d\u000ausing the MONTH function:\u000d\u000aselect dy, month(dy) as mth\u000d\u000a from (\u000d\u000aselect (current_date\u000d\u000a dayofyear(current_date) days +1 days) +1 months as dy\u000d\u000a from t1\u000d\u000a ) tmp1\u000d\u000aDY MTH\u000d\u000a----------- ---\u000d\u000a01-FEB-2005 2\u000d\u000aThe results presented thus far provide the start point for the recursive operation that\u000d\u000agenerates each day in February. To return each day in February, repeatedly add one\u000d\u000aday to DY until you are no longer in the month of February. A portion of the results\u000d\u000aof the WITH operation is shown here:\u000d\u000a with x (dy,mth)\u000d\u000a as (\u000d\u000aselect dy, month(dy)\u000d\u000a from (\u000d\u000aselect (current_date -\u000d\u000a dayofyear(current_date) days +1 days) +1 months as dy\u000d\u000a from t1\u000d\u000a ) tmp1\u000d\u000a union all\u000d\u000a select dy+1 days, mth\u000d\u000a from x\u000d\u000a where month(dy+1 day) = mth\u000d\u000a )\u000d\u000a select dy,mth\u000d\u000a from x\u000d\u000a242 | Chapter 9: Date Manipulation","DY MTH\u000d\u000a----------- ---\u000d\u000a01-FEB-2005 2\u000d\u000a\u2026\u000d\u000a10-FEB-2005 2\u000d\u000a\u2026\u000d\u000a28-FEB-2005 2\u000d\u000aThe final step is to use the MAX function on the DY column to return the last day in\u000d\u000aFebruary; if it is the 29th, you are in a leap year.\u000d\u000aOracle\u000d\u000aThe first step is to find the beginning of the year using the TRUNC function:\u000d\u000aselect trunc(sysdate,'y')\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000aBecause the first day of the year is January 1st, the next step is to add one month to\u000d\u000aget to February 1st:\u000d\u000aselect add_months(trunc(sysdate,'y'),1) dy\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-FEB-2005\u000d\u000aThe next step is to use the LAST_DAY function to find the last day in February:\u000d\u000aselect last_day(add_months(trunc(sysdate,'y'),1)) dy\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a28-FEB-2005\u000d\u000aThe final step (which is optional) is to use TO_CHAR to return either 28 or 29.\u000d\u000aPostgreSQL\u000d\u000aThe first step is to examine the results returned by inline view TMP1. Use the \u000d\u000aDATE_TRUNC function to find the beginning of the current year and cast that result\u000d\u000aas a DATE:\u000d\u000aselect cast(date_trunc('year',current_date) as date) as dy\u000d\u000a from t1\u000d\u000a9.1 Determining Whether a Year Is a Leap Year | 243","DY\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000aThe next step is to add one month to the first day of the current year to get the first\u000d\u000aday in February, casting the result as a date:\u000d\u000aselect cast(cast(\u000d\u000a date_trunc('year',current_date) as date)\u000d\u000a + interval '1 month' as date) as dy\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-FEB-2005\u000d\u000aNext, return DY from inline view TMP1 along with the numeric month of DY.\u000d\u000aReturn the numeric month by using the TO_CHAR function:\u000d\u000aselect dy, to_char(dy,'MM') as mth\u000d\u000a from (\u000d\u000a select cast(cast(\u000d\u000a date_trunc('year',current_date) as date)\u000d\u000a + interval '1 month' as date) as dy\u000d\u000a from t1\u000d\u000a ) tmp1\u000d\u000aDY MTH\u000d\u000a----------- ---\u000d\u000a01-FEB-2005 2\u000d\u000aThe results shown thus far comprise the result set of inline view TMP2. Your next\u000d\u000astep is to use the extremely useful function GENERATE_SERIES to return 29 rows\u000d\u000a(values 1 through 29). Every row returned by GENERATE_SERIES (aliased X) is\u000d\u000aadded to DY from inline view TMP2. Partial results are shown here:\u000d\u000aselect tmp2.dy+x.id as dy, tmp2.mth\u000d\u000a from (\u000d\u000aselect dy, to_char(dy,'MM') as mth\u000d\u000a from (\u000d\u000aselect cast(cast(\u000d\u000a date_trunc('year',current_date) as date)\u000d\u000a + interval '1 month' as date) as dy\u000d\u000a from t1\u000d\u000a ) tmp1\u000d\u000a ) tmp2, generate_series (0,29) x(id)\u000d\u000a where to_char(tmp2.dy+x.id,'MM') = tmp2.mth\u000d\u000aDY MTH\u000d\u000a----------- ---\u000d\u000a01-FEB-2005 02\u000d\u000a\u2026\u000d\u000a10-FEB-2005 02\u000d\u000a244 | Chapter 9: Date Manipulation","\u2026\u000d\u000a28-FEB-2005 02\u000d\u000aThe final step is to use the MAX function to return the last day in February. The\u000d\u000afunction TO_CHAR is applied to that value and will return either 28 or 29.\u000d\u000aMySQL\u000d\u000aThe first step is to find the first day of the current year by subtracting from the cur\u2010\u000d\u000arent date the number of days it is into the year and then adding one day. Do all of this\u000d\u000awith the DATE_ADD function:\u000d\u000aselect date_add(\u000d\u000a date_add(current_date,\u000d\u000a interval -dayofyear(current_date) day),\u000d\u000a interval 1 day) dy\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000aThen add one month again using the DATE_ADD function:\u000d\u000aselect date_add(\u000d\u000a date_add(\u000d\u000a date_add(current_date,\u000d\u000a interval -dayofyear(current_date) day),\u000d\u000a interval 1 day),\u000d\u000a interval 1 month) dy\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-FEB-2005\u000d\u000aNow that you\u2019ve made it to February, use the LAST_DAY function to find the last day\u000d\u000aof the month:\u000d\u000aselect last_day(\u000d\u000a date_add(\u000d\u000a date_add(\u000d\u000a date_add(current_date,\u000d\u000a interval -dayofyear(current_date) day),\u000d\u000a interval 1 day),\u000d\u000a interval 1 month)) dy\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a28-FEB-2005\u000d\u000a9.1 Determining Whether a Year Is a Leap Year | 245","The final step (which is optional) is to use the DAY function to return either a 28 or\u000d\u000a29.\u000d\u000aSQL Server\u000d\u000aWe can create a new date in most RDMSs by creating a string in a recognized date\u000d\u000aformat and using CAST to change format. We can therefore use the current year by\u000d\u000aretrieving the year from the current date. In SQL Server, this is done by applying\u000d\u000aYEAR to GET_DATE:\u000d\u000aselect YEAR(GETDATE());\u000d\u000aThis will return the year as an integer. We can then create 29th of February by using\u000d\u000aCONCAT and CAST:\u000d\u000aselect cast(concat\u000d\u000a (year(getdate()),'-02-29');\u000d\u000aHowever, this won\u2019t be a real date if the current year isn\u2019t a leap year. For example,\u000d\u000athere is no date 2019-02-29. Hence, if we try to use an operator like DAY to find any\u000d\u000aof its parts, it will return NULL. Therefore, use COALESCE and DAY to determine\u000d\u000awhether there is a 29th day in the month.\u000d\u000a9.2 Determining the Number of Days in a Year\u000d\u000aProblem\u000d\u000aYou want to count the number of days in the current year.\u000d\u000aSolution\u000d\u000aThe number of days in the current year is the difference between the first day of the\u000d\u000anext year and the first day of the current year (in days). For each solution the steps\u000d\u000aare:\u000d\u000a1. Find the first day of the current year.\u000d\u000a2. Add one year to that date (to get the first day of the next year).\u000d\u000a3. Subtract the current year from the result of Step 2.\u000d\u000aThe solutions differ only in the built-in functions that you use to perform these steps.\u000d\u000aDB2\u000d\u000aUse the function DAYOFYEAR to help find the first day of the current year, and use\u000d\u000aDAYS to find the number of days in the current year:\u000d\u000a246 | Chapter 9: Date Manipulation","1 select days((curr_year + 1 year)) - days(curr_year)\u000d\u000a2 from (\u000d\u000a3 select (current_date -\u000d\u000a4 dayofyear(current_date) day +\u000d\u000a5 1 day) curr_year\u000d\u000a6 from t1\u000d\u000a7 ) x\u000d\u000aOracle\u000d\u000aUse the function TRUNC to find the beginning of the current year, and use ADD_\u000d\u000aMONTHS to then find the beginning of next year:\u000d\u000a1 selectadd_months(trunc(sysdate,'y'),12) - trunc(sysdate,'y')\u000d\u000a2 from dual\u000d\u000aPostgreSQL\u000d\u000aUse the function DATE_TRUNC to find the beginning of the current year. Then use\u000d\u000ainterval arithmetic to determine the beginning of next year:\u000d\u000a1 select cast((curr_year + interval '1 year') as date) - curr_year\u000d\u000a2 from (\u000d\u000a3 select cast(date_trunc('year',current_date) as date) as curr_year\u000d\u000a4 from t1\u000d\u000a5 ) x\u000d\u000aMySQL\u000d\u000aUse ADDDATE to help find the beginning of the current year. Use DATEDIFF and\u000d\u000ainterval arithmetic to determine the number of days in the year:\u000d\u000a1 select datediff((curr_year + interval 1 year),curr_year)\u000d\u000a2 from (\u000d\u000a3 select adddate(current_date,-dayofyear(current_date)+1) curr_year\u000d\u000a4 from t1\u000d\u000a5 ) x\u000d\u000aSQL Server\u000d\u000aUse the function DATEADD to find the first day of the current year. Use DATEDIFF\u000d\u000ato return the number of days in the current year:\u000d\u000a1 select datediff(d,curr_year,dateadd(yy,1,curr_year))\u000d\u000a2 from (\u000d\u000a3 select dateadd(d,-datepart(dy,getdate())+1,getdate()) curr_year\u000d\u000a4 from t1\u000d\u000a5 ) x\u000d\u000a9.2 Determining the Number of Days in a Year | 247","Discussion\u000d\u000aDB2\u000d\u000aThe first step is to find the first day of the current year. Use DAYOFYEAR to deter\u2010\u000d\u000amine how many days you are into the current year. Subtract that value from the cur\u2010\u000d\u000arent date to get the last day of last year, and then add 1:\u000d\u000aselect (current_date\u000d\u000a dayofyear(current_date) day +\u000d\u000a 1 day) curr_year\u000d\u000a from t1\u000d\u000aCURR_YEAR\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000aNow that you have the first day of the current year, just add one year to it; this gives\u000d\u000ayou the first day of next year. Then subtract the beginning of the current year from\u000d\u000athe beginning of the next year.\u000d\u000aOracle\u000d\u000aThe first step is to find the first day of the current year, which you can easily do by\u000d\u000ainvoking the built-in TRUNC function and passing Y as the second argument\u000d\u000a(thereby truncating the date to the beginning of the year):\u000d\u000aselect select trunc(sysdate,'y') curr_year\u000d\u000a from dual\u000d\u000aCURR_YEAR\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000aThen add one year to arrive at the first day of the next year. Finally, subtract the two\u000d\u000adates to find the number of days in the current year.\u000d\u000aPostgreSQL\u000d\u000aBegin by finding the first day of the current year. To do that, invoke the DATE_\u000d\u000aTRUNC function as follows:\u000d\u000aselect cast(date_trunc('year',current_date) as date) as curr_year\u000d\u000a from t1\u000d\u000aCURR_YEAR\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000a248 | Chapter 9: Date Manipulation","You can then easily add a year to compute the first day of next year. Then all you need\u000d\u000ato do is to subtract the two dates. Be sure to subtract the earlier date from the later\u000d\u000adate. The result will be the number of days in the current year.\u000d\u000aMySQL\u000d\u000aYour first step is to find the first day of the current year. Use DAYOFYEAR to find\u000d\u000ahow many days you are into the current year. Subtract that value from the current\u000d\u000adate, and add one:\u000d\u000aselect adddate(current_date,-dayofyear(current_date)+1) curr_year\u000d\u000a from t1\u000d\u000aCURR_YEAR\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000aNow that you have the first day of the current year, your next step is to add one year\u000d\u000ato it to get the first day of next year. Then subtract the beginning of the current year\u000d\u000afrom the beginning of the next year. The result is the number of days in the current\u000d\u000ayear.\u000d\u000aSQL Server\u000d\u000aYour first step is to find the first day of the current year. Use DATEADD and DATE\u2010\u000d\u000aPART to subtract from the current date the number of days into the year the current\u000d\u000adate is, and add 1:\u000d\u000aselect dateadd(d,-datepart(dy,getdate())+1,getdate()) curr_year\u000d\u000a from t1\u000d\u000aCURR_YEAR\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000aNow that you have the first day of the current year, your next step is to add one year\u000d\u000ato it to get the first day of the next year. Then subtract the beginning of the current\u000d\u000ayear from the beginning of the next year. The result is the number of days in the cur\u2010\u000d\u000arent year.\u000d\u000a9.3 Extracting Units of Time from a Date\u000d\u000aProblem\u000d\u000aYou want to break the current date down into six parts: day, month, year, second,\u000d\u000aminute, and hour. You want the results to be returned as numbers.\u000d\u000a9.3 Extracting Units of Time from a Date | 249","Solution\u000d\u000aUse of the current date is arbitrary. Feel free to use this recipe with other dates. Most\u000d\u000avendors have now adopted the ANSI standard function for extracting parts of dates,\u000d\u000aEXTRACT, although SQL Server is an exception. They also retain their own legacy\u000d\u000amethods.\u000d\u000aDB2\u000d\u000aDB2 implements a set of built-in functions that make it easy for you to extract por\u2010\u000d\u000ations of a date. The function names HOUR, MINUTE, SECOND, DAY, MONTH,\u000d\u000aand YEAR conveniently correspond to the units of time you can return: if you want\u000d\u000athe day, use DAY; hour, use HOUR; etc. For example:\u000d\u000a 1 select hour( current_timestamp ) hr,\u000d\u000a 2 minute( current_timestamp ) min,\u000d\u000a 3 second( current_timestamp ) sec,\u000d\u000a 4 day( current_timestamp ) dy,\u000d\u000a 5 month( current_timestamp ) mth,\u000d\u000a 6 year( current_timestamp ) yr\u000d\u000a 7 from t1\u000d\u000aselect\u000d\u000a extract(hour from current_timestamp)\u000d\u000a , extract(minute from current_timestamp\u000d\u000a , extract(second from current_timestamp)\u000d\u000a , extract(day from current_timestamp)\u000d\u000a , extract(month from current_timestamp)\u000d\u000a , extract(year from current_timestamp)\u000d\u000a HR MIN SEC DY MTH YR\u000d\u000a ---- ----- ----- ----- ----- -----\u000d\u000a 20 28 36 15 6 2005\u000d\u000aOracle\u000d\u000aUse functions TO_CHAR and TO_NUMBER to return specific units of time from a\u000d\u000adate:\u000d\u000a1 select to_number(to_char(sysdate,'hh24')) hour,\u000d\u000a2 to_number(to_char(sysdate,'mi')) min,\u000d\u000a3 to_number(to_char(sysdate,'ss')) sec,\u000d\u000a4 to_number(to_char(sysdate,'dd')) day,\u000d\u000a5 to_number(to_char(sysdate,'mm')) mth,\u000d\u000a6 to_number(to_char(sysdate,'yyyy')) year\u000d\u000a7 from dual\u000d\u000a HOUR MIN SEC DAY MTH YEAR\u000d\u000a ---- ----- ----- ----- ----- -----\u000d\u000a 20 28 36 15 6 2005\u000d\u000a250 | Chapter 9: Date Manipulation","PostgreSQL\u000d\u000aUse functions TO_CHAR and TO_NUMBER to return specific units of time from a\u000d\u000adate:\u000d\u000a1 select to_number(to_char(current_timestamp,'hh24'),'99') as hr,\u000d\u000a2 to_number(to_char(current_timestamp,'mi'),'99') as min,\u000d\u000a3 to_number(to_char(current_timestamp,'ss'),'99') as sec,\u000d\u000a4 to_number(to_char(current_timestamp,'dd'),'99') as day,\u000d\u000a5 to_number(to_char(current_timestamp,'mm'),'99') as mth,\u000d\u000a6 to_number(to_char(current_timestamp,'yyyy'),'9999') as yr\u000d\u000a7 from t1\u000d\u000a HR MIN SEC DAY MTH YR\u000d\u000a ---- ----- ----- ----- ----- -----\u000d\u000a 20 28 36 15 6 2005\u000d\u000aMySQL\u000d\u000aUse the DATE_FORMAT function to return specific units of time from a date:\u000d\u000a1 select date_format(current_timestamp,'%k') hr,\u000d\u000a2 date_format(current_timestamp,'%i') min,\u000d\u000a3 date_format(current_timestamp,'%s') sec,\u000d\u000a4 date_format(current_timestamp,'%d') dy,\u000d\u000a5 date_format(current_timestamp,'%m') mon,\u000d\u000a6 date_format(current_timestamp,'%Y') yr\u000d\u000a7 from t1\u000d\u000a HR MIN SEC DAY MTH YR\u000d\u000a---- ----- ----- ----- ----- -----\u000d\u000a 20 28 36 15 6 2005\u000d\u000aSQL Server\u000d\u000aUse the function DATEPART to return specific units of time from a date:\u000d\u000a1 select datepart( hour, getdate()) hr,\u000d\u000a2 datepart( minute,getdate()) min,\u000d\u000a3 datepart( second,getdate()) sec,\u000d\u000a4 datepart( day, getdate()) dy,\u000d\u000a5 datepart( month, getdate()) mon,\u000d\u000a6 datepart( year, getdate()) yr\u000d\u000a7 from t1\u000d\u000a HR MIN SEC DAY MTH YR\u000d\u000a---- ----- ----- ----- ----- -----\u000d\u000a 20 28 36 15 6 2005\u000d\u000a9.3 Extracting Units of Time from a Date | 251","Discussion\u000d\u000aThere\u2019s nothing fancy in these solutions; just take advantage of what you\u2019re already\u000d\u000apaying for. Take the time to learn the date functions available to you. This recipe only\u000d\u000ascratches the surface of the functions presented in each solution. You\u2019ll find that each\u000d\u000aof the functions takes many more arguments and can return more information than\u000d\u000awhat this recipe provides you.\u000d\u000a9.4 Determining the First and Last Days of a Month\u000d\u000aProblem\u000d\u000aYou want to determine the first and last days for the current month.\u000d\u000aSolution\u000d\u000aThe solutions presented here are for finding first and last days for the current month.\u000d\u000aUsing the current month is arbitrary. With a bit of adjustment, you can make the sol\u2010\u000d\u000autions work for any month.\u000d\u000aDB2\u000d\u000aUse the DAY function to return the number of days into the current month the cur\u2010\u000d\u000arent date represents. Subtract this value from the current date, and then add one to\u000d\u000aget the first of the month. To get the last day of the month, add one month to the\u000d\u000acurrent date, and then subtract from it the value returned by the DAY function as\u000d\u000aapplied to the current date:\u000d\u000a1 select (date(current_date) - day(date(current_date)) day + 1 day) firstday,\u000d\u000a2 (date(current_date)+1 month\u000d\u000a3 - day(date(current_date)+1 month) day) lastday\u000d\u000a4 from t1\u000d\u000aOracle\u000d\u000aUse the function TRUNC to find the first of the month, and use the function\u000d\u000aLAST_DAY to find the last day of the month:\u000d\u000a1 select trunc(sysdate,'mm') firstday,\u000d\u000a2 last_day(sysdate) lastday\u000d\u000a3 from dual\u000d\u000aUsing TRUNC as described here will result in the loss of any timeof-day component, whereas LAST_DAY will preserve the time of\u000d\u000aday.\u000d\u000a252 | Chapter 9: Date Manipulation","PostgreSQL\u000d\u000aUse the DATE_TRUNC function to truncate the current date to the first of the cur\u2010\u000d\u000arent month. Once you have the first day of the month, add one month and subtract\u000d\u000aone day to find the end of the current month:\u000d\u000a 1 select firstday,\u000d\u000a 2 cast(firstday + interval '1 month'\u000d\u000a 3 - interval '1 day' as date) as lastday\u000d\u000a 4 from (\u000d\u000a 5 select cast(date_trunc('month',current_date) as date) as firstday\u000d\u000a 6 from t1\u000d\u000a 7 ) x\u000d\u000aMySQL\u000d\u000aUse the DATE_ADD and DAY functions to find the number of days into the month\u000d\u000athe current date is. Then subtract that value from the current date and add one to find\u000d\u000athe first of the month. To find the last day of the current month, use the LAST_DAY\u000d\u000afunction:\u000d\u000a1 select date_add(current_date,\u000d\u000a2 interval -day(current_date)+1 day) firstday,\u000d\u000a3 last_day(current_date) lastday\u000d\u000a4 from t1\u000d\u000aSQL Server\u000d\u000aUse the DATEADD and DAY functions to find the number of days into the month\u000d\u000arepresented by the current date. Then subtract that value from the current date and\u000d\u000aadd one to find the first of the month. To get the last day of the month, add one\u000d\u000amonth to the current date, and then subtract from that result the value returned by\u000d\u000athe DAY function applied to the current date, again using the functions DAY and\u000d\u000aDATEADD:\u000d\u000a1 select dateadd(day,-day(getdate())+1,getdate()) firstday,\u000d\u000a2 dateadd(day,\u000d\u000a3 -day(dateadd(month,1,getdate())),\u000d\u000a4 dateadd(month,1,getdate())) lastday\u000d\u000a5 from t1\u000d\u000aDiscussion\u000d\u000aDB2\u000d\u000aTo find the first day of the month, simply find the numeric value of the current day of\u000d\u000athe month, and then subtract this from the current date. For example, if the date is\u000d\u000aMarch 14th, the numeric day value is 14. Subtracting 14 days from March 14th gives\u000d\u000ayou the last day of the month in February. From there, simply add one day to get to\u000d\u000a9.4 Determining the First and Last Days of a Month | 253","the first of the current month. The technique to get the last day of the month is simi\u2010\u000d\u000alar to that of the first: subtract the numeric day of the month from the current date to\u000d\u000aget the last day of the prior month. Since we want the last day of the current month\u000d\u000a(not the last day of the prior month), we need to add one month to the current date.\u000d\u000aOracle\u000d\u000aTo find the first day of the current month, use the TRUNC function with \u201cmm\u201d as the\u000d\u000asecond argument to \u201ctruncate\u201d the current date down to the first of the month. To\u000d\u000afind the last day of the current month, simply use the LAST_DAY function.\u000d\u000aPostgreSQL\u000d\u000aTo find the first day of the current month, use the DATE_TRUNC function with\u000d\u000a\u201cmonth\u201d as the second argument to \u201ctruncate\u201d the current date down to the first of\u000d\u000athe month. To find the last day of the current month, add one month to the first day\u000d\u000aof the month, and then subtract one day.\u000d\u000aMySQL\u000d\u000aTo find the first day of the month, use the DAY function. The DAY function returns\u000d\u000athe day of the month for the date passed. If you subtract the value returned by\u000d\u000aDAY(CURRENT_DATE) from the current date, you get the last day of the prior\u000d\u000amonth; add one day to get the first day of the current month. To find the last day of\u000d\u000athe current month, simply use the LAST_DAY function.\u000d\u000aSQL Server\u000d\u000aTo find the first day of the month, use the DAY function. The DAY function conven\u2010\u000d\u000aiently returns the day of the month for the date passed. If you subtract the value\u000d\u000areturned by DAY(GETDATE()) from the current date, you get the last day of the\u000d\u000aprior month; add one day to get the first day of the current month. To find the last\u000d\u000aday of the current month, use the DATEADD function. Add one month to the cur\u2010\u000d\u000arent date, then subtract from it the value returned by DAY(GETDATE()) to get the\u000d\u000alast day of the current month. Add one month to the current date, and then subtract\u000d\u000afrom it the value returned by DAY(DATEADD(MONTH,1,GETDATE())) to get the\u000d\u000alast day of the current month.\u000d\u000a254 | Chapter 9: Date Manipulation","9.5 Determining All Dates for a Particular Weekday\u000d\u000aThroughout a Year\u000d\u000aProblem\u000d\u000aYou want to find all the dates in a year that correspond to a given day of the week. For\u000d\u000aexample, you may want to generate a list of Fridays for the current year.\u000d\u000aSolution\u000d\u000aRegardless of vendor, the key to the solution is to return each day for the current year\u000d\u000aand keep only those dates corresponding to the day of the week that you care about.\u000d\u000aThe solution examples retain all the Fridays.\u000d\u000aDB2\u000d\u000aUse the recursive WITH clause to return each day in the current year. Then use the\u000d\u000afunction DAYNAME to keep only Fridays:\u000d\u000a 1 with x (dy,yr)\u000d\u000a 2 as (\u000d\u000a 3 select dy, year(dy) yr\u000d\u000a 4 from (\u000d\u000a 5 select (current_date -\u000d\u000a 6 dayofyear(current_date) days +1 days) as dy\u000d\u000a 7 from t1\u000d\u000a 8 ) tmp1\u000d\u000a 9 union all\u000d\u000a 10 select dy+1 days, yr\u000d\u000a 11 from x\u000d\u000a 12 where year(dy +1 day) = yr\u000d\u000a 13 )\u000d\u000a 14 select dy\u000d\u000a 15 from x\u000d\u000a 16 where dayname(dy) = 'Friday'\u000d\u000aOracle\u000d\u000aUse the recursive CONNECT BY clause to return each day in the current year. Then\u000d\u000ause the function TO_CHAR to keep only Fridays:\u000d\u000a1 with x\u000d\u000a2 as (\u000d\u000a3 select trunc(sysdate,'y')+level-1 dy\u000d\u000a4 from t1\u000d\u000a5 connect by level <=\u000d\u000a6 add_months(trunc(sysdate,'y'),12)-trunc(sysdate,'y')\u000d\u000a7 )\u000d\u000a8 select *\u000d\u000a9.5 Determining All Dates for a Particular Weekday Throughout a Year | 255","9 from x\u000d\u000a10 where to_char( dy, 'dy') = 'fri'\u000d\u000aPostgreSQL\u000d\u000aUse a recursive CTE to generate every day of the year, and filter out days that aren\u2019t\u000d\u000aFridays. This version makes use of the ANSI standard EXTRACT, so it will run on a\u000d\u000awide variety of RDBMs:\u000d\u000a1 with recursive cal (dy)\u000d\u000a2 as (\u000d\u000a3 select current_date\u000d\u000a4 -(cast\u000d\u000a5 (extract(doy from current_date) as integer)\u000d\u000a6 -1)\u000d\u000a7 union all\u000d\u000a8 select dy+1\u000d\u000a9 from cal\u000d\u000a10 where extract(year from dy)=extract(year from (dy+1))\u000d\u000a11 )\u000d\u000a12\u000d\u000a13 select dy,extract(dow from dy) from cal\u000d\u000a14 where cast(extract(dow from dy) as integer) = 6\u000d\u000aMySQL\u000d\u000aUse a recursive CTE to find all the days in the year. Then filter all days but Fridays:\u000d\u000a1 with recursive cal (dy,yr)\u000d\u000a2 as\u000d\u000a3 (\u000d\u000a4 select dy, extract(year from dy) as yr\u000d\u000a5 from\u000d\u000a6 (select adddate\u000d\u000a7 (adddate(current_date, interval - dayofyear(current_date)\u000d\u000a8 day), interval 1 day) as dy) as tmp1\u000d\u000a9 union all\u000d\u000a10 select date_add(dy, interval 1 day), yr\u000d\u000a11 from cal\u000d\u000a12 where extract(year from date_add(dy, interval 1 day)) = yr\u000d\u000a13 )\u000d\u000a14 select dy from cal\u000d\u000a15 where dayofweek(dy) = 6\u000d\u000aSQL Server\u000d\u000aUse the recursive WITH clause to return each day in the current year. Then use the\u000d\u000afunction DAYNAME to keep only Fridays:\u000d\u000a 1 with x (dy,yr)\u000d\u000a 2 as (\u000d\u000a 3 select dy, year(dy) yr\u000d\u000a256 | Chapter 9: Date Manipulation"," 4 from (\u000d\u000a 5 select getdate()-datepart(dy,getdate())+1 dy\u000d\u000a 6 from t1\u000d\u000a 7 ) tmp1\u000d\u000a 8 union all\u000d\u000a 9 select dateadd(dd,1,dy), yr\u000d\u000a10 from x\u000d\u000a11 where year(dateadd(dd,1,dy)) = yr\u000d\u000a12 )\u000d\u000a13 select x.dy\u000d\u000a14 from x\u000d\u000a15 where datename(dw,x.dy) = 'Friday'\u000d\u000a16 option (maxrecursion 400)\u000d\u000aDiscussion\u000d\u000aDB2\u000d\u000aTo find all the Fridays in the current year, you must be able to return every day in the\u000d\u000acurrent year. The first step is to find the first day of the year by using the DAYOF\u2010\u000d\u000aYEAR function. Subtract the value returned by DAYOFYEAR(CURRENT_DATE)\u000d\u000afrom the current date to get December 31 of the prior year, and then add one to get\u000d\u000athe first day of the current year:\u000d\u000aselect (current_date\u000d\u000a dayofyear(current_date) days +1 days) as dy\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000aNow that you have the first day of the year, use the WITH clause to repeatedly add\u000d\u000aone day to the first day of the year until you are no longer in the current year. The\u000d\u000aresult set will be every day in the current year (a portion of the rows returned by the\u000d\u000arecursive view X is shown here):\u000d\u000a with x (dy,yr)\u000d\u000a as (\u000d\u000aselect dy, year(dy) yr\u000d\u000a from (\u000d\u000aselect (current_date\u000d\u000a dayofyear(current_date) days +1 days) as dy\u000d\u000a from t1\u000d\u000a ) tmp1\u000d\u000aunion all\u000d\u000aselect dy+1 days, yr\u000d\u000a from x\u000d\u000a where year(dy +1 day) = yr\u000d\u000a)\u000d\u000aselect dy\u000d\u000a9.5 Determining All Dates for a Particular Weekday Throughout a Year | 257"," from x\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-JAN-2020\u000d\u000a\u2026\u000d\u000a15-FEB-2020\u000d\u000a\u2026\u000d\u000a22-NOV-2020\u000d\u000a\u2026\u000d\u000a31-DEC-2020\u000d\u000aThe final step is to use the DAYNAME function to keep only rows that are Fridays.\u000d\u000aOracle\u000d\u000aTo find all the Fridays in the current year, you must be able to return every day in the\u000d\u000acurrent year. Begin by using the TRUNC function to find the first day of the year:\u000d\u000aselect trunc(sysdate,'y') dy\u000d\u000a from t1\u000d\u000a DY\u000d\u000a -----------\u000d\u000a 01-JAN-2020\u000d\u000aNext, use the CONNECT BY clause to return every day in the current year (to under\u2010\u000d\u000astand how to use CONNECT BY to generate rows, see Recipe 10.5).\u000d\u000aAs an aside, this recipe uses the WITH clause, but you can also use\u000d\u000aan inline view.\u000d\u000aA portion of the result set returned by view X is shown here:\u000d\u000a with x\u000d\u000a as (\u000d\u000aselect trunc(sysdate,'y')+level-1 dy\u000d\u000afrom t1\u000d\u000a connect by level <=\u000d\u000a add_months(trunc(sysdate,'y'),12)-trunc(sysdate,'y')\u000d\u000a)\u000d\u000aselect *\u000d\u000afrom x\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-JAN-2020\u000d\u000a\u2026\u000d\u000a15-FEB-2020\u000d\u000a258 | Chapter 9: Date Manipulation","\u2026\u000d\u000a22-NOV-2020\u000d\u000a\u2026\u000d\u000a31-DEC-2020\u000d\u000aThe final step is to use the TO_CHAR function to keep only Fridays.\u000d\u000aPostgreSQL\u000d\u000aTo find the Fridays, first find all the days. You need to find the first day of the year,\u000d\u000aand then use the recursive CTE to fill in the rest of the days. Remember PostgreSQL\u000d\u000ais one of the packages that requires the use of the RECURSIVE keyword to identify a\u000d\u000arecursive CTE.\u000d\u000aThe final step is to use the TO_CHAR function to keep only the Fridays.\u000d\u000aMySQL\u000d\u000aTo find all the Fridays in the current year, you must be able to return every day in the\u000d\u000acurrent year. The first step is to find the first day of the year. Subtract the value\u000d\u000areturned by DAYOFYEAR(CURRENT_DATE) from the current date, and then add\u000d\u000aone to get the first day of the current year:\u000d\u000aselect adddate(\u000d\u000a adddate(current_date,\u000d\u000a interval -dayofyear(current_date) day),\u000d\u000a interval 1 day ) dy\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-JAN-2020\u000d\u000aOnce you\u2019ve got the first day of the year, it\u2019s simple to use a recursive CTE to add\u000d\u000aevery day of the year:\u000d\u000awith cal (dy) as\u000d\u000a(select current\u000d\u000aunion all\u000d\u000aselect dy+1\u000d\u000a DY\u000d\u000a -----------\u000d\u000a 01-JAN-2020\u000d\u000a \u2026\u000d\u000a 15-FEB-2020\u000d\u000a \u2026\u000d\u000a 22-NOV-2020\u000d\u000a \u2026\u000d\u000a 31-DEC-2020\u000d\u000a9.5 Determining All Dates for a Particular Weekday Throughout a Year | 259","The final step is to use the DAYNAME function to keep only Fridays.\u000d\u000aSQL Server\u000d\u000aTo find all the Fridays in the current year, you must be able to return every day in the\u000d\u000acurrent year. The first step is to find the first day of the year by using the DATEPART \u000d\u000afunction. Subtract the value returned by DATEPART(DY,GETDATE()) from the cur\u2010\u000d\u000arent date, and then add one to get the first day of the current year:\u000d\u000aselect getdate()-datepart(dy,getdate())+1 dy\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-JAN-2005\u000d\u000aNow that you have the first day of the year, use the WITH clause and the DATEADD\u000d\u000afunction to repeatedly add one day to the first day of the year until you are no longer\u000d\u000ain the current year. The result set will be every day in the current year (a portion of\u000d\u000athe rows returned by the recursive view X is shown here):\u000d\u000awith x (dy,yr)\u000d\u000a as (\u000d\u000aselect dy, year(dy) yr\u000d\u000a from (\u000d\u000aselect getdate()-datepart(dy,getdate())+1 dy\u000d\u000a from t1\u000d\u000a ) tmp1\u000d\u000a union all\u000d\u000aselect dateadd(dd,1,dy), yr\u000d\u000a from x\u000d\u000a where year(dateadd(dd,1,dy)) = yr\u000d\u000a)\u000d\u000aselect x.dy\u000d\u000a from x\u000d\u000aoption (maxrecursion 400)\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-JAN-2020\u000d\u000a\u2026\u000d\u000a15-FEB-2020\u000d\u000a\u2026\u000d\u000a22-NOV-2020\u000d\u000a\u2026\u000d\u000a31-DEC-2020\u000d\u000aFinally, use the DATENAME function to keep only rows that are Fridays. For this sol\u2010\u000d\u000aution to work, you must set MAXRECURSION to at least 366 (the filter on the year\u000d\u000aportion of the current year, in recursive view X, guarantees you will never generate\u000d\u000amore than 366 rows).\u000d\u000a260 | Chapter 9: Date Manipulation","9.6 Determining the Date of the First and Last\u000d\u000aOccurrences of a Specific Weekday in a Month\u000d\u000aProblem\u000d\u000aYou want to find, for example, the first and last Mondays of the current month.\u000d\u000aSolution\u000d\u000aThe choice to use Monday and the current month is arbitrary; you can use the solu\u2010\u000d\u000ations presented in this recipe for any weekday and any month. Because each weekday\u000d\u000ais 7 days apart from itself, once you have the first instance of a weekday, you can add\u000d\u000a7 days to get the second and 14 days to get the third. Likewise, if you have the last\u000d\u000ainstance of a weekday in a month, you can subtract 7 days to get the third and sub\u2010\u000d\u000atract 14 days to get the second.\u000d\u000aDB2\u000d\u000aUse the recursive WITH clause to generate each day in the current month and use a\u000d\u000aCASE expression to flag all Mondays. The first and last Mondays will be the earliest\u000d\u000aand latest of the flagged dates:\u000d\u000a 1 with x (dy,mth,is_monday)\u000d\u000a 2 as (\u000d\u000a 3 select dy,month(dy),\u000d\u000a 4 case when dayname(dy)='Monday'\u000d\u000a 5 then 1 else 0\u000d\u000a 6 end\u000d\u000a 7 from (\u000d\u000a 8 select (current_date-day(current_date) day +1 day) dy\u000d\u000a 9 from t1\u000d\u000a10 ) tmp1\u000d\u000a11 union all\u000d\u000a12 select (dy +1 day), mth,\u000d\u000a13 case when dayname(dy +1 day)='Monday'\u000d\u000a14 then 1 else 0\u000d\u000a15 end\u000d\u000a16 from x\u000d\u000a17 where month(dy +1 day) = mth\u000d\u000a18 )\u000d\u000a19 select min(dy) first_monday, max(dy) last_monday\u000d\u000a20 from x\u000d\u000a21 where is_monday = 1\u000d\u000aOracle\u000d\u000aUse the functions NEXT_DAY and LAST_DAY, together with a bit of clever date\u000d\u000aarithmetic, to find the first and last Mondays of the current month:\u000d\u000a9.6 Determining the Date of the First and Last Occurrences of a Specific Weekday in a Month | 261","select next_day(trunc(sysdate,'mm')-1,'MONDAY') first_monday,\u000d\u000a next_day(last_day(trunc(sysdate,'mm'))-7,'MONDAY') last_monday\u000d\u000a from dual\u000d\u000aPostgreSQL\u000d\u000aUse the function DATE_TRUNC to find the first day of the month. Once you have\u000d\u000athe first day of the month, you can use simple arithmetic involving the numeric val\u2010\u000d\u000aues of weekdays (Sun\u2013Sat is 1\u20137) to find the first and last Mondays of the current\u000d\u000amonth:\u000d\u000a 1 select first_monday,\u000d\u000a 2 case to_char(first_monday+28,'mm')\u000d\u000a 3 when mth then first_monday+28\u000d\u000a 4 else first_monday+21\u000d\u000a 5 end as last_monday\u000d\u000a 6 from (\u000d\u000a 7 select case sign(cast(to_char(dy,'d') as integer)-2)\u000d\u000a 8 when 0\u000d\u000a 9 then dy\u000d\u000a10 when -1\u000d\u000a11 then dy+abs(cast(to_char(dy,'d') as integer)-2)\u000d\u000a12 when 1\u000d\u000a13 then (7-(cast(to_char(dy,'d') as integer)-2))+dy\u000d\u000a14 end as first_monday,\u000d\u000a15 mth\u000d\u000a16 from (\u000d\u000a17 select cast(date_trunc('month',current_date) as date) as dy,\u000d\u000a18 to_char(current_date,'mm') as mth\u000d\u000a19 from t1\u000d\u000a20 ) x\u000d\u000a21 ) y\u000d\u000aMySQL\u000d\u000aUse the ADDDATE function to find the first day of the month. Once you have the\u000d\u000afirst day of the month, you can use simple arithmetic on the numeric values of week\u2010\u000d\u000adays (Sun\u2013Sat is 1\u20137) to find the first and last Mondays of the current month:\u000d\u000a 1 select first_monday,\u000d\u000a 2 case month(adddate(first_monday,28))\u000d\u000a 3 when mth then adddate(first_monday,28)\u000d\u000a 4 else adddate(first_monday,21)\u000d\u000a 5 end last_monday\u000d\u000a 6 from (\u000d\u000a 7 select case sign(dayofweek(dy)-2)\u000d\u000a 8 when 0 then dy\u000d\u000a 9 when -1 then adddate(dy,abs(dayofweek(dy)-2))\u000d\u000a10 when 1 then adddate(dy,(7-(dayofweek(dy)-2)))\u000d\u000a11 end first_monday,\u000d\u000a12 mth\u000d\u000a13 from (\u000d\u000a262 | Chapter 9: Date Manipulation","14 select adddate(adddate(current_date,-day(current_date)),1) dy,\u000d\u000a15 month(current_date) mth\u000d\u000a16 from t1\u000d\u000a17 ) x\u000d\u000a18 ) y\u000d\u000aSQL Server\u000d\u000aUse the recursive WITH clause to generate each day in the current month, and then\u000d\u000ause a CASE expression to flag all Mondays. The first and last Mondays will be the ear\u2010\u000d\u000aliest and latest of the flagged dates:\u000d\u000a 1 with x (dy,mth,is_monday)\u000d\u000a 2 as (\u000d\u000a 3 select dy,mth,\u000d\u000a 4 case when datepart(dw,dy) = 2\u000d\u000a 5 then 1 else 0\u000d\u000a 6 end\u000d\u000a 7 from (\u000d\u000a 8 select dateadd(day,1,dateadd(day,-day(getdate()),getdate())) dy,\u000d\u000a 9 month(getdate()) mth\u000d\u000a10 from t1\u000d\u000a11 ) tmp1\u000d\u000a12 union all\u000d\u000a13 select dateadd(day,1,dy),\u000d\u000a14 mth,\u000d\u000a15 case when datepart(dw,dateadd(day,1,dy)) = 2\u000d\u000a16 then 1 else 0\u000d\u000a17 end\u000d\u000a18 from x\u000d\u000a19 where month(dateadd(day,1,dy)) = mth\u000d\u000a20 )\u000d\u000a21 select min(dy) first_monday,\u000d\u000a22 max(dy) last_monday\u000d\u000a23 from x\u000d\u000a24 where is_monday = 1\u000d\u000aDiscussion\u000d\u000aDB2 and SQL Server\u000d\u000aDB2 and SQL Server use different functions to solve this problem, but the technique\u000d\u000ais exactly the same. If you eyeball both solutions, you\u2019ll see the only difference\u000d\u000abetween the two is the way dates are added. This discussion will cover both solutions,\u000d\u000ausing the DB2 solution\u2019s code to show the results of intermediate steps.\u000d\u000a9.6 Determining the Date of the First and Last Occurrences of a Specific Weekday in a Month | 263","If you do not have access to the recursive WITH clause in the ver\u2010\u000d\u000asion of SQL Server or DB2 that you are running, you can use the\u000d\u000aPostgreSQL technique instead.\u000d\u000aThe first step in finding the first and last Mondays of the current month is to return\u000d\u000athe first day of the month. Inline view TMP1 in recursive view X finds the first day of\u000d\u000athe current month by first finding the current date, specifically, the day of the month\u000d\u000afor the current date. The day of the month for the current date represents how many\u000d\u000adays into the month you are (e.g., April 10th is the 10th day of the April). If you sub\u2010\u000d\u000atract this day of the month value from the current date, you end up at the last day of\u000d\u000athe previous month (e.g., subtracting 10 from April 10th puts you at the last day of\u000d\u000aMarch). After this subtraction, simply add one day to arrive at the first day of the cur\u2010\u000d\u000arent month:\u000d\u000aselect (current_date-day(current_date) day +1 day) dy\u000d\u000a from t1\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-JUN-2005\u000d\u000aNext, find the month for the current date using the MONTH function and a simple\u000d\u000aCASE expression to determine whether the first day of the month is a Monday:\u000d\u000aselect dy, month(dy) mth,\u000d\u000a case when dayname(dy)='Monday'\u000d\u000a then 1 else 0\u000d\u000a end is_monday\u000d\u000a from (\u000d\u000aselect (current_date-day(current_date) day +1 day) dy\u000d\u000a from t1\u000d\u000a ) tmp1\u000d\u000aDY MTH IS_MONDAY\u000d\u000a----------- --- ----------\u000d\u000a01-JUN-2005 6 0\u000d\u000aThen use the recursive capabilities of the WITH clause to repeatedly add one day to\u000d\u000athe first day of the month until you\u2019re no longer in the current month. Along the way,\u000d\u000ayou will use a CASE expression to determine which days in the month are Mondays\u000d\u000a(Mondays will be flagged with 1). A portion of the output from recursive view X is\u000d\u000ashown here:\u000d\u000awith x (dy,mth,is_monday)\u000d\u000a as (\u000d\u000a select dy,month(dy) mth,\u000d\u000a case when dayname(dy)='Monday'\u000d\u000a then 1 else 0\u000d\u000a264 | Chapter 9: Date Manipulation"," end is_monday\u000d\u000a from (\u000d\u000a select (current_date-day(current_date) day +1 day) dy\u000d\u000a from t1\u000d\u000a ) tmp1\u000d\u000a union all\u000d\u000a select (dy +1 day), mth,\u000d\u000a case when dayname(dy +1 day)='Monday'\u000d\u000a then 1 else 0\u000d\u000a end\u000d\u000a from x\u000d\u000a where month(dy +1 day) = mth\u000d\u000a )\u000d\u000a select *\u000d\u000a from x\u000d\u000aDY MTH IS_MONDAY\u000d\u000a----------- --- ----------\u000d\u000a01-JUN-2005 6 0\u000d\u000a02-JUN-2005 6 0\u000d\u000a03-JUN-2005 6 0\u000d\u000a04-JUN-2005 6 0\u000d\u000a05-JUN-2005 6 0\u000d\u000a06-JUN-2005 6 1\u000d\u000a07-JUN-2005 6 0\u000d\u000a08-JUN-2005 6 0\u000d\u000a\u2026\u000d\u000aOnly Mondays will have a value of 1 for IS_MONDAY, so the final step is to use the\u000d\u000aaggregate functions MIN and MAX on rows where IS_MONDAY is 1 to find the first\u000d\u000aand last Mondays of the month.\u000d\u000aOracle\u000d\u000aThe function NEXT_DAY makes this problem easy to solve. To find the first Monday\u000d\u000aof the current month, first return the last day of the prior month via some date arith\u2010\u000d\u000ametic involving the TRUNC function:\u000d\u000aselect trunc(sysdate,'mm')-1 dy\u000d\u000a from dual\u000d\u000aDY\u000d\u000a-----------\u000d\u000a31-MAY-2005\u000d\u000aThen use the NEXT_DAY function to find the first Monday that comes after the last\u000d\u000aday of the previous month (i.e., the first Monday of the current month):\u000d\u000aselect next_day(trunc(sysdate,'mm')-1,'MONDAY') first_monday\u000d\u000a from dual\u000d\u000a9.6 Determining the Date of the First and Last Occurrences of a Specific Weekday in a Month | 265","FIRST_MONDAY\u000d\u000a------------\u000d\u000a06-JUN-2005\u000d\u000aTo find the last Monday of the current month, start by returning the first day of the\u000d\u000acurrent month by using the TRUNC function:\u000d\u000aselect trunc(sysdate,'mm') dy\u000d\u000a from dual\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-JUN-2005\u000d\u000aThe next step is to find the last week (the last seven days) of the month. Use the \u000d\u000aLAST_DAY function to find the last day of the month, and then subtract seven days:\u000d\u000aselect last_day(trunc(sysdate,'mm'))-7 dy\u000d\u000a from dual\u000d\u000aDY\u000d\u000a-----------\u000d\u000a23-JUN-2005\u000d\u000aIf it isn\u2019t immediately obvious, you go back seven days from the last day of the month\u000d\u000ato ensure that you will have at least one of any weekday left in the month. The last\u000d\u000astep is to use the function NEXT_DAY to find the next (and last) Monday of the\u000d\u000amonth:\u000d\u000aselect next_day(last_day(trunc(sysdate,'mm'))-7,'MONDAY') last_monday\u000d\u000a from dual\u000d\u000aLAST_MONDAY\u000d\u000a-----------\u000d\u000a27-JUN-2005\u000d\u000aPostgreSQL and MySQL\u000d\u000aPostgreSQL and MySQL also share the same solution approach. The difference is in\u000d\u000athe functions that you invoke. Despite their lengths, the respective queries are\u000d\u000aextremely simple; little overhead is involved in finding the first and last Mondays of\u000d\u000athe current month.\u000d\u000aThe first step is to find the first day of the current month. The next step is to find the\u000d\u000afirst Monday of the month. Since there is no function to find the next date for a given\u000d\u000aweekday, you need to use a little arithmetic. The CASE expression beginning on line\u000d\u000a7 (of either solution) evaluates the difference between the numeric value for the\u000d\u000aweekday of the first day of the month and the numeric value corresponding to Mon\u2010\u000d\u000aday. Given that the function TO_CHAR (PostgreSQL), when called with the D or d\u000d\u000aformat, and the function DAYOFWEEK (MySQL) will return a numeric value from 1\u000d\u000ato 7 representing days Sunday to Saturday, Monday is always represented by 2. The\u000d\u000a266 | Chapter 9: Date Manipulation","first test evaluated by CASE is the SIGN of the numeric value of the first day of the\u000d\u000amonth (whatever it may be) minus the numeric value of Monday (2). If the result is\u000d\u000azero, then the first day of the month falls on a Monday, and that is the first Monday of\u000d\u000athe month. If the result is \u20131, then the first day of the month falls on a Sunday, and to\u000d\u000afind the first Monday of the month, simply add the difference in days between 2 and 1\u000d\u000a(numeric values of Monday and Sunday, respectively) to the first day of the month.\u000d\u000aIf you are having trouble understanding how this works, forget the\u000d\u000aweekday names and just do the math. For example, say you happen\u000d\u000ato be starting on a Tuesday and you are looking for the next Friday. \u000d\u000aWhen using TO_CHAR with the d format, or DAYOFWEEK, Fri\u2010\u000d\u000aday is 6 and Tuesday is 3. To get to 6 from 3, simply take the differ\u2010\u000d\u000aence (6\u20133 = 3) and add it to the smaller value ((6\u20133) + 3 = 6). So,\u000d\u000aregardless of the actual dates, if the numeric value of the day you\u000d\u000aare starting from is less than the numeric value of the day you are\u000d\u000asearching for, adding the difference between the two dates to the\u000d\u000adate you are starting from will get you to the date you are searching\u000d\u000afor.\u000d\u000aIf the result from SIGN is 1, then the first day of the month falls between Tuesday and\u000d\u000aSaturday (inclusive). When the first day of the month has a numeric value greater\u000d\u000athan 2 (Monday), subtract from 7 the difference between the numeric value of the\u000d\u000afirst day of the month and the numeric value of Monday (2), and then add that value\u000d\u000ato the first day of the month. You will have arrived at the day of the week that you are\u000d\u000aafter, in this case Monday.\u000d\u000aAgain, if you are having trouble understanding how this works,\u000d\u000aforget the weekday names and just do the math. For example, sup\u2010\u000d\u000apose you want to find the next Tuesday and you are starting from\u000d\u000aFriday. Tuesday (3) is less than Friday (6). To get to 3 from 6, sub\u2010\u000d\u000atract the difference between the two values from 7 (7\u2013( |3\u20136| ) = 4)\u000d\u000aand add the result (4) to the start day Friday. (The vertical bars in |\u000d\u000a3\u20136| generate the absolute value of that difference.) Here, you\u2019re\u000d\u000anot adding 4 to 6 (which will give you 10); you are adding four days\u000d\u000ato Friday, which will give you the next Tuesday.\u000d\u000aThe idea behind the CASE expression is to create a sort of a \u201cnext day\u201d function for\u000d\u000aPostgreSQL and MySQL. If you do not start with the first day of the month, the value\u000d\u000afor DY will be the value returned by CURRENT_DATE, and the result of the CASE\u000d\u000aexpression will return the date of the next Monday starting from the current date\u000d\u000a(unless CURRENT_DATE is a Monday, then that date will be returned).\u000d\u000a9.6 Determining the Date of the First and Last Occurrences of a Specific Weekday in a Month | 267","Now that you have the first Monday of the month, add either 21 or 28 days to find the\u000d\u000alast Monday of the month. The CASE expression in lines 2\u20135 determines whether to\u000d\u000aadd 21 or 28 days by checking to see whether 28 days takes you into the next month.\u000d\u000aThe CASE expression does this through the following process:\u000d\u000a1. It adds 28 to the value of FIRST_MONDAY.\u000d\u000a2. Using either TO_CHAR (PostgreSQL) or MONTH, the CASE expression\u000d\u000aextracts the name of the current month from the result of FIRST_MONDAY +\u000d\u000a28.\u000d\u000a3. The result from step two is compared to the value MTH from the inline view.\u000d\u000aThe value MTH is the name of the current month as derived from CURRENT_\u000d\u000aDATE. If the 2 month values match, then the month is large enough for you to\u000d\u000aneed to add 28 days, and the CASE expression returns FIRST_MONDAY + 28. If\u000d\u000athe two month values do not match, then you do not have room to add 28 days,\u000d\u000aand the CASE expression returns FIRST_MONDAY + 21 days instead. It is con\u2010\u000d\u000avenient that our months are such that 28 and 21 are the only two possible values\u000d\u000ayou need worry about adding.\u000d\u000aYou can extend the solution by adding 7 and 14 days to find the\u000d\u000asecond and third Mondays of the month, respectively.\u000d\u000a9.7 Creating a Calendar\u000d\u000aProblem\u000d\u000aYou want to create a calendar for the current month. The calendar should be format\u2010\u000d\u000ated like a calendar you might have on your desk: seven columns across and (usually)\u000d\u000afive rows down.\u000d\u000aSolution\u000d\u000aEach solution will look a bit different, but they all solve the problem the same way:\u000d\u000areturn each day for the current month, and then pivot on the day of the week for each\u000d\u000aweek in the month to create a calendar.\u000d\u000aThere are different formats available for calendars. For example, the Unix CAL com\u2010\u000d\u000amand formats the days from Sunday to Saturday. The examples in this recipe are\u000d\u000abased on ISO weeks, so the Monday through Friday format is the most convenient to\u000d\u000agenerate. Once you become comfortable with the solutions, you\u2019ll see that\u000d\u000a268 | Chapter 9: Date Manipulation","reformatting however you like is simply a matter of modifying the values assigned by\u000d\u000athe ISO week before pivoting.\u000d\u000aAs you begin to use different types of formatting with SQL to cre\u2010\u000d\u000aate readable output, you will notice your queries becoming longer.\u000d\u000aDon\u2019t let those long queries intimidate you; the queries presented\u000d\u000afor this recipe are extremely simple once broken down and run\u000d\u000apiece by piece.\u000d\u000aDB2\u000d\u000aUse the recursive WITH clause to return every day in the current month. Then pivot\u000d\u000aon the day of the week using CASE and MAX:\u000d\u000a 1 with x(dy,dm,mth,dw,wk)\u000d\u000a 2 as (\u000d\u000a 3 select (current_date -day(current_date) day +1 day) dy,\u000d\u000a 4 day((current_date -day(current_date) day +1 day)) dm,\u000d\u000a 5 month(current_date) mth,\u000d\u000a 6 dayofweek(current_date -day(current_date) day +1 day) dw,\u000d\u000a 7 week_iso(current_date -day(current_date) day +1 day) wk\u000d\u000a 8 from t1\u000d\u000a 9 union all\u000d\u000a10 select dy+1 day, day(dy+1 day), mth,\u000d\u000a11 dayofweek(dy+1 day), week_iso(dy+1 day)\u000d\u000a12 from x\u000d\u000a13 where month(dy+1 day) = mth\u000d\u000a14 )\u000d\u000a15 select max(case dw when 2 then dm end) as Mo,\u000d\u000a16 max(case dw when 3 then dm end) as Tu,\u000d\u000a17 max(case dw when 4 then dm end) as We,\u000d\u000a18 max(case dw when 5 then dm end) as Th,\u000d\u000a19 max(case dw when 6 then dm end) as Fr,\u000d\u000a20 max(case dw when 7 then dm end) as Sa,\u000d\u000a21 max(case dw when 1 then dm end) as Su\u000d\u000a22 from x\u000d\u000a23 group by wk\u000d\u000a24 order by wk\u000d\u000aOracle\u000d\u000aUse the recursive CONNECT BY clause to return each day in the current month.\u000d\u000aThen pivot on the day of the week using CASE and MAX:\u000d\u000a 1 with x\u000d\u000a 2 as (\u000d\u000a 3 select *\u000d\u000a 4 from (\u000d\u000a 5 select to_char(trunc(sysdate,'mm')+level-1,'iw') wk,\u000d\u000a 6 to_char(trunc(sysdate,'mm')+level-1,'dd') dm,\u000d\u000a 7 to_number(to_char(trunc(sysdate,'mm')+level-1,'d')) dw,\u000d\u000a9.7 Creating a Calendar | 269"," 8 to_char(trunc(sysdate,'mm')+level-1,'mm') curr_mth,\u000d\u000a 9 to_char(sysdate,'mm') mth\u000d\u000a10 from dual\u000d\u000a11 connect by level <= 31\u000d\u000a12 )\u000d\u000a13 where curr_mth = mth\u000d\u000a14 )\u000d\u000a15 select max(case dw when 2 then dm end) Mo,\u000d\u000a16 max(case dw when 3 then dm end) Tu,\u000d\u000a17 max(case dw when 4 then dm end) We,\u000d\u000a18 max(case dw when 5 then dm end) Th,\u000d\u000a19 max(case dw when 6 then dm end) Fr,\u000d\u000a20 max(case dw when 7 then dm end) Sa,\u000d\u000a21 max(case dw when 1 then dm end) Su\u000d\u000a22 from x\u000d\u000a23 group by wk\u000d\u000a24 order by wk\u000d\u000aPostgreSQL\u000d\u000aUse the function GENERATE_SERIES to return every day in the current month.\u000d\u000aThen pivot on the day of the week using MAX and CASE:\u000d\u000a 1 select max(case dw when 2 then dm end) as Mo,\u000d\u000a 2 max(case dw when 3 then dm end) as Tu,\u000d\u000a 3 max(case dw when 4 then dm end) as We,\u000d\u000a 4 max(case dw when 5 then dm end) as Th,\u000d\u000a 5 max(case dw when 6 then dm end) as Fr,\u000d\u000a 6 max(case dw when 7 then dm end) as Sa,\u000d\u000a 7 max(case dw when 1 then dm end) as Su\u000d\u000a 8 from (\u000d\u000a 9 select *\u000d\u000a10 from (\u000d\u000a11 select cast(date_trunc('month',current_date) as date)+x.id,\u000d\u000a12 to_char(\u000d\u000a13 cast(\u000d\u000a14 date_trunc('month',current_date)\u000d\u000a15 as date)+x.id,'iw') as wk,\u000d\u000a16 to_char(\u000d\u000a17 cast(\u000d\u000a18 date_trunc('month',current_date)\u000d\u000a19 as date)+x.id,'dd') as dm,\u000d\u000a20 cast(\u000d\u000a21 to_char(\u000d\u000a22 cast(\u000d\u000a23 date_trunc('month',current_date)\u000d\u000a24 as date)+x.id,'d') as integer) as dw,\u000d\u000a25 to_char(\u000d\u000a26 cast(\u000d\u000a27 date_trunc('month',current_date)\u000d\u000a28 as date)+x.id,'mm') as curr_mth,\u000d\u000a29 to_char(current_date,'mm') as mth\u000d\u000a270 | Chapter 9: Date Manipulation","30 from generate_series (0,31) x(id)\u000d\u000a31 ) x\u000d\u000a32 where mth = curr_mth\u000d\u000a33 ) y\u000d\u000a34 group by wk\u000d\u000a35 order by wk\u000d\u000aMySQL\u000d\u000aUse a recursive CTE to return each day in the current month. Then pivot on the day\u000d\u000aof the week using MAX and CASE:\u000d\u000awith recursive x(dy,dm,mth,dw,wk)\u000d\u000a as (\u000d\u000a select dy,\u000d\u000a day(dy) dm,\u000d\u000a datepart(m,dy) mth,\u000d\u000a datepart(dw,dy) dw,\u000d\u000a case when datepart(dw,dy) = 1\u000d\u000a then datepart(ww,dy)-1\u000d\u000a else datepart(ww,dy)\u000d\u000a end wk\u000d\u000a from (\u000d\u000a select date_add(day,-day(getdate())+1,getdate()) dy\u000d\u000a from t1\u000d\u000a ) x\u000d\u000a union all\u000d\u000a select dateadd(d,1,dy), day(date_add(d,1,dy)), mth,\u000d\u000a datepart(dw,dateadd(d,1,dy)),\u000d\u000a case when datepart(dw,date_add(d,1,dy)) = 1\u000d\u000a then datepart(wk,date_add(d,1,dy))-1\u000d\u000a else datepart(wk,date_add(d,1,dy))\u000d\u000a end\u000d\u000a from x\u000d\u000a where datepart(m,date_add(d,1,dy)) = mth\u000d\u000a )\u000d\u000a select max(case dw when 2 then dm end) as Mo,\u000d\u000a max(case dw when 3 then dm end) as Tu,\u000d\u000a max(case dw when 4 then dm end) as We,\u000d\u000a max(case dw when 5 then dm end) as Th,\u000d\u000a max(case dw when 6 then dm end) as Fr,\u000d\u000a max(case dw when 7 then dm end) as Sa,\u000d\u000a max(case dw when 1 then dm end) as Su\u000d\u000a from x\u000d\u000a group by wk\u000d\u000a order by wk;\u000d\u000a9.7 Creating a Calendar | 271","SQL Server\u000d\u000aUse the recursive WITH clause to return every day in the current month. Then pivot\u000d\u000aon the day of the week using CASE and MAX:\u000d\u000a 1 with x(dy,dm,mth,dw,wk)\u000d\u000a 2 as (\u000d\u000a 3 select dy,\u000d\u000a 4 day(dy) dm,\u000d\u000a 5 datepart(m,dy) mth,\u000d\u000a 6 datepart(dw,dy) dw,\u000d\u000a 7 case when datepart(dw,dy) = 1\u000d\u000a 8 then datepart(ww,dy)-1\u000d\u000a 9 else datepart(ww,dy)\u000d\u000a10 end wk\u000d\u000a11 from (\u000d\u000a12 select dateadd(day,-day(getdate())+1,getdate()) dy\u000d\u000a13 from t1\u000d\u000a14 ) x\u000d\u000a15 union all\u000d\u000a16 select dateadd(d,1,dy), day(dateadd(d,1,dy)), mth,\u000d\u000a17 datepart(dw,dateadd(d,1,dy)),\u000d\u000a18 case when datepart(dw,dateadd(d,1,dy)) = 1\u000d\u000a19 then datepart(wk,dateadd(d,1,dy)) -1\u000d\u000a20 else datepart(wk,dateadd(d,1,dy))\u000d\u000a21 end\u000d\u000a22 from x\u000d\u000a23 where datepart(m,dateadd(d,1,dy)) = mth\u000d\u000a24 )\u000d\u000a25 select max(case dw when 2 then dm end) as Mo,\u000d\u000a26 max(case dw when 3 then dm end) as Tu,\u000d\u000a27 max(case dw when 4 then dm end) as We,\u000d\u000a28 max(case dw when 5 then dm end) as Th,\u000d\u000a29 max(case dw when 6 then dm end) as Fr,\u000d\u000a30 max(case dw when 7 then dm end) as Sa,\u000d\u000a31 max(case dw when 1 then dm end) as Su\u000d\u000a32 from x\u000d\u000a33 group by wk\u000d\u000a34 order by wk\u000d\u000aDiscussion\u000d\u000aDB2\u000d\u000aThe first step is to return each day in the month for which you want to create a calen\u2010\u000d\u000adar. Do that using the recursive WITH clause. Along with each day of the month\u000d\u000a(DM), you will need to return different parts of each date: the day of the week (DW),\u000d\u000athe current month you are working with (MTH), and the ISO week for each day of\u000d\u000a272 | Chapter 9: Date Manipulation","the month (WK). The results of the recursive view X prior to recursion taking place\u000d\u000a(the upper portion of the UNION ALL) are shown here:\u000d\u000aselect (current_date -day(current_date) day +1 day) dy,\u000d\u000a day((current_date -day(current_date) day +1 day)) dm,\u000d\u000a month(current_date) mth,\u000d\u000a dayofweek(current_date -day(current_date) day +1 day) dw,\u000d\u000a week_iso(current_date -day(current_date) day +1 day) wk\u000d\u000a from t1\u000d\u000aDY DM MTH DW WK\u000d\u000a----------- -- --- ---------- --\u000d\u000a01-JUN-2005 01 06 4 22\u000d\u000aThe next step is to repeatedly increase the value for DM (move through the days of\u000d\u000athe month) until you are no longer in the current month. As you move through each\u000d\u000aday in the month, you will also return the day of the week that each day is, and which\u000d\u000aISO week the current day of the month falls into. Partial results are shown here:\u000d\u000awith x(dy,dm,mth,dw,wk)\u000d\u000a as (\u000d\u000aselect (current_date -day(current_date) day +1 day) dy,\u000d\u000a day((current_date -day(current_date) day +1 day)) dm,\u000d\u000a month(current_date) mth,\u000d\u000a dayofweek(current_date -day(current_date) day +1 day) dw,\u000d\u000a week_iso(current_date -day(current_date) day +1 day) wk\u000d\u000a from t1\u000d\u000a union all\u000d\u000a select dy+1 day, day(dy+1 day), mth,\u000d\u000a dayofweek(dy+1 day), week_iso(dy+1 day)\u000d\u000a from x\u000d\u000a where month(dy+1 day) = mth\u000d\u000a)\u000d\u000aselect *\u000d\u000a from x\u000d\u000aDY DM MTH DW WK\u000d\u000a----------- -- --- ---------- --\u000d\u000a01-JUN-2020 01 06 4 22\u000d\u000a02-JUN-2020 02 06 5 22\u000d\u000a\u2026\u000d\u000a21-JUN-2020 21 06 3 25\u000d\u000a22-JUN-2020 22 06 4 25\u000d\u000a\u2026\u000d\u000a30-JUN-2020 30 06 5 26\u000d\u000aWhat you are returning at this point is: each day for the current month, the two-digit\u000d\u000anumeric day of the month, the two-digit numeric month, the one-digit day of the\u000d\u000aweek (1\u20137 for Sun\u2013Sat), and the two-digit ISO week each day falls into. With all this\u000d\u000ainformation available, you can use a CASE expression to determine which day of the\u000d\u000a9.7 Creating a Calendar | 273","week each value of DM (each day of the month) falls into. A portion of the results is\u000d\u000ashown here:\u000d\u000awith x(dy,dm,mth,dw,wk)\u000d\u000a as (\u000d\u000aselect (current_date -day(current_date) day +1 day) dy,\u000d\u000a day((current_date -day(current_date) day +1 day)) dm,\u000d\u000a month(current_date) mth,\u000d\u000a dayofweek(current_date -day(current_date) day +1 day) dw,\u000d\u000a week_iso(current_date -day(current_date) day +1 day) wk\u000d\u000a from t1\u000d\u000a union all\u000d\u000a select dy+1 day, day(dy+1 day), mth,\u000d\u000a dayofweek(dy+1 day), week_iso(dy+1 day)\u000d\u000a from x\u000d\u000a where month(dy+1 day) = mth\u000d\u000a )\u000d\u000a select wk,\u000d\u000a case dw when 2 then dm end as Mo,\u000d\u000a case dw when 3 then dm end as Tu,\u000d\u000a case dw when 4 then dm end as We,\u000d\u000a case dw when 5 then dm end as Th,\u000d\u000a case dw when 6 then dm end as Fr,\u000d\u000a case dw when 7 then dm end as Sa,\u000d\u000a case dw when 1 then dm end as Su\u000d\u000a from x\u000d\u000aWK MO TU WE TH FR SA SU\u000d\u000a-- -- -- -- -- -- -- --\u000d\u000a22 01\u000d\u000a22 02\u000d\u000a22 03\u000d\u000a22 04\u000d\u000a22 05\u000d\u000a23 06\u000d\u000a23 07\u000d\u000a23 08\u000d\u000a23 09\u000d\u000a23 10\u000d\u000a23 11\u000d\u000a23 12\u000d\u000aAs you can see from the partial output, every day in each week is returned as a row.\u000d\u000aWhat you want to do now is to group the days by week, and then collapse all the days\u000d\u000afor each week into a single row. Use the aggregate function MAX, and group by WK\u000d\u000a(the ISO week) to return all the days for a week as one row. To properly format the\u000d\u000acalendar and ensure that the days are in the right order, order the results by WK. The\u000d\u000afinal output is shown here:\u000d\u000awith x(dy,dm,mth,dw,wk)\u000d\u000a as (\u000d\u000aselect (current_date -day(current_date) day +1 day) dy,\u000d\u000a274 | Chapter 9: Date Manipulation"," day((current_date -day(current_date) day +1 day)) dm,\u000d\u000a month(current_date) mth,\u000d\u000a dayofweek(current_date -day(current_date) day +1 day) dw,\u000d\u000a week_iso(current_date -day(current_date) day +1 day) wk\u000d\u000a from t1\u000d\u000a union all\u000d\u000a select dy+1 day, day(dy+1 day), mth,\u000d\u000a dayofweek(dy+1 day), week_iso(dy+1 day)\u000d\u000a from x\u000d\u000a where month(dy+1 day) = mth\u000d\u000a)\u000d\u000aselect max(case dw when 2 then dm end) as Mo,\u000d\u000a max(case dw when 3 then dm end) as Tu,\u000d\u000a max(case dw when 4 then dm end) as We,\u000d\u000a max(case dw when 5 then dm end) as Th,\u000d\u000a max(case dw when 6 then dm end) as Fr,\u000d\u000a max(case dw when 7 then dm end) as Sa,\u000d\u000a max(case dw when 1 then dm end) as Su\u000d\u000a from x\u000d\u000a group by wk\u000d\u000a order by wk\u000d\u000aMO TU WE TH FR SA SU\u000d\u000a-- -- -- -- -- -- --\u000d\u000a 01 02 03 04 05\u000d\u000a06 07 08 09 10 11 12\u000d\u000a13 14 15 16 17 18 19\u000d\u000a20 21 22 23 24 25 26\u000d\u000a27 28 29 30\u000d\u000aOracle\u000d\u000aBegin by using the recursive CONNECT BY clause to generate a row for each day in\u000d\u000athe month for which you want to generate a calendar. If you aren\u2019t running at least\u000d\u000aOracle9i Database, you can\u2019t use CONNECT BY this way. Instead, you can use a pivot\u000d\u000atable, such as T500 in the MySQL solution.\u000d\u000aAlong with each day of the month, you will need to return different bits of informa\u2010\u000d\u000ation for each day: the day of the month (DM), the day of the week (DW), the current\u000d\u000amonth you are working with (MTH), and the ISO week for each day of the month\u000d\u000a(WK). The results of the WITH view X for the first day of the current month are\u000d\u000ashown here:\u000d\u000aselect trunc(sysdate,'mm') dy,\u000d\u000a to_char(trunc(sysdate,'mm'),'dd') dm,\u000d\u000a to_char(sysdate,'mm') mth,\u000d\u000a to_number(to_char(trunc(sysdate,'mm'),'d')) dw,\u000d\u000a to_char(trunc(sysdate,'mm'),'iw') wk\u000d\u000a from dual\u000d\u000a9.7 Creating a Calendar | 275","DY DM MT DW WK\u000d\u000a----------- -- -- ---------- --\u000d\u000a01-JUN-2020 01 06 4 22\u000d\u000aThe next step is to repeatedly increase the value for DM (move through the days of\u000d\u000athe month) until you are no longer in the current month. As you move through each\u000d\u000aday in the month, you will also return the day of the week for each day and the ISO\u000d\u000aweek into which the current day falls. Partial results are shown here (the full date for\u000d\u000aeach day is added for readability):\u000d\u000awith x\u000d\u000a as (\u000d\u000aselect *\u000d\u000a from (\u000d\u000aselect trunc(sysdate,'mm')+level-1 dy,\u000d\u000a to_char(trunc(sysdate,'mm')+level-1,'iw') wk,\u000d\u000a to_char(trunc(sysdate,'mm')+level-1,'dd') dm,\u000d\u000a to_number(to_char(trunc(sysdate,'mm')+level-1,'d')) dw,\u000d\u000a to_char(trunc(sysdate,'mm')+level-1,'mm') curr_mth,\u000d\u000a to_char(sysdate,'mm') mth\u000d\u000a from dual\u000d\u000a connect by level <= 31\u000d\u000a )\u000d\u000a where curr_mth = mth\u000d\u000a)\u000d\u000aselect *\u000d\u000a from x\u000d\u000aDY WK DM DW CU MT\u000d\u000a----------- -- -- ---------- -- --\u000d\u000a01-JUN-2020 22 01 4 06 06\u000d\u000a02-JUN-2020 22 02 5 06 06\u000d\u000a\u2026\u000d\u000a21-JUN-2020 25 21 3 06 06\u000d\u000a22-JUN-2020 25 22 4 06 06\u000d\u000a\u2026\u000d\u000a30-JUN-2020 26 30 5 06 06\u000d\u000aWhat you are returning at this point is one row for each day of the current month. In\u000d\u000athat row you have: the two-digit numeric day of the month, the two-digit numeric\u000d\u000amonth, the one-digit day of the week (1\u20137 for Sun\u2013Sat), and the two-digit ISO week\u000d\u000anumber. With all this information available, you can use a CASE expression to deter\u2010\u000d\u000amine which day of the week each value of DM (each day of the month) falls into. A\u000d\u000aportion of the results is shown here:\u000d\u000awith x\u000d\u000a as (\u000d\u000aselect *\u000d\u000a from (\u000d\u000aselect trunc(sysdate,'mm')+level-1 dy,\u000d\u000a to_char(trunc(sysdate,'mm')+level-1,'iw') wk,\u000d\u000a276 | Chapter 9: Date Manipulation"," to_char(trunc(sysdate,'mm')+level-1,'dd') dm,\u000d\u000a to_number(to_char(trunc(sysdate,'mm')+level-1,'d')) dw,\u000d\u000a to_char(trunc(sysdate,'mm')+level-1,'mm') curr_mth,\u000d\u000a to_char(sysdate,'mm') mth\u000d\u000a from dual\u000d\u000a connect by level <= 31\u000d\u000a )\u000d\u000a where curr_mth = mth\u000d\u000a)\u000d\u000aselect wk,\u000d\u000a case dw when 2 then dm end as Mo,\u000d\u000a case dw when 3 then dm end as Tu,\u000d\u000a case dw when 4 then dm end as We,\u000d\u000a case dw when 5 then dm end as Th,\u000d\u000a case dw when 6 then dm end as Fr,\u000d\u000a case dw when 7 then dm end as Sa,\u000d\u000a case dw when 1 then dm end as Su\u000d\u000a from x\u000d\u000aWK MO TU WE TH FR SA SU\u000d\u000a-- -- -- -- -- -- -- --\u000d\u000a22 01\u000d\u000a22 02\u000d\u000a22 03\u000d\u000a22 04\u000d\u000a22 05\u000d\u000a23 06\u000d\u000a23 07\u000d\u000a23 08\u000d\u000a23 09\u000d\u000a23 10\u000d\u000a23 11\u000d\u000a23 12\u000d\u000aAs you can see from the partial output, every day in each week is returned as a row,\u000d\u000abut the day number is in one of seven columns corresponding to the day of the week.\u000d\u000aYour task now is to consolidate the days into one row for each week. Use the aggre\u2010\u000d\u000agate function MAX and group by WK (the ISO week) to return all the days for a week\u000d\u000aas one row. To ensure the days are in the right order, order the results by WK. The\u000d\u000afinal output is shown here:\u000d\u000awith x\u000d\u000a as (\u000d\u000aselect *\u000d\u000a from (\u000d\u000aselect to_char(trunc(sysdate,'mm')+level-1,'iw') wk,\u000d\u000a to_char(trunc(sysdate,'mm')+level-1,'dd') dm,\u000d\u000a to_number(to_char(trunc(sysdate,'mm')+level-1,'d')) dw,\u000d\u000a to_char(trunc(sysdate,'mm')+level-1,'mm') curr_mth,\u000d\u000a to_char(sysdate,'mm') mth\u000d\u000a from dual\u000d\u000a connect by level <= 31\u000d\u000a9.7 Creating a Calendar | 277"," )\u000d\u000a where curr_mth = mth\u000d\u000a)\u000d\u000aselect max(case dw when 2 then dm end) Mo,\u000d\u000a max(case dw when 3 then dm end) Tu,\u000d\u000a max(case dw when 4 then dm end) We,\u000d\u000a max(case dw when 5 then dm end) Th,\u000d\u000a max(case dw when 6 then dm end) Fr,\u000d\u000a max(case dw when 7 then dm end) Sa,\u000d\u000a max(case dw when 1 then dm end) Su\u000d\u000a from x\u000d\u000a group by wk\u000d\u000a order by wk\u000d\u000aMO TU WE TH FR SA SU\u000d\u000a-- -- -- -- -- -- --\u000d\u000a 01 02 03 04 05\u000d\u000a06 07 08 09 10 11 12\u000d\u000a13 14 15 16 17 18 19\u000d\u000a20 21 22 23 24 25 26\u000d\u000a27 28 29 30\u000d\u000aMySQL, PostgreSQL, and SQL Server\u000d\u000aThese solutions are the same except for differences in the specific functions used to\u000d\u000acall dates. We arbitrarily use the SQL Serve solution for the explanation. Begin by\u000d\u000areturning one row for each day of the month. You can do that using the recursive\u000d\u000aWITH clause. For each row that you return, you will need the following items: the\u000d\u000aday of the month (DM), the day of the week (DW), the current month you are work\u2010\u000d\u000aing with (MTH), and the ISO week for each day of the month (WK). The results of\u000d\u000athe recursive view X prior to recursion taking place (the upper portion of the UNION\u000d\u000aALL) are shown here:\u000d\u000aselect dy,\u000d\u000a day(dy) dm,\u000d\u000a datepart(m,dy) mth,\u000d\u000a datepart(dw,dy) dw,\u000d\u000a case when datepart(dw,dy) = 1\u000d\u000a then datepart(ww,dy)-1\u000d\u000a else datepart(ww,dy)\u000d\u000a end wk\u000d\u000a from (\u000d\u000aselect dateadd(day,-day(getdate())+1,getdate()) dy\u000d\u000a from t1\u000d\u000a ) x\u000d\u000aDY DM MTH DW WK\u000d\u000a----------- -- --- ---------- --\u000d\u000a01-JUN-2005 1 6 4 23\u000d\u000a278 | Chapter 9: Date Manipulation","Your next step is to repeatedly increase the value for DM (move through the days of\u000d\u000athe month) until you are no longer in the current month. As you move through each\u000d\u000aday in the month, you will also return the day of the week and the ISO week number.\u000d\u000aPartial results are shown here:\u000d\u000a with x(dy,dm,mth,dw,wk)\u000d\u000a as (\u000d\u000aselect dy,\u000d\u000a day(dy) dm,\u000d\u000a datepart(m,dy) mth,\u000d\u000a datepart(dw,dy) dw,\u000d\u000a case when datepart(dw,dy) = 1\u000d\u000a then datepart(ww,dy)-1\u000d\u000a else datepart(ww,dy)\u000d\u000a end wk\u000d\u000a from (\u000d\u000aselect dateadd(day,-day(getdate())+1,getdate()) dy\u000d\u000a from t1\u000d\u000a ) x\u000d\u000a union all\u000d\u000a select dateadd(d,1,dy), day(dateadd(d,1,dy)), mth,\u000d\u000a datepart(dw,dateadd(d,1,dy)),\u000d\u000a case when datepart(dw,dateadd(d,1,dy)) = 1\u000d\u000a then datepart(wk,dateadd(d,1,dy))-1\u000d\u000a else datepart(wk,dateadd(d,1,dy))\u000d\u000a end\u000d\u000a from x\u000d\u000a where datepart(m,dateadd(d,1,dy)) = mth\u000d\u000a)\u000d\u000aselect *\u000d\u000a from x\u000d\u000aDY DM MTH DW WK\u000d\u000a----------- -- --- ---------- --\u000d\u000a01-JUN-2005 01 06 4 23\u000d\u000a02-JUN-2005 02 06 5 23\u000d\u000a\u2026\u000d\u000a21-JUN-2005 21 06 3 26\u000d\u000a22-JUN-2005 22 06 4 26\u000d\u000a\u2026\u000d\u000a30-JUN-2005 30 06 5 27\u000d\u000aFor each day in the current month, you now have: the two-digit numeric day of the\u000d\u000amonth, the two-digit numeric month, the one-digit day of the week (1\u20137 for Sun\u2013\u000d\u000aSat), and the two-digit ISO week number.\u000d\u000aNow, use a CASE expression to determine which day of the week each value of DM\u000d\u000a(each day of the month) falls into. A portion of the results is shown here:\u000d\u000a with x(dy,dm,mth,dw,wk)\u000d\u000a as (\u000d\u000aselect dy,\u000d\u000a9.7 Creating a Calendar | 279"," day(dy) dm,\u000d\u000a datepart(m,dy) mth,\u000d\u000a datepart(dw,dy) dw,\u000d\u000a case when datepart(dw,dy) = 1\u000d\u000a then datepart(ww,dy)-1\u000d\u000a else datepart(ww,dy)\u000d\u000a end wk\u000d\u000a from (\u000d\u000aselect dateadd(day,-day(getdate())+1,getdate()) dy\u000d\u000a from t1\u000d\u000a ) x\u000d\u000a union all\u000d\u000a select dateadd(d,1,dy), day(dateadd(d,1,dy)), mth,\u000d\u000a datepart(dw,dateadd(d,1,dy)),\u000d\u000a case when datepart(dw,dateadd(d,1,dy)) = 1\u000d\u000a then datepart(wk,dateadd(d,1,dy))-1\u000d\u000a else datepart(wk,dateadd(d,1,dy))\u000d\u000a end\u000d\u000a from x\u000d\u000a where datepart(m,dateadd(d,1,dy)) = mth\u000d\u000a)\u000d\u000aselect case dw when 2 then dm end as Mo,\u000d\u000a case dw when 3 then dm end as Tu,\u000d\u000a case dw when 4 then dm end as We,\u000d\u000a case dw when 5 then dm end as Th,\u000d\u000a case dw when 6 then dm end as Fr,\u000d\u000a case dw when 7 then dm end as Sa,\u000d\u000a case dw when 1 then dm end as Su\u000d\u000a from x\u000d\u000aWK MO TU WE TH FR SA SU\u000d\u000a-- -- -- -- -- -- -- --\u000d\u000a22 01\u000d\u000a22 02\u000d\u000a22 03\u000d\u000a22 04\u000d\u000a22 05\u000d\u000a23 06\u000d\u000a23 07\u000d\u000a23 08\u000d\u000a23 09\u000d\u000a23 10\u000d\u000a23 11\u000d\u000a23 12\u000d\u000aEvery day in each week is returned as a separate row. In each row, the column con\u2010\u000d\u000ataining the day number corresponds to the day of the week. You now need to consoli\u2010\u000d\u000adate the days for each week into one row. Do that by grouping the rows by WK (the\u000d\u000aISO week) and applying the MAX function to the different columns. The results will\u000d\u000abe in calendar format as shown here:\u000d\u000a280 | Chapter 9: Date Manipulation","with x(dy,dm,mth,dw,wk)\u000d\u000a as (\u000d\u000aselect dy,\u000d\u000a day(dy) dm,\u000d\u000a datepart(m,dy) mth,\u000d\u000a datepart(dw,dy) dw,\u000d\u000a case when datepart(dw,dy) = 1\u000d\u000a then datepart(ww,dy)-1\u000d\u000a else datepart(ww,dy)\u000d\u000a end wk\u000d\u000a from (\u000d\u000aselect dateadd(day,-day(getdate())+1,getdate()) dy\u000d\u000a from t1\u000d\u000a ) x\u000d\u000a union all\u000d\u000a select dateadd(d,1,dy), day(dateadd(d,1,dy)), mth,\u000d\u000a datepart(dw,dateadd(d,1,dy)),\u000d\u000a case when datepart(dw,dateadd(d,1,dy)) = 1\u000d\u000a then datepart(wk,dateadd(d,1,dy))-1\u000d\u000a else datepart(wk,dateadd(d,1,dy))\u000d\u000a end\u000d\u000a from x\u000d\u000a where datepart(m,dateadd(d,1,dy)) = mth\u000d\u000a)\u000d\u000aselect max(case dw when 2 then dm end) as Mo,\u000d\u000a max(case dw when 3 then dm end) as Tu,\u000d\u000a max(case dw when 4 then dm end) as We,\u000d\u000a max(case dw when 5 then dm end) as Th,\u000d\u000a max(case dw when 6 then dm end) as Fr,\u000d\u000a max(case dw when 7 then dm end) as Sa,\u000d\u000a max(case dw when 1 then dm end) as Su\u000d\u000a from x\u000d\u000a group by wk\u000d\u000a order by wk\u000d\u000aMO TU WE TH FR SA SU\u000d\u000a-- -- -- -- -- -- --\u000d\u000a 01 02 03 04 05\u000d\u000a06 07 08 09 10 11 12\u000d\u000a13 14 15 16 17 18 19\u000d\u000a20 21 22 23 24 25 26\u000d\u000a27 28 29 30\u000d\u000a9.8 Listing Quarter Start and End Dates for the Year\u000d\u000aProblem\u000d\u000aYou want to return the start and end dates for each of the four quarters of a given\u000d\u000ayear.\u000d\u000a9.8 Listing Quarter Start and End Dates for the Year | 281","Solution\u000d\u000aThere are four quarters to a year, so you know you will need to generate four rows.\u000d\u000aAfter generating the desired number of rows, simply use the date functions supplied\u000d\u000aby your RDBMS to return to the quarter the start and end dates fall into. Your goal is\u000d\u000ato produce the following result set (one again, the choice to use the current year is\u000d\u000aarbitrary):\u000d\u000aQTR Q_START Q_END\u000d\u000a--- ----------- -----------\u000d\u000a 1 01-JAN-2020 31-MAR-2020\u000d\u000a 2 01-APR-2020 30-JUN-2020\u000d\u000a 3 01-JUL-2020 30-SEP-2020\u000d\u000a 4 01-OCT-2020 31-DEC-2020\u000d\u000aDB2\u000d\u000aUse table EMP and the window function ROW_NUMBER OVER to generate four\u000d\u000arows. Alternatively, you can use the WITH clause to generate rows (as many of the\u000d\u000arecipes do), or you can query against any table with at least four rows. The following\u000d\u000asolution uses the ROW_NUMBER OVER approach:\u000d\u000a 1 select quarter(dy-1 day) QTR,\u000d\u000a 2 dy-3 month Q_start,\u000d\u000a 3 dy-1 day Q_end\u000d\u000a 4 from (\u000d\u000a 5 select (current_date -\u000d\u000a 6 (dayofyear(current_date)-1) day\u000d\u000a 7 + (rn*3) month) dy\u000d\u000a 8 from (\u000d\u000a 9 select row_number()over() rn\u000d\u000a10 from emp\u000d\u000a11 fetch first 4 rows only\u000d\u000a12 ) x\u000d\u000a13 ) y\u000d\u000aOracle\u000d\u000aUse the function ADD_MONTHS to find the start and end dates for each quarter.\u000d\u000aUse ROWNUM to represent the quarter the start and end dates belong to. The fol\u2010\u000d\u000alowing solution uses table EMP to generate four rows:\u000d\u000a1 select rownum qtr,\u000d\u000a2 add_months(trunc(sysdate,'y'),(rownum-1)*3) q_start,\u000d\u000a3 add_months(trunc(sysdate,'y'),rownum*3)-1 q_end\u000d\u000a4 from emp\u000d\u000a5 where rownum <= 4\u000d\u000a282 | Chapter 9: Date Manipulation","PostgreSQL\u000d\u000aFind the first day of the year based on the current date, and use a recursive CTE to fill\u000d\u000ain the first date of the remaining three quarters before finding the last day of each\u000d\u000aquarter:\u000d\u000a with recursive x (dy,cnt)\u000d\u000a as (\u000d\u000a select\u000d\u000a current_date -cast(extract(day from current_date)as integer) +1 dy\u000d\u000a , id\u000d\u000a from t1\u000d\u000a union all\u000d\u000a select cast(dy + interval '3 months' as date) , cnt+1\u000d\u000a from x\u000d\u000a where cnt+1 <= 4\u000d\u000a )\u000d\u000a select cast(dy - interval '3 months' as date) as Q_start\u000d\u000a , dy-1 as Q_end\u000d\u000a from x\u000d\u000aMySQL\u000d\u000aFind the first day of the year from the current day, and use a CTE to create four rows,\u000d\u000aone for each quarter. Use ADDDATE to find the last day of each quarter (three\u000d\u000amonths after the previous last day, or the first day of the quarter minus one):\u000d\u000a1 with recursive x (dy,cnt)\u000d\u000a2 as (\u000d\u000a3 select\u000d\u000a4 adddate(current_date,(-dayofyear(current_date))+1) dy\u000d\u000a5 ,id\u000d\u000a6 from t1\u000d\u000a7 union all\u000d\u000a8 select adddate(dy, interval 3 month ), cnt+1\u000d\u000a9 from x\u000d\u000a10 where cnt+1 <= 4\u000d\u000a11 )\u000d\u000a12\u000d\u000a13 select quarter(adddate(dy,-1)) QTR\u000d\u000a14 , date_add(dy, interval -3 month) Q_start\u000d\u000a15 , adddate(dy,-1) Q_end\u000d\u000a16 from x\u000d\u000a17 order by 1;\u000d\u000aSQL Server\u000d\u000aUse the recursive WITH clause to generate four rows. Use the function DATEADD to\u000d\u000afind the start and end dates. Use the function DATEPART to determine which quar\u2010\u000d\u000ater the start and end dates belong to:\u000d\u000a9.8 Listing Quarter Start and End Dates for the Year | 283"," 1 with x (dy,cnt)\u000d\u000a 2 as (\u000d\u000a 3 select dateadd(d,-(datepart(dy,getdate())-1),getdate()),\u000d\u000a 4 1\u000d\u000a 5 from t1\u000d\u000a 6 union all\u000d\u000a 7 select dateadd(m,3,dy), cnt+1\u000d\u000a 8 from x\u000d\u000a 9 where cnt+1 <= 4\u000d\u000a10 )\u000d\u000a11 select datepart(q,dateadd(d,-1,dy)) QTR,\u000d\u000a12 dateadd(m,-3,dy) Q_start,\u000d\u000a13 dateadd(d,-1,dy) Q_end\u000d\u000a14 from x\u000d\u000a15 order by 1\u000d\u000aDiscussion\u000d\u000aDB2\u000d\u000aThe first step is to generate four rows (with values one through four) for each quarter\u000d\u000ain the year. Inline view X uses the window function ROW_NUMBER OVER and the\u000d\u000aFETCH FIRST clause to return only four rows from EMP. The results are shown here:\u000d\u000aselect row_number()over() rn\u000d\u000a from emp\u000d\u000a fetch first 4 rows only\u000d\u000aRN\u000d\u000a--\u000d\u000a 1\u000d\u000a 2\u000d\u000a 3\u000d\u000a 4\u000d\u000aThe next step is to find the first day of the year, then add n months to it, where n is\u000d\u000athree times RN (you are adding 3, 6, 9, and 12 months to the first day of the year).\u000d\u000aThe results are shown here:\u000d\u000aselect (current_date\u000d\u000a (dayofyear(current_date)-1) day\u000d\u000a + (rn*3) month) dy \u000d\u000a from (\u000d\u000aselect row_number()over() rn\u000d\u000a from emp\u000d\u000a fetch first 4 rows only\u000d\u000a ) x\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-APR-2005\u000d\u000a01-JUL-2005\u000d\u000a284 | Chapter 9: Date Manipulation","01-OCT-2005\u000d\u000a01-JAN-2005\u000d\u000aAt this point, the values for DY are one day after the end date for each quarter. The\u000d\u000anext step is to get the start and end dates for each quarter. Subtract one day from DY\u000d\u000ato get the end of each quarter, and subtract three months from DY to get the start of\u000d\u000aeach quarter. Use the QUARTER function on DY-1 (the end date for each quarter) to\u000d\u000adetermine which quarter the start and end dates belong to.\u000d\u000aOracle\u000d\u000aThe combination of ROWNUM, TRUNC, and ADD_MONTHS makes this solution\u000d\u000aeasy. To find the start of each quarter, simply add n months to the first day of the year,\u000d\u000awhere n is (ROWNUM-1)*3 (giving you 0, 3, 6, 9). To find the end of each quarter,\u000d\u000aadd n months to the first day of the year, where n is ROWNUM*3, and subtract one\u000d\u000aday. As an aside, when working with quarters, you may also find it useful to use\u000d\u000aTO_CHAR and/or TRUNC with the Q formatting option.\u000d\u000aPostgreSQL, MySQL, and SQL Server\u000d\u000aLike some of the previous recipes, this recipe uses the same structure across three\u000d\u000aRDMS implementations, but different syntax for the date operations. The first step is\u000d\u000ato find the first day of the year and then recursively add n months, where n is three\u000d\u000atimes the current iteration (there are four iterations, therefore, you are adding 3*1\u000d\u000amonths, 3*2 months, etc.), using the DATEADD function or its equivalent. The\u000d\u000aresults are shown here:\u000d\u000awith x (dy,cnt)\u000d\u000a as (\u000d\u000aselect dateadd(d,-(datepart(dy,getdate())-1),getdate()),\u000d\u000a 1\u000d\u000a from t1\u000d\u000a union all\u000d\u000aselect dateadd(m,3,dy), cnt+1\u000d\u000a from x\u000d\u000a where cnt+1 <= 4\u000d\u000a)\u000d\u000aselect dy\u000d\u000a from x\u000d\u000aDY\u000d\u000a-----------\u000d\u000a01-APR-2020\u000d\u000a01-JUL-2020\u000d\u000a01-OCT-2020\u000d\u000a01-JAN-2020\u000d\u000aThe values for DY are one day after the end of each quarter. To get the end of each\u000d\u000aquarter, simply subtract one day from DY by using the DATEADD function. To find\u000d\u000a9.8 Listing Quarter Start and End Dates for the Year | 285","the start of each quarter, use the DATEADD function to subtract three months from\u000d\u000aDY. Use the DATEPART function on the end date for each quarter to determine\u000d\u000awhich quarter the start and end dates belong to or its equivalent. If you are using\u000d\u000aPostgreSQL, note that you need CAST to ensure data types align after performing\u000d\u000aadding the three months to the start date, or the data types will different, and the\u000d\u000aUNION ALL in the recursive CTE will fail.\u000d\u000a9.9 Determining Quarter Start and End Dates for a Given\u000d\u000aQuarter\u000d\u000aProblem\u000d\u000aWhen given a year and quarter in the format of YYYYQ (four-digit year, one-digit\u000d\u000aquarter), you want to return the quarter\u2019s start and end dates.\u000d\u000aSolution\u000d\u000aThe key to this solution is to find the quarter by using the modulus function on the\u000d\u000aYYYYQ value. (As an alternative to modulo, since the year format is four digits, you\u000d\u000acan simply substring out the last digit to get the quarter.) Once you have the quarter,\u000d\u000asimply multiply by three to get the ending month for the quarter. In the solutions that\u000d\u000afollow, inline view X will return all four year and quarter combinations. The result set\u000d\u000afor inline view X is as follows:\u000d\u000aselect 20051 as yrq from t1 union all\u000d\u000aselect 20052 as yrq from t1 union all\u000d\u000aselect 20053 as yrq from t1 union all\u000d\u000aselect 20054 as yrq from t1\u000d\u000a YRQ\u000d\u000a-------\u000d\u000a 20051\u000d\u000a 20052\u000d\u000a 20053\u000d\u000a 20054\u000d\u000aDB2\u000d\u000aUse the function SUBSTR to return the year from inline view X. Use the MOD func\u2010\u000d\u000ation to determine which quarter you are looking for:\u000d\u000a 1 select (q_end-2 month) q_start,\u000d\u000a 2 (q_end+1 month)-1 day q_end\u000d\u000a 3 from (\u000d\u000a 4 select date(substr(cast(yrq as char(4)),1,4) ||'-'||\u000d\u000a 5 rtrim(cast(mod(yrq,10)*3 as char(2))) ||'-1') q_end\u000d\u000a 6 from (\u000d\u000a 7 select 20051 yrq from t1 union all\u000d\u000a286 | Chapter 9: Date Manipulation"," 8 select 20052 yrq from t1 union all\u000d\u000a 9 select 20053 yrq from t1 union all\u000d\u000a10 select 20054 yrq from t1\u000d\u000a11 ) x\u000d\u000a12 ) y\u000d\u000aOracle\u000d\u000aUse the function SUBSTR to return the year from inline view X. Use the MOD func\u2010\u000d\u000ation to determine which quarter you are looking for:\u000d\u000a 1 select add_months(q_end,-2) q_start,\u000d\u000a 2 last_day(q_end) q_end\u000d\u000a 3 from (\u000d\u000a 4 select to_date(substr(yrq,1,4)||mod(yrq,10)*3,'yyyymm') q_end\u000d\u000a 5 from (\u000d\u000a 6 select 20051 yrq from dual union all\u000d\u000a 7 select 20052 yrq from dual union all\u000d\u000a 8 select 20053 yrq from dual union all\u000d\u000a 9 select 20054 yrq from dual\u000d\u000a10 ) x\u000d\u000a11 ) y\u000d\u000aPostgreSQL\u000d\u000aUse the function SUBSTR to return the year from the inline view X. Use the MOD\u000d\u000afunction to determine which quarter you are looking for:\u000d\u000a 1 select date(q_end-(2*interval '1 month')) as q_start,\u000d\u000a 2 date(q_end+interval '1 month'-interval '1 day') as q_end\u000d\u000a 3 from (\u000d\u000a 4 select to_date(substr(yrq,1,4)||mod(yrq,10)*3,'yyyymm') as q_end\u000d\u000a 5 from (\u000d\u000a 6 select 20051 as yrq from t1 union all\u000d\u000a 7 select 20052 as yrq from t1 union all\u000d\u000a 8 select 20053 as yrq from t1 union all\u000d\u000a 9 select 20054 as yrq from t1\u000d\u000a10 ) x\u000d\u000a11 ) y\u000d\u000aMySQL\u000d\u000aUse the function SUBSTR to return the year from the inline view X. Use the MOD\u000d\u000afunction to determine which quarter you are looking for:\u000d\u000a 1 select date_add(\u000d\u000a 2 adddate(q_end,-day(q_end)+1),\u000d\u000a 3 interval -2 month) q_start,\u000d\u000a 4 q_end\u000d\u000a 5 from (\u000d\u000a 6 select last_day(\u000d\u000a 7 str_to_date(\u000d\u000a9.9 Determining Quarter Start and End Dates for a Given Quarter | 287"," 8 concat(\u000d\u000a 9 substr(yrq,1,4),mod(yrq,10)*3),'%Y%m')) q_end\u000d\u000a10 from (\u000d\u000a11 select 20051 as yrq from t1 union all\u000d\u000a12 select 20052 as yrq from t1 union all\u000d\u000a13 select 20053 as yrq from t1 union all\u000d\u000a14 select 20054 as yrq from t1\u000d\u000a15 ) x\u000d\u000a16 ) y\u000d\u000aSQL Server\u000d\u000aUse the function SUBSTRING to return the year from the inline view X. Use the\u000d\u000amodulus function (%) to determine which quarter you are looking for:\u000d\u000a 1 select dateadd(m,-2,q_end) q_start,\u000d\u000a 2 dateadd(d,-1,dateadd(m,1,q_end)) q_end\u000d\u000a 3 from (\u000d\u000a 4 select cast(substring(cast(yrq as varchar),1,4)+'-'+\u000d\u000a 5 cast(yrq%10*3 as varchar)+'-1' as datetime) q_end\u000d\u000a 6 from (\u000d\u000a 7 select 20051 as yrq from t1 union all\u000d\u000a 8 select 20052 as yrq from t1 union all\u000d\u000a 9 select 20052 as yrq from t1 union all\u000d\u000a10 select 20054 as yrq from t1\u000d\u000a11 ) x\u000d\u000a12 ) y\u000d\u000aDiscussion\u000d\u000aDB2\u000d\u000aThe first step is to find the year and quarter you are working with. Substring out the\u000d\u000ayear from inline view X (X.YRQ) using the SUBSTR function. To get the quarter, use\u000d\u000amodulus 10 on YRQ. Once you have the quarter, multiply by three to get the end\u000d\u000amonth for the quarter. The results are shown here:\u000d\u000aselect substr(cast(yrq as char(4)),1,4) yr,\u000d\u000a mod(yrq,10)*3 mth\u000d\u000a from (\u000d\u000aselect 20051 yrq from t1 union all\u000d\u000aselect 20052 yrq from t1 union all\u000d\u000aselect 20053 yrq from t1 union all\u000d\u000aselect 20054 yrq from t1\u000d\u000a ) x\u000d\u000aYR MTH\u000d\u000a---- ------\u000d\u000a2005 3\u000d\u000a2005 6\u000d\u000a288 | Chapter 9: Date Manipulation","2005 9\u000d\u000a2005 12\u000d\u000aAt this point you have the year and end month for each quarter. Use those values to\u000d\u000aconstruct a date, specifically, the first day of the last month for each quarter. Use the\u000d\u000aconcatenation operator || to glue together the year and month, and then use the \u000d\u000aDATE function to convert to a date:\u000d\u000aselect date(substr(cast(yrq as char(4)),1,4) ||'-'||\u000d\u000a rtrim(cast(mod(yrq,10)*3 as char(2))) ||'-1') q_end\u000d\u000a from (\u000d\u000aselect 20051 yrq from t1 union all\u000d\u000aselect 20052 yrq from t1 union all\u000d\u000aselect 20053 yrq from t1 union all\u000d\u000aselect 20054 yrq from t1\u000d\u000a ) x\u000d\u000aQ_END\u000d\u000a-----------\u000d\u000a01-MAR-2005\u000d\u000a01-JUN-2005\u000d\u000a01-SEP-2005\u000d\u000a01-DEC-2005\u000d\u000aThe values for Q_END are the first day of the last month of each quarter. To get to\u000d\u000athe last day of the month, add one month to Q_END and then subtract one day. To\u000d\u000afind the start date for each quarter, subtract two months from Q_END.\u000d\u000aOracle\u000d\u000aThe first step is to find the year and quarter you are working with. Substring out the\u000d\u000ayear from inline view X (X.YRQ) using the SUBSTR function. To get the quarter, use\u000d\u000amodulus 10 on YRQ. Once you have the quarter, multiply by three to get the end\u000d\u000amonth for the quarter. The results are shown here:\u000d\u000aselect substr(yrq,1,4) yr, mod(yrq,10)*3 mth\u000d\u000a from (\u000d\u000aselect 20051 yrq from t1 union all\u000d\u000aselect 20052 yrq from t1 union all\u000d\u000aselect 20053 yrq from t1 union all\u000d\u000aselect 20054 yrq from t1\u000d\u000a ) x\u000d\u000aYR MTH\u000d\u000a---- ------\u000d\u000a2005 3\u000d\u000a2005 6\u000d\u000a2005 9\u000d\u000a2005 12\u000d\u000a9.9 Determining Quarter Start and End Dates for a Given Quarter | 289","At this point you have the year and end month for each quarter. Use those values to\u000d\u000aconstruct a date, specifically, the first day of the last month for each quarter. Use the\u000d\u000aconcatenation operator || to glue together the year and month, and then use the\u000d\u000aTO_DATE function to convert to a date:\u000d\u000aselect to_date(substr(yrq,1,4)||mod(yrq,10)*3,'yyyymm') q_end\u000d\u000a from (\u000d\u000aselect 20051 yrq from t1 union all\u000d\u000aselect 20052 yrq from t1 union all\u000d\u000aselect 20053 yrq from t1 union all\u000d\u000aselect 20054 yrq from t1\u000d\u000a ) x\u000d\u000aQ_END\u000d\u000a-----------\u000d\u000a01-MAR-2005\u000d\u000a01-JUN-2005\u000d\u000a01-SEP-2005\u000d\u000a01-DEC-2005\u000d\u000aThe values for Q_END are the first day of the last month of each quarter. To get to\u000d\u000athe last day of the month, use the LAST_DAY function on Q_END. To find the start\u000d\u000adate for each quarter, subtract two months from Q_END using the ADD_MONTHS\u000d\u000afunction.\u000d\u000aPostgreSQL\u000d\u000aThe first step is to find the year and quarter you are working with. Substring out the\u000d\u000ayear from inline view X (X.YRQ) using the SUBSTR function. To get the quarter, use\u000d\u000amodulus 10 on YRQ. Once you have the quarter, multiply by 3 to get the end month\u000d\u000afor the quarter. The results are shown here:\u000d\u000aselect substr(yrq,1,4) yr, mod(yrq,10)*3 mth\u000d\u000a from (\u000d\u000aselect 20051 yrq from t1 union all\u000d\u000aselect 20052 yrq from t1 union all\u000d\u000aselect 20053 yrq from t1 union all\u000d\u000aselect 20054 yrq from t1\u000d\u000a ) x\u000d\u000aYR MTH\u000d\u000a---- -------\u000d\u000a2005 3\u000d\u000a2005 6\u000d\u000a2005 9\u000d\u000a2005 12\u000d\u000a290 | Chapter 9: Date Manipulation","At this point, you have the year and end month for each quarter. Use those values to\u000d\u000aconstruct a date, specifically, the first day of the last month for each quarter. Use the\u000d\u000aconcatenation operator || to glue together the year and month, and then use the TO_\u000d\u000aDATE function to convert to a date:\u000d\u000aselect to_date(substr(yrq,1,4)||mod(yrq,10)*3,'yyyymm') q_end\u000d\u000a from (\u000d\u000aselect 20051 yrq from t1 union all\u000d\u000aselect 20052 yrq from t1 union all\u000d\u000aselect 20053 yrq from t1 union all\u000d\u000aselect 20054 yrq from t1\u000d\u000a ) x\u000d\u000aQ_END\u000d\u000a-----------\u000d\u000a01-MAR-2005\u000d\u000a01-JUN-2005\u000d\u000a01-SEP-2005\u000d\u000a01-DEC-2005\u000d\u000aThe values for Q_END are the first day of the last month of each quarter. To get to\u000d\u000athe last day of the month, add one month to Q_END and subtract one day. To find\u000d\u000athe start date for each quarter, subtract two months from Q_END. Cast the final\u000d\u000aresult as dates.\u000d\u000aMySQL\u000d\u000aThe first step is to find the year and quarter you are working with. Substring out the\u000d\u000ayear from inline view X (X.YRQ) using the SUBSTR function. To get the quarter, use\u000d\u000amodulus 10 on YRQ. Once you have the quarter, multiply by three to get the end\u000d\u000amonth for the quarter. The results are shown here:\u000d\u000aselect substr(yrq,1,4) yr, mod(yrq,10)*3 mth\u000d\u000a from (\u000d\u000aselect 20051 yrq from t1 union all\u000d\u000aselect 20052 yrq from t1 union all\u000d\u000aselect 20053 yrq from t1 union all\u000d\u000aselect 20054 yrq from t1\u000d\u000a ) x\u000d\u000aYR MTH\u000d\u000a---- ------\u000d\u000a2005 3\u000d\u000a2005 6\u000d\u000a2005 9\u000d\u000a2005 12\u000d\u000aAt this point, you have the year and end month for each quarter. Use those values to\u000d\u000aconstruct a date, specifically, the last day of each quarter. Use the CONCAT function\u000d\u000a9.9 Determining Quarter Start and End Dates for a Given Quarter | 291","to glue together the year and month, and then use the STR_TO_DATE function to\u000d\u000aconvert to a date. Use the LAST_DAY function to find the last day for each quarter:\u000d\u000aselect last_day(\u000d\u000a str_to_date(\u000d\u000a concat(\u000d\u000a substr(yrq,1,4),mod(yrq,10)*3),'%Y%m')) q_end\u000d\u000a from (\u000d\u000aselect 20051 as yrq from t1 union all\u000d\u000aselect 20052 as yrq from t1 union all\u000d\u000aselect 20053 as yrq from t1 union all\u000d\u000aselect 20054 as yrq from t1\u000d\u000a ) x\u000d\u000aQ_END\u000d\u000a-----------\u000d\u000a31-MAR-2005\u000d\u000a30-JUN-2005\u000d\u000a30-SEP-2005\u000d\u000a31-DEC-2005\u000d\u000aBecause you already have the end of each quarter, all that\u2019s left is to find the start date\u000d\u000afor each quarter. Use the DAY function to return the day of the month the end of each\u000d\u000aquarter falls on, and subtract that from Q_END using the ADDDATE function to\u000d\u000agive you the end of the prior month; add one day to bring you to the first day of the\u000d\u000alast month of each quarter. The last step is to use the DATE_ADD function to sub\u2010\u000d\u000atract two months from the first day of the last month of each quarter to get you to the\u000d\u000astart date for each quarter.\u000d\u000aSQL Server\u000d\u000aThe first step is to find the year and quarter you are working with. Substring out the\u000d\u000ayear from inline view X (X.YRQ) using the SUBSTRING function. To get the quarter,\u000d\u000ause modulus 10 on YRQ. Once you have the quarter, multiply by three to get the end\u000d\u000amonth for the quarter. The results are shown here:\u000d\u000aselect substring(yrq,1,4) yr, yrq%10*3 mth\u000d\u000a from (\u000d\u000aselect 20051 yrq from t1 union all\u000d\u000aselect 20052 yrq from t1 union all\u000d\u000aselect 20053 yrq from t1 union all\u000d\u000aselect 20054 yrq from t1\u000d\u000a ) x\u000d\u000aYR MTH\u000d\u000a---- ------\u000d\u000a2005 3\u000d\u000a2005 6\u000d\u000a2005 9\u000d\u000a2005 12\u000d\u000a292 | Chapter 9: Date Manipulation","At this point, you have the year and end month for each quarter. Use those values to\u000d\u000aconstruct a date, specifically, the first day of the last month for each quarter. Use the\u000d\u000aconcatenation operator + to glue together the year and month, and then use the \u000d\u000aCAST function to convert to a date:\u000d\u000aselect cast(substring(cast(yrq as varchar),1,4)+'-'+\u000d\u000a cast(yrq%10*3 as varchar)+'-1' as datetime) q_end\u000d\u000a from (\u000d\u000aselect 20051 yrq from t1 union all\u000d\u000aselect 20052 yrq from t1 union all\u000d\u000aselect 20053 yrq from t1 union all\u000d\u000aselect 20054 yrq from t1\u000d\u000a ) x\u000d\u000aQ_END\u000d\u000a-----------\u000d\u000a01-MAR-2005\u000d\u000a01-JUN-2005\u000d\u000a01-SEP-2005\u000d\u000a01-DEC-2005\u000d\u000aThe values for Q_END are the first day of the last month of each quarter. To get to\u000d\u000athe last day of the month, add one month to Q_END and subtract one day using the\u000d\u000aDATEADD function. To find the start date for each quarter, subtract two months\u000d\u000afrom Q_END using the DATEADD function.\u000d\u000a9.10 Filling in Missing Dates\u000d\u000aProblem\u000d\u000aYou need to generate a row for every date (or every month, week, or year) within a\u000d\u000agiven range. Such rowsets are often used to generate summary reports. For example,\u000d\u000ayou want to count the number of employees hired every month of every year in\u000d\u000awhich any employee has been hired. Examining the dates of all the employees hired,\u000d\u000athere have been hirings from 2000 to 2003:\u000d\u000aselect distinct\u000d\u000a extract(year from hiredate) as year\u000d\u000a from emp\u000d\u000aYEAR\u000d\u000a-----\u000d\u000a 2000\u000d\u000a 2001\u000d\u000a 2002\u000d\u000a 2003\u000d\u000aYou want to determine the number of employees hired each month from 2000 to\u000d\u000a2003. A portion of the desired result set is shown here:\u000d\u000a9.10 Filling in Missing Dates | 293","MTH NUM_HIRED\u000d\u000a----------- ----------\u000d\u000a01-JAN-2001 0\u000d\u000a01-FEB-2001 2\u000d\u000a01-MAR-2001 0\u000d\u000a01-APR-2001 1\u000d\u000a01-MAY-2001 1\u000d\u000a01-JUN-2001 1\u000d\u000a01-JUL-2001 0\u000d\u000a01-AUG-2001 0\u000d\u000a01-SEP-2001 2\u000d\u000a01-OCT-2001 0\u000d\u000a01-NOV-2001 1\u000d\u000a01-DEC-2001 2\u000d\u000aSolution\u000d\u000aThe trick here is that you want to return a row for each month even if no employee\u000d\u000awas hired (i.e., the count would be zero). Because there isn\u2019t an employee hired every\u000d\u000amonth between 2000 and 2003, you must generate those months yourself and then\u000d\u000aouter join to table EMP on HIREDATE (truncating the actual HIREDATE to its\u000d\u000amonth so it can match the generated months when possible).\u000d\u000aDB2\u000d\u000aUse the recursive WITH clause to generate every month (the first day of each month\u000d\u000afrom January 1, 2000, to December 1, 2003). Once you have all the months for the\u000d\u000arequired range of dates, outer join to table EMP and use the aggregate function\u000d\u000aCOUNT to count the number of hires for each month:\u000d\u000a 1 with x (start_date,end_date)\u000d\u000a 2 as (\u000d\u000a 3 select (min(hiredate)\u000d\u000a 4 dayofyear(min(hiredate)) day +1 day) start_date,\u000d\u000a 5 (max(hiredate)\u000d\u000a 6 dayofyear(max(hiredate)) day +1 day) +1 year end_date\u000d\u000a 7 from emp\u000d\u000a 8 union all\u000d\u000a 9 select start_date +1 month, end_date\u000d\u000a10 from x\u000d\u000a11 where (start_date +1 month) < end_date\u000d\u000a12 )\u000d\u000a13 select x.start_date mth, count(e.hiredate) num_hired\u000d\u000a14 from x left join emp e\u000d\u000a15 on (x.start_date = (e.hiredate-(day(hiredate)-1) day))\u000d\u000a16 group by x.start_date\u000d\u000a17 order by 1\u000d\u000a294 | Chapter 9: Date Manipulation","Oracle\u000d\u000aUse the CONNECT BY clause to generate each month between 2000 and 2003. Then\u000d\u000aouter join to table EMP and use the aggregate function COUNT to count the number\u000d\u000aof employees hired in each month:\u000d\u000a 1 with x\u000d\u000a 2 as (\u000d\u000a 3 select add_months(start_date,level-1) start_date\u000d\u000a 4 from (\u000d\u000a 5 select min(trunc(hiredate,'y')) start_date,\u000d\u000a 6 add_months(max(trunc(hiredate,'y')),12) end_date\u000d\u000a 7 from emp\u000d\u000a 8 )\u000d\u000a 9 connect by level <= months_between(end_date,start_date)\u000d\u000a10 )\u000d\u000a11 select x.start_date MTH, count(e.hiredate) num_hired\u000d\u000a12 from x left join emp e\u000d\u000a13 on (x.start_date = trunc(e.hiredate,'mm'))\u000d\u000a14 group by x.start_date\u000d\u000a15 order by 1\u000d\u000aPostgreSQL\u000d\u000aUse CTE to fill in the months since the earliest hire and then LEFT OUTER JOIN on\u000d\u000athe EMP table using the month and year of each generated month to enable the\u000d\u000aCOUNT of the number of hiredates in each period:\u000d\u000a with recursive x (start_date, end_date)\u000d\u000aas\u000d\u000a(\u000d\u000a select\u000d\u000a cast(min(hiredate) - (cast(extract(day from min(hiredate))\u000d\u000a as integer) - 1) as date)\u000d\u000a , max(hiredate)\u000d\u000a from emp\u000d\u000a union all\u000d\u000a select cast(start_date + interval '1 month' as date)\u000d\u000a , end_date\u000d\u000a from x\u000d\u000a where start_date < end_date\u000d\u000a )\u000d\u000a select x.start_date,count(hiredate)\u000d\u000a from x left join emp\u000d\u000a on (extract(month from start_date) =\u000d\u000a extract(month from emp.hiredate)\u000d\u000a and extract(year from start_date)\u000d\u000a = extract(year from emp.hiredate))\u000d\u000a group by x.start_date\u000d\u000a order by 1\u000d\u000a9.10 Filling in Missing Dates | 295","MySQL\u000d\u000aUse a recursive CTE to generate each month between the start and end dates, and\u000d\u000athen check for hires by using an outer join to table EMP:\u000d\u000a with recursive x (start_date,end_date)\u000d\u000a as\u000d\u000a (\u000d\u000a select\u000d\u000a adddate(min(hiredate),\u000d\u000a -dayofyear(min(hiredate))+1) start_date\u000d\u000a ,adddate(max(hiredate),\u000d\u000a -dayofyear(max(hiredate))+1) end_date\u000d\u000a from emp\u000d\u000a union all\u000d\u000a select date_add(start_date,interval 1 month)\u000d\u000a , end_date\u000d\u000a from x\u000d\u000a where date_add(start_date, interval 1 month) < end_date\u000d\u000a )\u000d\u000a select x.start_date mth, count(e.hiredate) num_hired\u000d\u000a from x left join emp e\u000d\u000a on (extract(year_month from start_date)\u000d\u000a =\u000d\u000a extract(year_month from e.hiredate))\u000d\u000a group by x.start_date\u000d\u000a order by 1;\u000d\u000aSQL Server\u000d\u000aUse the recursive WITH clause to generate every month (the first day of each month\u000d\u000afrom January 1, 2000, to December 1, 2003). Once you have all the months for the\u000d\u000arequired range of dates, outer join to table EMP and use the aggregate function\u000d\u000aCOUNT to count the number of hires for each month:\u000d\u000a1 with x (start_date,end_date)\u000d\u000a2 as (\u000d\u000a3 select (min(hiredate) -\u000d\u000a4 datepart(dy,min(hiredate))+1) start_date,\u000d\u000a5 dateadd(yy,1,\u000d\u000a6 (max(hiredate) -\u000d\u000a7 datepart(dy,max(hiredate))+1)) end_date\u000d\u000a8 from emp\u000d\u000a9 union all\u000d\u000a10 select dateadd(mm,1,start_date), end_date\u000d\u000a11 from x\u000d\u000a12 where dateadd(mm,1,start_date) < end_date\u000d\u000a13 )\u000d\u000a14 select x.start_date mth, count(e.hiredate) num_hired\u000d\u000a15 from x left join emp e\u000d\u000a16 on (x.start_date =\u000d\u000a296 | Chapter 9: Date Manipulation","17 dateadd(dd,-day(e.hiredate)+1,e.hiredate))\u000d\u000a18 group by x.start_date\u000d\u000a19 order by 1\u000d\u000aDiscussion\u000d\u000aDB2\u000d\u000aThe first step is to generate every month (actually the first day of each month) from\u000d\u000a2000 to 2003. Start using the DAYOFYEAR function on the MIN and MAX HIRE\u2010\u000d\u000aDATEs to find the boundary months:\u000d\u000aselect (min(hiredate)\u000d\u000a dayofyear(min(hiredate)) day +1 day) start_date,\u000d\u000a (max(hiredate)\u000d\u000a dayofyear(max(hiredate)) day +1 day) +1 year end_date\u000d\u000a from emp\u000d\u000aSTART_DATE END_DATE\u000d\u000a----------- -----------\u000d\u000a01-JAN-2000 01-JAN-2004\u000d\u000aYour next step is to repeatedly add months to START_DATE to return all the months\u000d\u000anecessary for the final result set. The value for END_DATE is one day more than it\u000d\u000ashould be. This is OK. As you recursively add months to START_DATE, you can stop\u000d\u000abefore you hit END_DATE. A portion of the months created is shown here:\u000d\u000awith x (start_date,end_date)\u000d\u000a as (\u000d\u000aselect (min(hiredate)\u000d\u000a dayofyear(min(hiredate)) day +1 day) start_date,\u000d\u000a (max(hiredate)\u000d\u000a dayofyear(max(hiredate)) day +1 day) +1 year end_date\u000d\u000a from emp\u000d\u000a union all\u000d\u000aselect start_date +1 month, end_date\u000d\u000a from x\u000d\u000a where (start_date +1 month) < end_date\u000d\u000a)\u000d\u000aselect *\u000d\u000a from x\u000d\u000aSTART_DATE END_DATE\u000d\u000a----------- -----------\u000d\u000a01-JAN-2000 01-JAN-2004\u000d\u000a01-FEB-2000 01-JAN-2004\u000d\u000a01-MAR-2000 01-JAN-2004\u000d\u000a\u2026\u000d\u000a01-OCT-2003 01-JAN-2004\u000d\u000a01-NOV-2003 01-JAN-2004\u000d\u000a01-DEC-2003 01-JAN-2004\u000d\u000a9.10 Filling in Missing Dates | 297","At this point, you have all the months you need, and you can simply outer join to\u000d\u000aEMP.HIREDATE. Because the day for each START_DATE is the first of the month,\u000d\u000atruncate EMP.HIREDATE to the first day of its month. Finally, use the aggregate\u000d\u000afunction COUNT on EMP.HIREDATE.\u000d\u000aOracle\u000d\u000aThe first step is to generate the first day of every for every month from 2000 to 2003. \u000d\u000aStart by using TRUNC and ADD_MONTHS together with the MIN and MAX\u000d\u000aHIREDATE values to find the boundary months:\u000d\u000aselect min(trunc(hiredate,'y')) start_date,\u000d\u000a add_months(max(trunc(hiredate,'y')),12) end_date\u000d\u000a from emp\u000d\u000aSTART_DATE END_DATE\u000d\u000a----------- -----------\u000d\u000a01-JAN-2000 01-JAN-2004\u000d\u000aThen repeatedly add months to START_DATE to return all the months necessary for\u000d\u000athe final result set. The value for END_DATE is one day more than it should be,\u000d\u000awhich is OK. As you recursively add months to START_DATE, you can stop before\u000d\u000ayou hit END_DATE. A portion of the months created is shown here:\u000d\u000awith x as (\u000d\u000aselect add_months(start_date,level-1) start_date\u000d\u000a from (\u000d\u000aselect min(trunc(hiredate,'y')) start_date,\u000d\u000a add_months(max(trunc(hiredate,'y')),12) end_date\u000d\u000a from emp\u000d\u000a )\u000d\u000a connect by level <= months_between(end_date,start_date)\u000d\u000a)\u000d\u000aselect *\u000d\u000a from x\u000d\u000aSTART_DATE\u000d\u000a-----------\u000d\u000a01-JAN-2000\u000d\u000a01-FEB-2000\u000d\u000a01-MAR-2000\u000d\u000a\u2026\u000d\u000a01-OCT-2003\u000d\u000a01-NOV-2003\u000d\u000a01-DEC-2003\u000d\u000aAt this point, you have all the months you need, and you can simply outer join to\u000d\u000aEMP.HIREDATE. Because the day for each START_DATE is the first of the month,\u000d\u000atruncate EMP.HIREDATE to the first day of the month it is in. The final step is to use\u000d\u000athe aggregate function COUNT on EMP.HIREDATE.\u000d\u000a298 | Chapter 9: Date Manipulation","PostgreSQL\u000d\u000aThis solution uses a CTE to generate the months you need and is similar to the subse\u2010\u000d\u000aquent solutions for MySQL and SQL Server. The first step is to create the boundary\u000d\u000adates using aggregate functions. You could simply find earliest and latest hire dates\u000d\u000ausing the MIN() and MAX() functions, but the output makes more sense if you find\u000d\u000athe first day of the month containing the earliest hire date.\u000d\u000aMySQL\u000d\u000aFirst, find the boundary dates by using the aggregate functions MIN and MAX along\u000d\u000awith the DAYOFYEAR and ADDDATE functions. The result set shown here is from\u000d\u000ainline view X:\u000d\u000awith recursive x (start_date,end_date)\u000d\u000a as (\u000d\u000a select\u000d\u000a adddate(min(hiredate),\u000d\u000a -dayofyear(min(hiredate))+1) start_date\u000d\u000a ,adddate(max(hiredate),\u000d\u000a -dayofyear(max(hiredate))+1) end_date\u000d\u000a from emp\u000d\u000a union all\u000d\u000a select date_add(start_date,interval 1 month)\u000d\u000a , end_date\u000d\u000a from x\u000d\u000a where date_add(start_date, interval 1 month) < end_date\u000d\u000a )\u000d\u000aselect * from x\u000d\u000a select adddate(min(hiredate),-dayofyear(min(hiredate))+1) min_hd,\u000d\u000a adddate(max(hiredate),-dayofyear(max(hiredate))+1) max_hd\u000d\u000a from emp\u000d\u000a MIN_HD MAX_HD\u000d\u000a ----------- -----------\u000d\u000a 01-JAN-2000 01-JAN-2003\u000d\u000aNext, increment MAX_HD to the last month of the year by the CTE:\u000d\u000aMTH\u000d\u000a-----------\u000d\u000a01-JAN-2000\u000d\u000a01-FEB-2000\u000d\u000a01-MAR-2000\u000d\u000a\u2026\u000d\u000a01-OCT-2003\u000d\u000a01-NOV-2003\u000d\u000a01-DEC-2003\u000d\u000aNow that you have all the months you need for the final result set, outer join to\u000d\u000aEMP.HIREDATE (be sure to truncate EMP.HIREDATE to the first day of the month)\u000d\u000a9.10 Filling in Missing Dates | 299","and use the aggregate function COUNT on EMP.HIREDATE to count the number of\u000d\u000ahires in each month.\u000d\u000aSQL Server\u000d\u000aBegin by generating every month (actually, the first day of each month) from 2000 to\u000d\u000a2003. Then find the boundary months by applying the DAYOFYEAR function to the\u000d\u000aMIN and MAX HIREDATEs:\u000d\u000aselect (min(hiredate) -\u000d\u000a datepart(dy,min(hiredate))+1) start_date,\u000d\u000a dateadd(yy,1,\u000d\u000a (max(hiredate) -\u000d\u000a datepart(dy,max(hiredate))+1)) end_date\u000d\u000a from emp\u000d\u000aSTART_DATE END_DATE\u000d\u000a----------- -----------\u000d\u000a01-JAN-2000 01-JAN-2004\u000d\u000aYour next step is to repeatedly add months to START_DATE to return all the months\u000d\u000anecessary for the final result set. The value for END_DATE is one day more than it\u000d\u000ashould be, which is OK, as you can stop recursively adding months to START_DATE\u000d\u000abefore you hit END_DATE. A portion of the months created is shown here:\u000d\u000awith x (start_date,end_date)\u000d\u000a as (\u000d\u000aselect (min(hiredate) -\u000d\u000a datepart(dy,min(hiredate))+1) start_date,\u000d\u000a dateadd(yy,1,\u000d\u000a (max(hiredate) -\u000d\u000a datepart(dy,max(hiredate))+1)) end_date\u000d\u000a from emp\u000d\u000a union all\u000d\u000aselect dateadd(mm,1,start_date), end_date\u000d\u000a from x\u000d\u000a where dateadd(mm,1,start_date) < end_date\u000d\u000a)\u000d\u000aselect *\u000d\u000a from x\u000d\u000aSTART_DATE END_DATE\u000d\u000a----------- -----------\u000d\u000a01-JAN-2000 01-JAN-2004\u000d\u000a01-FEB-2000 01-JAN-2004\u000d\u000a01-MAR-2000 01-JAN-2004\u000d\u000a\u2026\u000d\u000a01-OCT-2003 01-JAN-2004\u000d\u000a01-NOV-2003 01-JAN-2004\u000d\u000a01-DEC-2003 01-JAN-2004\u000d\u000a300 | Chapter 9: Date Manipulation","At this point, you have all the months you need. Simply outer join to EMP.HIRE\u2010\u000d\u000aDATE. Because the day for each START_DATE is the first of the month, truncate\u000d\u000aEMP.HIREDATE to the first day of the month. The final step is to use the aggregate\u000d\u000afunction COUNT on EMP.HIREDATE.\u000d\u000a9.11 Searching on Specific Units of Time\u000d\u000aProblem\u000d\u000aYou want to search for dates that match a given month, day of the week, or some\u000d\u000aother unit of time. For example, you want to find all employees hired in February or\u000d\u000aDecember, as well as employees hired on a Tuesday.\u000d\u000aSolution\u000d\u000aUse the functions supplied by your RDBMS to find month and weekday names for\u000d\u000adates. This particular recipe can be useful in various places. Consider, if you wanted\u000d\u000ato search HIREDATEs but wanted to ignore the year by extracting the month (or any\u000d\u000aother part of the HIREDATE you are interested in), you can do so. The example solu\u2010\u000d\u000ations to this problem search by month and weekday name. By studying the date for\u2010\u000d\u000amatting functions provided by your RDBMS, you can easily modify these solutions to\u000d\u000asearch by year, quarter, combination of year and quarter, month and year combina\u2010\u000d\u000ation, etc.\u000d\u000aDB2 and MySQL\u000d\u000aUse the functions MONTHNAME and DAYNAME to find the name of the month\u000d\u000aand weekday an employee was hired, respectively:\u000d\u000a1 select ename\u000d\u000a2 from emp\u000d\u000a3 where monthname(hiredate) in ('February','December')\u000d\u000a4 or dayname(hiredate) = 'Tuesday'\u000d\u000aOracle and PostgreSQL\u000d\u000aUse the function TO_CHAR to find the names of the month and weekday an\u000d\u000aemployee was hired. Use the function RTRIM to remove trailing whitespaces:\u000d\u000a1 select ename\u000d\u000a2 from emp\u000d\u000a3 where rtrim(to_char(hiredate,'month')) in ('february','december')\u000d\u000a4 or rtrim(to_char(hiredate,'day')) = 'tuesday'\u000d\u000a9.11 Searching on Specific Units of Time | 301","SQL Server\u000d\u000aUse the function DATENAME to find the names of the month and weekday an\u000d\u000aemployee was hired:\u000d\u000a1 select ename\u000d\u000a2 from emp\u000d\u000a3 where datename(m,hiredate) in ('February','December')\u000d\u000a4 or datename(dw,hiredate) = 'Tuesday'\u000d\u000aDiscussion\u000d\u000aThe key to each solution is simply knowing which functions to use and how to use\u000d\u000athem. To verify what the return values are, put the functions in the SELECT clause\u000d\u000aand examine the output. Listed here is the result set for employees in DEPTNO 10\u000d\u000a(using SQL Server syntax):\u000d\u000aselect ename,datename(m,hiredate) mth,datename(dw,hiredate) dw\u000d\u000a from emp\u000d\u000a where deptno = 10\u000d\u000aENAME MTH DW\u000d\u000a------ --------- -----------\u000d\u000aCLARK June Tuesday\u000d\u000aKING November Tuesday\u000d\u000aMILLER January Saturday\u000d\u000aOnce you know what the function(s) return, finding rows using the functions shown\u000d\u000ain each of the solutions is easy.\u000d\u000a9.12 Comparing Records Using Specific Parts of a Date\u000d\u000aProblem\u000d\u000aYou want to find which employees have been hired on the same month and weekday.\u000d\u000aFor example, if an employee was hired on Monday, March 10, 2008, and another\u000d\u000aemployee was hired on Monday, March 2, 2001, you want those two to come up as a\u000d\u000amatch since the day of week and month match. In table EMP, only three employees\u000d\u000ameet this requirement. You want to return the following result set:\u000d\u000aMSG\u000d\u000a------------------------------------------------------\u000d\u000aJAMES was hired on the same month and weekday as FORD\u000d\u000aSCOTT was hired on the same month and weekday as JAMES\u000d\u000aSCOTT was hired on the same month and weekday as FORD\u000d\u000a302 | Chapter 9: Date Manipulation","Solution\u000d\u000aBecause you want to compare one employee\u2019s HIREDATE with the HIREDATE of the\u000d\u000aother employees, you will need to self-join table EMP. That makes each possible com\u2010\u000d\u000abination of HIREDATEs available for you to compare. Then, simply extract the week\u2010\u000d\u000aday and month from each HIREDATE and compare.\u000d\u000aDB2\u000d\u000aAfter self-joining table EMP, use the function DAYOFWEEK to return the numeric\u000d\u000aday of the week. Use the function MONTHNAME to return the name of the month:\u000d\u000a1 select a.ename ||\u000d\u000a2 ' was hired on the same month and weekday as '||\u000d\u000a3 b.ename msg\u000d\u000a4 from emp a, emp b\u000d\u000a5 where (dayofweek(a.hiredate),monthname(a.hiredate)) =\u000d\u000a6 (dayofweek(b.hiredate),monthname(b.hiredate))\u000d\u000a7 and a.empno < b.empno\u000d\u000a8 order by a.ename\u000d\u000aOracle and PostgreSQL\u000d\u000aAfter self-joining table EMP, use the TO_CHAR function to format the HIREDATE\u000d\u000ainto weekday and month for comparison:\u000d\u000a1 select a.ename ||\u000d\u000a2 ' was hired on the same month and weekday as '||\u000d\u000a3 b.ename as msg\u000d\u000a4 from emp a, emp b\u000d\u000a5 where to_char(a.hiredate,'DMON') =\u000d\u000a6 to_char(b.hiredate,'DMON')\u000d\u000a7 and a.empno < b.empno\u000d\u000a8 order by a.ename\u000d\u000aMySQL\u000d\u000aAfter self-joining table EMP, use the DATE_FORMAT function to format the HIRE\u2010\u000d\u000aDATE into weekday and month for comparison:\u000d\u000a1 select concat(a.ename,\u000d\u000a2 ' was hired on the same month and weekday as ',\u000d\u000a3 b.ename) msg\u000d\u000a4 from emp a, emp b\u000d\u000a5 where date_format(a.hiredate,'%w%M') =\u000d\u000a6 date_format(b.hiredate,'%w%M')\u000d\u000a7 and a.empno < b.empno\u000d\u000a8 order by a.ename\u000d\u000a9.12 Comparing Records Using Specific Parts of a Date | 303","SQL Server\u000d\u000aAfter self-joining table EMP, use the DATENAME function to format the HIREDATE\u000d\u000ainto weekday and month for comparison:\u000d\u000a1 select a.ename +\u000d\u000a2 ' was hired on the same month and weekday as '+\u000d\u000a3 b.ename msg\u000d\u000a4 from emp a, emp b\u000d\u000a5 where datename(dw,a.hiredate) = datename(dw,b.hiredate)\u000d\u000a6 and datename(m,a.hiredate) = datename(m,b.hiredate)\u000d\u000a7 and a.empno < b.empno\u000d\u000a8 order by a.ename\u000d\u000aDiscussion\u000d\u000aThe only difference between the solutions is the date function used to format the\u000d\u000aHIREDATE. We\u2019ll use the Oracle/PostgreSQL solution in this discussion (because it\u2019s\u000d\u000athe shortest to type out), but the explanation holds true for the other solutions as\u000d\u000awell.\u000d\u000aThe first step is to self-join EMP so that each employee has access to the other\u000d\u000aemployees\u2019 HIREDATEs. Consider the results of the query shown here (filtered for\u000d\u000aSCOTT):\u000d\u000aselect a.ename as scott, a.hiredate as scott_hd,\u000d\u000a b.ename as other_emps, b.hiredate as other_hds\u000d\u000a from emp a, emp b\u000d\u000a where a.ename = 'SCOTT'\u000d\u000a and a.empno != b.empno\u000d\u000aSCOTT SCOTT_HD OTHER_EMPS OTHER_HDS\u000d\u000a---------- ----------- ---------- -----------\u000d\u000aSCOTT 09-DEC-2002 SMITH 17-DEC-2000\u000d\u000aSCOTT 09-DEC-2002 ALLEN 20-FEB-2001\u000d\u000aSCOTT 09-DEC-2002 WARD 22-FEB-2001\u000d\u000aSCOTT 09-DEC-2002 JONES 02-APR-2001\u000d\u000aSCOTT 09-DEC-2002 MARTIN 28-SEP-2001\u000d\u000aSCOTT 09-DEC-2002 BLAKE 01-MAY-2001\u000d\u000aSCOTT 09-DEC-2002 CLARK 09-JUN-2001\u000d\u000aSCOTT 09-DEC-2002 KING 17-NOV-2001\u000d\u000aSCOTT 09-DEC-2002 TURNER 08-SEP-2001\u000d\u000aSCOTT 09-DEC-2002 ADAMS 12-JAN-2003\u000d\u000aSCOTT 09-DEC-2002 JAMES 03-DEC-2001\u000d\u000aSCOTT 09-DEC-2002 FORD 03-DEC-2001\u000d\u000aSCOTT 09-DEC-2002 MILLER 23-JAN-2002\u000d\u000aBy self-joining table EMP, you can compare SCOTT\u2019s HIREDATE to the HIREDATE\u000d\u000aof all the other employees. The filter on EMPNO is so that SCOTT\u2019s HIREDATE is\u000d\u000anot returned as one of the OTHER_HDS. The next step is to use your RDBMS\u2019s\u000d\u000a304 | Chapter 9: Date Manipulation","supplied date formatting function(s) to compare the weekday and month of the HIR\u2010\u000d\u000aEDATEs and keep only those that match:\u000d\u000aselect a.ename as emp1, a.hiredate as emp1_hd,\u000d\u000a b.ename as emp2, b.hiredate as emp2_hd\u000d\u000a from emp a, emp b\u000d\u000a where to_char(a.hiredate,'DMON') =\u000d\u000a to_char(b.hiredate,'DMON')\u000d\u000a and a.empno != b.empno\u000d\u000a order by 1\u000d\u000aEMP1 EMP1_HD EMP2 EMP2_HD\u000d\u000a---------- ----------- ---------- -----------\u000d\u000aFORD 03-DEC-2001 SCOTT 09-DEC-2002\u000d\u000aFORD 03-DEC-2001 JAMES 03-DEC-2001\u000d\u000aJAMES 03-DEC-2001 SCOTT 09-DEC-2002\u000d\u000aJAMES 03-DEC-2001 FORD 03-DEC-2001\u000d\u000aSCOTT 09-DEC-2002 JAMES 03-DEC-2001\u000d\u000aSCOTT 09-DEC-2002 FORD 03-DEC-2001\u000d\u000aAt this point, the HIREDATEs are correctly matched, but there are six rows in the\u000d\u000aresult set rather than the three in the \u201cProblem\u201d section of this recipe. The reason for\u000d\u000athe extra rows is the filter on EMPNO. By using \u201cnot equals,\u201d you do not filter out the\u000d\u000areciprocals. For example, the first row matches FORD and SCOTT, and the last row\u000d\u000amatches SCOTT and FORD. The six rows in the result set are technically accurate but\u000d\u000aredundant. To remove the redundancy, use \u201cless than\u201d (the HIREDATEs are removed\u000d\u000ato bring the intermediate queries closer to the final result set):\u000d\u000aselect a.ename as emp1, b.ename as emp2\u000d\u000a from emp a, emp b\u000d\u000a where to_char(a.hiredate,'DMON') =\u000d\u000a to_char(b.hiredate,'DMON')\u000d\u000a and a.empno < b.empno\u000d\u000a order by 1\u000d\u000aEMP1 EMP2\u000d\u000a---------- ----------\u000d\u000aJAMES FORD\u000d\u000aSCOTT JAMES\u000d\u000aSCOTT FORD\u000d\u000aThe final step is to simply concatenate the result set to form the message.\u000d\u000a9.13 Identifying Overlapping Date Ranges\u000d\u000aProblem\u000d\u000aYou want to find all instances of an employee starting a new project before ending an\u000d\u000aexisting project. Consider table EMP_PROJECT:\u000d\u000a9.13 Identifying Overlapping Date Ranges | 305","select *\u000d\u000a from emp_project\u000d\u000aEMPNO ENAME PROJ_ID PROJ_START PROJ_END\u000d\u000a----- ---------- ------- ----------- -----------\u000d\u000a7782 CLARK 1 16-JUN-2005 18-JUN-2005\u000d\u000a7782 CLARK 4 19-JUN-2005 24-JUN-2005\u000d\u000a7782 CLARK 7 22-JUN-2005 25-JUN-2005\u000d\u000a7782 CLARK 10 25-JUN-2005 28-JUN-2005\u000d\u000a7782 CLARK 13 28-JUN-2005 02-JUL-2005\u000d\u000a7839 KING 2 17-JUN-2005 21-JUN-2005\u000d\u000a7839 KING 8 23-JUN-2005 25-JUN-2005\u000d\u000a7839 KING 14 29-JUN-2005 30-JUN-2005\u000d\u000a7839 KING 11 26-JUN-2005 27-JUN-2005\u000d\u000a7839 KING 5 20-JUN-2005 24-JUN-2005\u000d\u000a7934 MILLER 3 18-JUN-2005 22-JUN-2005\u000d\u000a7934 MILLER 12 27-JUN-2005 28-JUN-2005\u000d\u000a7934 MILLER 15 30-JUN-2005 03-JUL-2005\u000d\u000a7934 MILLER 9 24-JUN-2005 27-JUN-2005\u000d\u000a7934 MILLER 6 21-JUN-2005 23-JUN-2005\u000d\u000aLooking at the results for employee KING, you see that KING began PROJ_ID 8\u000d\u000abefore finishing PROJ_ID 5 and began PROJ_ID 5 before finishing PROJ_ID 2. You\u000d\u000awant to return the following result set:\u000d\u000aEMPNO ENAME MSG\u000d\u000a----- ---------- --------------------------------\u000d\u000a7782 CLARK project 7 overlaps project 4\u000d\u000a7782 CLARK project 10 overlaps project 7\u000d\u000a7782 CLARK project 13 overlaps project 10\u000d\u000a7839 KING project 8 overlaps project 5\u000d\u000a7839 KING project 5 overlaps project 2\u000d\u000a7934 MILLER project 12 overlaps project 9\u000d\u000a7934 MILLER project 6 overlaps project 3\u000d\u000aSolution\u000d\u000aThe key here is to find rows where PROJ_START (the date the new project starts)\u000d\u000aoccurs on or after another project\u2019s PROJ_START date and on or before that other\u000d\u000aproject\u2019s PROJ_END date. To begin, you need to be able to compare each project with\u000d\u000aeach other project (for the same employee). By self-joining EMP_PROJECT on\u000d\u000aemployee, you generate every possible combination of two projects for each\u000d\u000aemployee. To find the overlaps, simply find the rows where PROJ_START for any\u000d\u000aPROJ_ID falls between PROJ_START and PROJ_END for another PROJ_ID by the\u000d\u000asame employee.\u000d\u000aDB2, PostgreSQL, and Oracle\u000d\u000aSelf-join EMP_PROJECT. Then use the concatenation operator || to construct the\u000d\u000amessage that explains which projects overlap:\u000d\u000a306 | Chapter 9: Date Manipulation","1 select a.empno,a.ename,\u000d\u000a2 'project '||b.proj_id||\u000d\u000a3 ' overlaps project '||a.proj_id as msg\u000d\u000a4 from emp_project a,\u000d\u000a5 emp_project b\u000d\u000a6 where a.empno = b.empno\u000d\u000a7 and b.proj_start >= a.proj_start\u000d\u000a8 and b.proj_start <= a.proj_end\u000d\u000a9 and a.proj_id != b.proj_id\u000d\u000aMySQL\u000d\u000aSelf-join EMP_PROJECT. Then use the CONCAT function to construct the message\u000d\u000athat explains which projects overlap:\u000d\u000a1 select a.empno,a.ename,\u000d\u000a2 concat('project ',b.proj_id,\u000d\u000a3 ' overlaps project ',a.proj_id) as msg\u000d\u000a4 from emp_project a,\u000d\u000a5 emp_project b\u000d\u000a6 where a.empno = b.empno\u000d\u000a7 and b.proj_start >= a.proj_start\u000d\u000a8 and b.proj_start <= a.proj_end\u000d\u000a9 and a.proj_id != b.proj_id\u000d\u000aSQL Server\u000d\u000aSelf-join EMP_PROJECT. Then use the concatenation operator + to construct the\u000d\u000amessage that explains which projects overlap:\u000d\u000a1 select a.empno,a.ename,\u000d\u000a2 'project '+b.proj_id+\u000d\u000a3 ' overlaps project '+a.proj_id as msg\u000d\u000a4 from emp_project a,\u000d\u000a5 emp_project b\u000d\u000a6 where a.empno = b.empno\u000d\u000a7 and b.proj_start >= a.proj_start\u000d\u000a8 and b.proj_start <= a.proj_end\u000d\u000a9 and a.proj_id != b.proj_id\u000d\u000aDiscussion\u000d\u000aThe only difference between the solutions lies in the string concatenation, so one dis\u2010\u000d\u000acussion using the DB2 syntax will cover all three solutions. The first step is a self-join\u000d\u000aof EMP_PROJECT so that the PROJ_START dates can be compared among the dif\u2010\u000d\u000aferent projects. The output of the self-join for employee KING is shown here. You can\u000d\u000aobserve how each project can \u201csee\u201d the other projects:\u000d\u000a9.13 Identifying Overlapping Date Ranges | 307","select a.ename,\u000d\u000a a.proj_id as a_id,\u000d\u000a a.proj_start as a_start,\u000d\u000a a.proj_end as a_end,\u000d\u000a b.proj_id as b_id,\u000d\u000a b.proj_start as b_start\u000d\u000a from emp_project a,\u000d\u000a emp_project b\u000d\u000a where a.ename = 'KING'\u000d\u000a and a.empno = b.empno\u000d\u000a and a.proj_id != b.proj_id\u000d\u000aorder by 2\u000d\u000aENAME A_ID A_START A_END B_ID B_START\u000d\u000a------ ----- ----------- ----------- ----- -----------\u000d\u000aKING 2 17-JUN-2005 21-JUN-2005 8 23-JUN-2005\u000d\u000aKING 2 17-JUN-2005 21-JUN-2005 14 29-JUN-2005\u000d\u000aKING 2 17-JUN-2005 21-JUN-2005 11 26-JUN-2005\u000d\u000aKING 2 17-JUN-2005 21-JUN-2005 5 20-JUN-2005\u000d\u000aKING 5 20-JUN-2005 24-JUN-2005 2 17-JUN-2005\u000d\u000aKING 5 20-JUN-2005 24-JUN-2005 8 23-JUN-2005\u000d\u000aKING 5 20-JUN-2005 24-JUN-2005 11 26-JUN-2005\u000d\u000aKING 5 20-JUN-2005 24-JUN-2005 14 29-JUN-2005\u000d\u000aKING 8 23-JUN-2005 25-JUN-2005 2 17-JUN-2005\u000d\u000aKING 8 23-JUN-2005 25-JUN-2005 14 29-JUN-2005\u000d\u000aKING 8 23-JUN-2005 25-JUN-2005 5 20-JUN-2005\u000d\u000aKING 8 23-JUN-2005 25-JUN-2005 11 26-JUN-2005\u000d\u000aKING 11 26-JUN-2005 27-JUN-2005 2 17-JUN-2005\u000d\u000aKING 11 26-JUN-2005 27-JUN-2005 8 23-JUN-2005\u000d\u000aKING 11 26-JUN-2005 27-JUN-2005 14 29-JUN-2005\u000d\u000aKING 11 26-JUN-2005 27-JUN-2005 5 20-JUN-2005\u000d\u000aKING 14 29-JUN-2005 30-JUN-2005 2 17-JUN-2005\u000d\u000aKING 14 29-JUN-2005 30-JUN-2005 8 23-JUN-2005\u000d\u000aKING 14 29-JUN-2005 30-JUN-2005 5 20-JUN-2005\u000d\u000aKING 14 29-JUN-2005 30-JUN-2005 11 26-JUN-2005\u000d\u000aAs you can see from the result set, the self-join makes finding overlapping dates easy:\u000d\u000asimply return each row where B_START occurs between A_START and A_END. If\u000d\u000ayou look at the WHERE clause on lines 7 and 8 of the solution:\u000d\u000aand b.proj_start >= a.proj_start\u000d\u000aand b.proj_start <= a.proj_end\u000d\u000ait is doing just that. Once you have the required rows, constructing the messages is\u000d\u000ajust a matter of concatenating the return values.\u000d\u000aOracle users can use the window function LEAD OVER to avoid the self-join, if the\u000d\u000amaximum number of projects per employee is fixed. This can come in handy if the\u000d\u000aself-join is expensive for your particular results (if the self-join requires more resour\u2010\u000d\u000aces than the sorts needed for LEAD OVER). For example, consider the alternative for\u000d\u000aemployee KING using LEAD OVER:\u000d\u000a308 | Chapter 9: Date Manipulation","select empno,\u000d\u000a ename,\u000d\u000a proj_id,\u000d\u000a proj_start,\u000d\u000a proj_end,\u000d\u000a case\u000d\u000a when lead(proj_start,1)over(order by proj_start)\u000d\u000a between proj_start and proj_end\u000d\u000a then lead(proj_id)over(order by proj_start)\u000d\u000a when lead(proj_start,2)over(order by proj_start)\u000d\u000a between proj_start and proj_end\u000d\u000a then lead(proj_id)over(order by proj_start)\u000d\u000a when lead(proj_start,3)over(order by proj_start)\u000d\u000a between proj_start and proj_end\u000d\u000a then lead(proj_id)over(order by proj_start)\u000d\u000a when lead(proj_start,4)over(order by proj_start)\u000d\u000a between proj_start and proj_end\u000d\u000a then lead(proj_id)over(order by proj_start)\u000d\u000a end is_overlap\u000d\u000a from emp_project\u000d\u000a where ename = 'KING'\u000d\u000aEMPNO ENAME PROJ_ID PROJ_START PROJ_END IS_OVERLAP\u000d\u000a----- ------ ------- ----------- ----------- ----------\u000d\u000a7839 KING 2 17-JUN-2005 21-JUN-2005 5\u000d\u000a7839 KING 5 20-JUN-2005 24-JUN-2005 8\u000d\u000a7839 KING 8 23-JUN-2005 25-JUN-2005\u000d\u000a7839 KING 11 26-JUN-2005 27-JUN-2005\u000d\u000a7839 KING 14 29-JUN-2005 30-JUN-2005\u000d\u000aBecause the number of projects is fixed at five for employee KING, you can use\u000d\u000aLEAD OVER to examine the dates of all the projects without a self-join. From here,\u000d\u000aproducing the final result set is easy. Simply keep the rows where IS_OVERLAP is not\u000d\u000aNULL:\u000d\u000aselect empno,ename,\u000d\u000a 'project '||is_overlap||\u000d\u000a ' overlaps project '||proj_id msg\u000d\u000a from (\u000d\u000aselect empno,\u000d\u000a ename,\u000d\u000a proj_id,\u000d\u000a proj_start,\u000d\u000a proj_end,\u000d\u000a case\u000d\u000a when lead(proj_start,1)over(order by proj_start)\u000d\u000a between proj_start and proj_end\u000d\u000a then lead(proj_id)over(order by proj_start)\u000d\u000a when lead(proj_start,2)over(order by proj_start)\u000d\u000a between proj_start and proj_end\u000d\u000a then lead(proj_id)over(order by proj_start)\u000d\u000a when lead(proj_start,3)over(order by proj_start)\u000d\u000a9.13 Identifying Overlapping Date Ranges | 309"," between proj_start and proj_end\u000d\u000a then lead(proj_id)over(order by proj_start)\u000d\u000a when lead(proj_start,4)over(order by proj_start)\u000d\u000a between proj_start and proj_end\u000d\u000a then lead(proj_id)over(order by proj_start)\u000d\u000a end is_overlap\u000d\u000a from emp_project\u000d\u000a where ename = 'KING'\u000d\u000a )\u000d\u000a where is_overlap is not null\u000d\u000aEMPNO ENAME MSG\u000d\u000a----- ------ --------------------------------\u000d\u000a7839 KING project 5 overlaps project 2\u000d\u000a7839 KING project 8 overlaps project 5\u000d\u000aTo allow the solution to work for all employees (not just KING), partition by ENAME\u000d\u000ain the LEAD OVER function:\u000d\u000aselect empno,ename,\u000d\u000a 'project '||is_overlap||\u000d\u000a ' overlaps project '||proj_id msg\u000d\u000a from (\u000d\u000aselect empno,\u000d\u000a ename,\u000d\u000a proj_id,\u000d\u000a proj_start,\u000d\u000a proj_end,\u000d\u000a case\u000d\u000a when lead(proj_start,1)over(partition by ename\u000d\u000a order by proj_start)\u000d\u000a between proj_start and proj_end\u000d\u000a then lead(proj_id)over(partition by ename\u000d\u000a order by proj_start)\u000d\u000a when lead(proj_start,2)over(partition by ename\u000d\u000a order by proj_start)\u000d\u000a between proj_start and proj_end\u000d\u000a then lead(proj_id)over(partition by ename\u000d\u000a order by proj_start)\u000d\u000a when lead(proj_start,3)over(partition by ename\u000d\u000a order by proj_start)\u000d\u000a between proj_start and proj_end\u000d\u000a then lead(proj_id)over(partition by ename\u000d\u000a order by proj_start)\u000d\u000a when lead(proj_start,4)over(partition by ename\u000d\u000a order by proj_start)\u000d\u000a between proj_start and proj_end\u000d\u000a then lead(proj_id)over(partition by ename\u000d\u000a order by proj_start)\u000d\u000a end is_overlap\u000d\u000a from emp_project\u000d\u000a )\u000d\u000awhere is_overlap is not null\u000d\u000a310 | Chapter 9: Date Manipulation","EMPNO ENAME MSG\u000d\u000a----- ------ -------------------------------\u000d\u000a7782 CLARK project 7 overlaps project 4\u000d\u000a7782 CLARK project 10 overlaps project 7\u000d\u000a7782 CLARK project 13 overlaps project 10\u000d\u000a7839 KING project 5 overlaps project 2\u000d\u000a7839 KING project 8 overlaps project 5\u000d\u000a7934 MILLER project 6 overlaps project 3\u000d\u000a7934 MILLER project 12 overlaps project 9\u000d\u000a9.14 Summing Up\u000d\u000aDate manipulations are a common problem for anyone querying a database\u2014a series\u000d\u000aof events stored with their dates inspires business users to ask creative date-based\u000d\u000aquestions. At the same time, dates are one of the less standardized areas of SQLs\u000d\u000abetween vendors. We hope that you take away from this chapter an idea of how even\u000d\u000awhen the syntax is different, there is still a common logic that can be applied to quer\u2010\u000d\u000aies that use dates.\u000d\u000a9.14 Summing Up | 311","","CHAPTER 10\u000d\u000aWorking with Ranges\u000d\u000aThis chapter is about \u201ceveryday\u201d queries that involve ranges. Ranges are common in\u000d\u000aeveryday life. For example, projects that we work on range over consecutive periods\u000d\u000aof time. In SQL, it\u2019s often necessary to search for ranges, or to generate ranges, or to\u000d\u000aotherwise manipulate range-based data. The queries you\u2019ll read about here are\u000d\u000aslightly more involved than the queries found in the preceding chapters, but they are\u000d\u000ajust as common, and they\u2019ll begin to give you a sense of what SQL can really do for\u000d\u000ayou when you learn to take full advantage of it.\u000d\u000a10.1 Locating a Range of Consecutive Values\u000d\u000aProblem\u000d\u000aYou want to determine which rows represent a range of consecutive projects. Con\u2010\u000d\u000asider the following result set from view V, which contains data about a project and its\u000d\u000astart and end dates:\u000d\u000aselect *\u000d\u000a from V\u000d\u000aPROJ_ID PROJ_START PROJ_END\u000d\u000a------- ----------- -----------\u000d\u000a 1 01-JAN-2020 02-JAN-2020\u000d\u000a 2 02-JAN-2020 03-JAN-2020\u000d\u000a 3 03-JAN-2020 04-JAN-2020\u000d\u000a 4 04-JAN-2020 05-JAN-2020\u000d\u000a 5 06-JAN-2020 07-JAN-2020\u000d\u000a 6 16-JAN-2020 17-JAN-2020\u000d\u000a 7 17-JAN-2020 18-JAN-2020\u000d\u000a 8 18-JAN-2020 19-JAN-2020\u000d\u000a 9 19-JAN-2020 20-JAN-2020\u000d\u000a 10 21-JAN-2020 22-JAN-2020\u000d\u000a313"," 11 26-JAN-2020 27-JAN-2020\u000d\u000a 12 27-JAN-2020 28-JAN-2020\u000d\u000a 13 28-JAN-2020 29-JAN-2020\u000d\u000a 14 29-JAN-2020 30-JAN-2020\u000d\u000aExcluding the first row, each row\u2019s PROJ_START should equal the PROJ_END of the\u000d\u000arow before it (\u201cbefore\u201d is defined as PROJ_ID\u20131 for the current row). Examining the\u000d\u000afirst five rows from view V, PROJ_IDs 1 through 3 are part of the same \u201cgroup\u201d as\u000d\u000aeach PROJ_END equals the PROJ_START of the row after it. Because you want to\u000d\u000afind the range of dates for consecutive projects, you would like to return all rows\u000d\u000awhere the current PROJ_END equals the next row\u2019s PROJ_START. If the first five\u000d\u000arows comprised the entire result set, you would like to return only the first three\u000d\u000arows. The final result set (using all 14 rows from view V) should be:\u000d\u000aPROJ_ID PROJ_START PROJ_END\u000d\u000a------- ----------- -----------\u000d\u000a 1 01-JAN-2020 02-JAN-2020\u000d\u000a 2 02-JAN-2020 03-JAN-2020\u000d\u000a 3 03-JAN-2020 04-JAN-2020\u000d\u000a 6 16-JAN-2020 17-JAN-2020\u000d\u000a 7 17-JAN-2020 18-JAN-2020\u000d\u000a 8 18-JAN-2020 19-JAN-2020\u000d\u000a 11 26-JAN-2020 27-JAN-2020\u000d\u000a 12 27-JAN-2020 28-JAN-2020\u000d\u000a 13 28-JAN-2020 29-JAN-2020\u000d\u000aThe rows with PROJ_IDs 4, 5, 9, 10, and 14 are excluded from this result set because\u000d\u000athe PROJ_END of each of these rows does not match the PROJ_START of the row\u000d\u000afollowing it.\u000d\u000aSolution\u000d\u000aThis solution takes best advantage of the window function LEAD OVER to look at\u000d\u000athe \u201cnext\u201d row\u2019s BEGIN_DATE, thus avoiding the need to self-join, which was neces\u2010\u000d\u000asary before window functions were widely introduced:\u000d\u000a1 select proj_id, proj_start, proj_end\u000d\u000a2 from (\u000d\u000a3 select proj_id, proj_start, proj_end,\u000d\u000a4 lead(proj_start)over(order by proj_id) next_proj_start\u000d\u000a5 from V\u000d\u000a6 ) alias\u000d\u000a7 where next_proj_start = proj_end\u000d\u000a314 | Chapter 10: Working with Ranges","Discussion\u000d\u000aDB2, MySQL, PostgreSQL, SQL Server, and Oracle\u000d\u000aAlthough it is possible to develop a solution using a self-join, the window function\u000d\u000aLEAD OVER is perfect for this type of problem, and more intuitive. The function\u000d\u000aLEAD OVER allows you to examine other rows without performing a self-join\u000d\u000a(though the function must impose order on the result set to do so). Consider the\u000d\u000aresults of the inline view (lines 3\u20135) for IDs 1 and 4:\u000d\u000aselect *\u000d\u000a from (\u000d\u000aselect proj_id, proj_start, proj_end,\u000d\u000a lead(proj_start)over(order by proj_id) next_proj_start\u000d\u000a from v\u000d\u000a )\u000d\u000a where proj_id in ( 1, 4 )\u000d\u000aPROJ_ID PROJ_START PROJ_END NEXT_PROJ_START\u000d\u000a------- ----------- ----------- ---------------\u000d\u000a 1 01-JAN-2020 02-JAN-2020 02-JAN-2020\u000d\u000a 4 04-JAN-2020 05-JAN-2020 06-JAN-2020\u000d\u000aExamining this snippet of code and its result set, it is particularly easy to see why\u000d\u000aPROJ_ID 4 is excluded from the final result set of the complete solution. It\u2019s excluded\u000d\u000abecause its PROJ_END date of 05-JAN-2020 does not match the \u201cnext\u201d project\u2019s start\u000d\u000adate of 06-JAN-2020.\u000d\u000aThe function LEAD OVER is extremely handy when it comes to problems such as\u000d\u000athis one, particularly when examining partial results. When working with window\u000d\u000afunctions, keep in mind that they are evaluated after the FROM and WHERE clauses,\u000d\u000aso the LEAD OVER function in the preceding query must be embedded within an\u000d\u000ainline view. Otherwise, the LEAD OVER function is applied to the result set after the\u000d\u000aWHERE clause has filtered out all rows except for PROJ_ID\u2019s 1 and 4.\u000d\u000aNow, depending on how you view the data, you may very well want to include\u000d\u000aPROJ_ID 4 in the final result set. Consider the first five rows from view V:\u000d\u000aselect *\u000d\u000a from V\u000d\u000a where proj_id <= 5\u000d\u000aPROJ_ID PROJ_START PROJ_END\u000d\u000a------- ----------- -----------\u000d\u000a 1 01-JAN-2020 02-JAN-2020\u000d\u000a 2 02-JAN-2020 03-JAN-2020\u000d\u000a 3 03-JAN-2020 04-JAN-2020\u000d\u000a 4 04-JAN-2020 05-JAN-2020\u000d\u000a 5 06-JAN-2020 07-JAN-2020\u000d\u000a10.1 Locating a Range of Consecutive Values | 315","If your requirement is such that PROJ_ID 4 is in fact contiguous (because PROJ_\u000d\u000aSTART for PROJ_ID 4 matches PROJ_END for PROJ_ID 3), and that only PROJ_ ID\u000d\u000a5 should be discarded, the proposed solution for this recipe is incorrect (!) or, at the\u000d\u000avery least, incomplete:\u000d\u000aselect proj_id, proj_start, proj_end\u000d\u000a from (\u000d\u000aselect proj_id, proj_start, proj_end, \u000d\u000a lead(proj_start)over(order by proj_id) next_start\u000d\u000a from V\u000d\u000awhere proj_id <= 5\u000d\u000a )\u000d\u000awhere proj_end = next_start\u000d\u000aPROJ_ID PROJ_START PROJ_END\u000d\u000a------- ----------- -----------\u000d\u000a 1 01-JAN-2020 02-JAN-2020\u000d\u000a 2 02-JAN-2020 03-JAN-2020\u000d\u000a 3 03-JAN-2020 04-JAN-2020\u000d\u000aIf you believe PROJ_ID 4 should be included, simply add LAG OVER to the query\u000d\u000aand use an additional filter in the WHERE clause:\u000d\u000aselect proj_id, proj_start, proj_end\u000d\u000a from (\u000d\u000aselect proj_id, proj_start, proj_end, \u000d\u000a lead(proj_start)over(order by proj_id) next_start,\u000d\u000a lag(proj_end)over(order by proj_id) last_end\u000d\u000a from V\u000d\u000awhere proj_id <= 5\u000d\u000a )\u000d\u000awhere proj_end = next_start\u000d\u000a or proj_start = last_end\u000d\u000aPROJ_ID PROJ_START PROJ_END\u000d\u000a------- ----------- -----------\u000d\u000a 1 01-JAN-2020 02-JAN-2020\u000d\u000a 2 02-JAN-2020 03-JAN-2020\u000d\u000a 3 03-JAN-2020 04-JAN-2020\u000d\u000a 4 04-JAN-2020 05-JAN-2020\u000d\u000aNow PROJ_ID 4 is included in the final result set, and only the evil PROJ_ID 5 is\u000d\u000aexcluded. Please consider your exact requirements when applying these recipes to\u000d\u000ayour code.\u000d\u000a316 | Chapter 10: Working with Ranges","10.2 Finding Differences Between Rows in the Same\u000d\u000aGroup or Partition\u000d\u000aProblem\u000d\u000aYou want to return the DEPTNO, ENAME, and SAL of each employee along with the\u000d\u000adifference in SAL between employees in the same department (i.e., having the same\u000d\u000avalue for DEPTNO). The difference should be between each current employee and\u000d\u000athe employee hired immediately afterward (you want to see if there is a correlation\u000d\u000abetween seniority and salary on a \u201cper department\u201d basis). For each employee hired\u000d\u000alast in his department, return \u201cN/A\u201d for the difference. The result set should look like\u000d\u000athis:\u000d\u000aDEPTNO ENAME SAL HIREDATE DIFF\u000d\u000a------ ---------- ---------- ----------- ----------\u000d\u000a 10 CLARK 2450 09-JUN-2006 -2550\u000d\u000a 10 KING 5000 17-NOV-2006 3700\u000d\u000a 10 MILLER 1300 23-JAN-2007 N/A\u000d\u000a 20 SMITH 800 17-DEC-2005 -2175\u000d\u000a 20 JONES 2975 02-APR-2006 -25\u000d\u000a 20 FORD 3000 03-DEC-2006 0\u000d\u000a 20 SCOTT 3000 09-DEC-2007 1900\u000d\u000a 20 ADAMS 1100 12-JAN-2008 N/A\u000d\u000a 30 ALLEN 1600 20-FEB-2006 350\u000d\u000a 30 WARD 1250 22-FEB-2006 -1600\u000d\u000a 30 BLAKE 2850 01-MAY-2006 1350\u000d\u000a 30 TURNER 1500 08-SEP-2006 250\u000d\u000a 30 MARTIN 1250 28-SEP-2006 300\u000d\u000a 30 JAMES 950 03-DEC-2006 N/A\u000d\u000aSolution\u000d\u000aThe is another example of where the window functions LEAD OVER and LAG\u000d\u000aOVER come in handy. You can easily access next and prior rows without additional\u000d\u000ajoins. Alternative methods such as subqueries or self-joins are possible but awkward:\u000d\u000a1 with next_sal_tab (deptno,ename,sal,hiredate,next_sal)\u000d\u000a2 as\u000d\u000a3 (select deptno, ename, sal, hiredate,\u000d\u000a4 lead(sal)over(partition by deptno\u000d\u000a5 order by hiredate) as next_sal\u000d\u000a6 from emp )\u000d\u000a7\u000d\u000a8 select deptno, ename, sal, hiredate\u000d\u000a9 , coalesce(cast(sal-next_sal as char), 'N/A') as diff\u000d\u000a10 from next_sal_tab\u000d\u000a10.2 Finding Differences Between Rows in the Same Group or Partition | 317","In this case, for the sake of variety, we have used a CTE rather than a subquery\u2014both\u000d\u000awill work across most RDBMSs these days, with the preference usually relating to\u000d\u000areadability.\u000d\u000aDiscussion\u000d\u000aThe first step is to use the LEAD OVER window function to find the \u201cnext\u201d salary for\u000d\u000aeach employee within their department. The employees hired last in each department\u000d\u000awill have a NULL value for NEXT_SAL:\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a lead(sal)over(partition by deptno order by hiredate) as next_sal\u000d\u000a from emp\u000d\u000aDEPTNO ENAME SAL HIREDATE NEXT_SAL\u000d\u000a------ ---------- ---------- ----------- ----------\u000d\u000a 10 CLARK 2450 09-JUN-2006 5000\u000d\u000a 10 KING 5000 17-NOV-2006 1300\u000d\u000a 10 MILLER 1300 23-JAN-2007\u000d\u000a 20 SMITH 800 17-DEC-2005 2975\u000d\u000a 20 JONES 2975 02-APR-2006 3000\u000d\u000a 20 FORD 3000 03-DEC-2006 3000\u000d\u000a 20 SCOTT 3000 09-DEC-2007 1100\u000d\u000a 20 ADAMS 1100 12-JAN-2008\u000d\u000a 30 ALLEN 1600 20-FEB-2006 1250\u000d\u000a 30 WARD 1250 22-FEB-2006 2850\u000d\u000a 30 BLAKE 2850 01-MAY-2006 1500\u000d\u000a 30 TURNER 1500 08-SEP-2006 1250\u000d\u000a 30 MARTIN 1250 28-SEP-2006 950\u000d\u000a 30 JAMES 950 03-DEC-2006\u000d\u000aThe next step is to take the difference between each employee\u2019s salary and the salary\u000d\u000aof the employee hired immediately after them in the same department:\u000d\u000aselect deptno,ename,sal,hiredate, sal-next_sal diff\u000d\u000a from (\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a lead(sal)over(partition by deptno order by hiredate) next_sal\u000d\u000a from emp\u000d\u000a )\u000d\u000aDEPTNO ENAME SAL HIREDATE DIFF\u000d\u000a------ ---------- ---------- ----------- ----------\u000d\u000a 10 CLARK 2450 09-JUN-2006 -2550\u000d\u000a 10 KING 5000 17-NOV-2006 3700\u000d\u000a 10 MILLER 1300 23-JAN-2007\u000d\u000a 20 SMITH 800 17-DEC-2005 -2175\u000d\u000a 20 JONES 2975 02-APR-2006 -25\u000d\u000a 20 FORD 3000 03-DEC-2006 0\u000d\u000a 20 SCOTT 3000 09-DEC-2007 1900\u000d\u000a 20 ADAMS 1100 12-JAN-2008\u000d\u000a 30 ALLEN 1600 20-FEB-2006 350\u000d\u000a318 | Chapter 10: Working with Ranges"," 30 WARD 1250 22-FEB-2006 -1600\u000d\u000a 30 BLAKE 2850 01-MAY-2006 1350\u000d\u000a 30 TURNER 1500 08-SEP-2006 250\u000d\u000a 30 MARTIN 1250 28-SEP-2006 300\u000d\u000a 30 JAMES 950 03-DEC-2006\u000d\u000aThe next step is to use the COALESCE function to insert \u201cN/A\u201d when there is no next\u000d\u000asalary. To be able to return \u201cN/A\u201d you must cast the value of DIFF to a string:\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a nvl(to_char(sal-next_sal),'N/A') diff\u000d\u000a from (\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a lead(sal)over(partition by deptno order by hiredate) next_sal\u000d\u000a from emp\u000d\u000a )\u000d\u000aDEPTNO ENAME SAL HIREDATE DIFF\u000d\u000a------ ---------- ---------- ----------- ---------------\u000d\u000a 10 CLARK 2450 09-JUN-2006 -2550\u000d\u000a 10 KING 5000 17-NOV-2006 3700\u000d\u000a 10 MILLER 1300 23-JAN-2007 N/A\u000d\u000a 20 SMITH 800 17-DEC-2005 -2175\u000d\u000a 20 JONES 2975 02-APR-2006 -25\u000d\u000a 20 FORD 3000 03-DEC-2006 0\u000d\u000a 20 SCOTT 3000 09-DEC-2007 1900\u000d\u000a 20 ADAMS 1100 12-JAN-2008 N/A\u000d\u000a 30 ALLEN 1600 20-FEB-2006 350\u000d\u000a 30 WARD 1250 22-FEB-2006 -1600\u000d\u000a 30 BLAKE 2850 01-MAY-2006 1350\u000d\u000a 30 TURNER 1500 08-SEP-2006 250\u000d\u000a 30 MARTIN 1250 28-SEP-2006 300\u000d\u000a 30 JAMES 950 03-DEC-2006 N/A\u000d\u000aWhile the majority of the solutions provided in this book do not deal with \u201cwhat if \u201d\u000d\u000ascenarios (for the sake of readability and the author\u2019s sanity), the scenario involving\u000d\u000aduplicates when using the LEAD OVER function in this manner must be discussed.\u000d\u000aIn the simple sample data in table EMP, no employees have duplicate HIREDATEs,\u000d\u000ayet this is an unlikely situation. Normally, we would not discuss a \u201cwhat if \u201d situation\u000d\u000asuch as duplicates (since there aren\u2019t any in table EMP), but the workaround involv\u2010\u000d\u000aing LEAD may not be immediately obvious. Consider the following query, which\u000d\u000areturns the difference in SAL between the employees in DEPTNO 10 (the difference\u000d\u000ais performed in the order in which they were hired):\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a lpad(nvl(to_char(sal-next_sal),'N/A'),10) diff\u000d\u000a from (\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a lead(sal)over(partition by deptno\u000d\u000a order by hiredate) next_sal\u000d\u000a from emp\u000d\u000a10.2 Finding Differences Between Rows in the Same Group or Partition | 319"," where deptno=10 and empno > 10\u000d\u000a )\u000d\u000aDEPTNO ENAME SAL HIREDATE DIFF\u000d\u000a------ ------ ----- ----------- ----------\u000d\u000a 10 CLARK 2450 09-JUN-2006 -2550\u000d\u000a 10 KING 5000 17-NOV-2006 3700\u000d\u000a 10 MILLER 1300 23-JAN-2007 N/A\u000d\u000aThis solution is correct considering the data in table EMP, but if there were duplicate\u000d\u000arows, the solution would fail. Consider the following example, which shows four\u000d\u000amore employees hired on the same day as KING:\u000d\u000ainsert into emp (empno,ename,deptno,sal,hiredate)\u000d\u000avalues (1,'ant',10,1000,to_date('17-NOV-2006'))\u000d\u000ainsert into emp (empno,ename,deptno,sal,hiredate)\u000d\u000avalues (2,'joe',10,1500,to_date('17-NOV-2006'))\u000d\u000ainsert into emp (empno,ename,deptno,sal,hiredate)\u000d\u000avalues (3,'jim',10,1600,to_date('17-NOV-2006'))\u000d\u000ainsert into emp (empno,ename,deptno,sal,hiredate)\u000d\u000avalues (4,'jon',10,1700,to_date('17-NOV-2006'))\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a lpad(nvl(to_char(sal-next_sal),'N/A'),10) diff\u000d\u000a from (\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a lead(sal)over(partition by deptno\u000d\u000a order by hiredate) next_sal\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a )\u000d\u000aDEPTNO ENAME SAL HIREDATE DIFF\u000d\u000a------ ------ ----- ----------- ----------\u000d\u000a 10 CLARK 2450 09-JUN-2006 1450\u000d\u000a 10 ant 1000 17-NOV-2006 -500\u000d\u000a 10 joe 1500 17-NOV-2006 -3500\u000d\u000a 10 KING 5000 17-NOV-2006 3400\u000d\u000a 10 jim 1600 17-NOV-2006 -100\u000d\u000a 10 jon 1700 17-NOV-2006 400\u000d\u000a 10 MILLER 1300 23-JAN-2007 N/A\u000d\u000aYou\u2019ll notice that with the exception of employee JON, all employees hired on the\u000d\u000asame date (November 17) evaluate their salary against another employee hired on the\u000d\u000asame date! This is incorrect. All employees hired on November 17 should have the\u000d\u000adifference of salary computed against MILLER\u2019s salary, not another employee hired\u000d\u000aon November 17. Take, for example, employee ANT. The value for DIFF for ANT\u000d\u000ais \u2013500 because ANT\u2019s SAL is compared with JOE\u2019s SAL and is 500 less than JOE\u2019s\u000d\u000a320 | Chapter 10: Working with Ranges","SAL, hence the value of \u2013500. The correct value for DIFF for employee ANT should\u000d\u000abe \u2013300 because ANT makes 300 less than MILLER, who is the next employee hired\u000d\u000aby HIREDATE. The reason the solution seems to not work is due to the default\u000d\u000abehavior of Oracle\u2019s LEAD OVER function. By default, LEAD OVER looks ahead\u000d\u000aonly one row. So, for employee ANT, the next SAL based on HIREDATE is JOE\u2019s\u000d\u000aSAL, because LEAD OVER simply looks one row ahead and doesn\u2019t skip duplicates.\u000d\u000aFortunately, Oracle planned for such a situation and allows you to pass an additional\u000d\u000aparameter to LEAD OVER to determine how far ahead it should look. In the previ\u2010\u000d\u000aous example, the solution is simply a matter of counting: find the distance from each\u000d\u000aemployee hired on November 17 to January 23 (MILLER\u2019s HIREDATE). The follow\u2010\u000d\u000aing shows how to accomplish this:\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a lpad(nvl(to_char(sal-next_sal),'N/A'),10) diff\u000d\u000a from (\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a lead(sal,cnt-rn+1)over(partition by deptno\u000d\u000a order by hiredate) next_sal\u000d\u000a from (\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a count(*)over(partition by deptno,hiredate) cnt,\u000d\u000a row_number()over(partition by deptno,hiredate order by sal) rn\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a )\u000d\u000a )\u000d\u000aDEPTNO ENAME SAL HIREDATE DIFF\u000d\u000a------ ------ ----- ----------- ----------\u000d\u000a 10 CLARK 2450 09-JUN-2006 1450\u000d\u000a 10 ant 1000 17-NOV-2006 -300\u000d\u000a 10 joe 1500 17-NOV-2006 200\u000d\u000a 10 jim 1600 17-NOV-2006 300\u000d\u000a 10 jon 1700 17-NOV-2006 400\u000d\u000a 10 KING 5000 17-NOV-2006 3700\u000d\u000a 10 MILLER 1300 23-JAN-2007 N/A\u000d\u000aNow the solution is correct. As you can see, all the employees hired on November 17\u000d\u000anow have their salaries compared with MILLER\u2019s salary. Inspecting the results,\u000d\u000aemployee ANT now has a value of \u2013300 for DIFF, which is what we were hoping for.\u000d\u000aIf it isn\u2019t immediately obvious, the expression passed to LEAD OVER; CNT-RN+1 is\u000d\u000asimply the distance from each employee hired on November 17 to MILLER. Consider\u000d\u000athe following inline view, which shows the values for CNT and RN:\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a count(*)over(partition by deptno,hiredate) cnt,\u000d\u000a row_number()over(partition by deptno,hiredate order by sal) rn\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a10.2 Finding Differences Between Rows in the Same Group or Partition | 321","DEPTNO ENAME SAL HIREDATE CNT RN\u000d\u000a------ ------ ----- ----------- ---------- ----------\u000d\u000a 10 CLARK 2450 09-JUN-2006 1 1\u000d\u000a 10 ant 1000 17-NOV-2006 5 1\u000d\u000a 10 joe 1500 17-NOV-2006 5 2\u000d\u000a 10 jim 1600 17-NOV-2006 5 3\u000d\u000a 10 jon 1700 17-NOV-2006 5 4\u000d\u000a 10 KING 5000 17-NOV-2006 5 5\u000d\u000a 10 MILLER 1300 23-JAN-2007 1 1\u000d\u000aThe value for CNT represents, for each employee with a duplicate HIREDATE, how\u000d\u000amany duplicates there are in total for their HIREDATE. The value for RN represents a\u000d\u000aranking for the employees in DEPTNO 10. The rank is partitioned by DEPTNO and\u000d\u000aHIREDATE so only employees with a HIREDATE that another employee has will\u000d\u000ahave a value greater than one. The ranking is sorted by SAL (this is arbitrary; SAL is\u000d\u000aconvenient, but we could have just as easily chosen EMPNO). Now that you know\u000d\u000ahow many total duplicates there are and you have a ranking of each duplicate, the dis\u2010\u000d\u000atance to MILLER is simply the total number of duplicates minus the current rank\u000d\u000aplus one (CNT-RN+1). The results of the distance calculation and its effect on LEAD\u000d\u000aOVER are shown here:\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a lead(sal)over(partition by deptno\u000d\u000a order by hiredate) incorrect,\u000d\u000a cnt-rn+1 distance,\u000d\u000a lead(sal,cnt-rn+1)over(partition by deptno\u000d\u000a order by hiredate) correct\u000d\u000a from (\u000d\u000aselect deptno,ename,sal,hiredate,\u000d\u000a count(*)over(partition by deptno,hiredate) cnt,\u000d\u000a row_number()over(partition by deptno,hiredate\u000d\u000a order by sal) rn\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a )\u000d\u000aDEPTNO ENAME SAL HIREDATE INCORRECT DISTANCE CORRECT\u000d\u000a------ ------ ----- ----------- ---------- ---------- ----------\u000d\u000a 10 CLARK 2450 09-JUN-2006 1000 1 1000\u000d\u000a 10 ant 1000 17-NOV-2006 1500 5 1300\u000d\u000a 10 joe 1500 17-NOV-2006 1600 4 1300\u000d\u000a 10 jim 1600 17-NOV-2006 1700 3 1300\u000d\u000a 10 jon 1700 17-NOV-2006 5000 2 1300\u000d\u000a 10 KING 5000 17-NOV-2006 1300 1 1300\u000d\u000a 10 MILLER 1300 23-JAN-2007 1\u000d\u000aNow you can clearly see the effect that you have when you pass the correct distance to\u000d\u000aLEAD OVER. The rows for INCORRECT represent the values returned by LEAD\u000d\u000aOVER using a default distance of one. The rows for CORRECT represent the values\u000d\u000areturned by LEAD OVER using the proper distance for each employee with a\u000d\u000a322 | Chapter 10: Working with Ranges","duplicate HIREDATE to MILLER. At this point, all that is left is to find the difference\u000d\u000abetween CORRECT and SAL for each row, which has already been shown.\u000d\u000a10.3 Locating the Beginning and End of a Range of\u000d\u000aConsecutive Values\u000d\u000aProblem\u000d\u000aThis recipe is an extension of the prior recipe, and it uses the same view V from the\u000d\u000aprior recipe. Now that you\u2019ve located the ranges of consecutive values, you want to\u000d\u000afind just their start and end points. Unlike the prior recipe, if a row is not part of a set\u000d\u000aof consecutive values, you still want to return it. Why? Because such a row represents\u000d\u000aboth the beginning and end of its range. Using the data from view V:\u000d\u000aselect *\u000d\u000a from V\u000d\u000aPROJ_ID PROJ_START PROJ_END\u000d\u000a------- ----------- -----------\u000d\u000a 1 01-JAN-2020 02-JAN-2020\u000d\u000a 2 02-JAN-2020 03-JAN-2020\u000d\u000a 3 03-JAN-2020 04-JAN-2020\u000d\u000a 4 04-JAN-2020 05-JAN-2020\u000d\u000a 5 06-JAN-2020 07-JAN-2020\u000d\u000a 6 16-JAN-2020 17-JAN-2020\u000d\u000a 7 17-JAN-2020 18-JAN-2020\u000d\u000a 8 18-JAN-2020 19-JAN-2020\u000d\u000a 9 19-JAN-2020 20-JAN-2020\u000d\u000a 10 21-JAN-2020 22-JAN-2020\u000d\u000a 11 26-JAN-2020 27-JAN-2020\u000d\u000a 12 27-JAN-2020 28-JAN-2020\u000d\u000a 13 28-JAN-2020 29-JAN-2020\u000d\u000a 14 29-JAN-2020 30-JAN-2020\u000d\u000ayou want the final result set to be as follows:\u000d\u000aPROJ_GRP PROJ_START PROJ_END\u000d\u000a-------- ----------- -----------\u000d\u000a 1 01-JAN-2020 05-JAN-2020\u000d\u000a 2 06-JAN-2020 07-JAN-2020\u000d\u000a 3 16-JAN-2020 20-JAN-2020\u000d\u000a 4 21-JAN-2020 22-JAN-2020\u000d\u000a 5 26-JAN-2020 30-JAN-2020\u000d\u000a10.3 Locating the Beginning and End of a Range of Consecutive Values | 323","Solution\u000d\u000aThis problem is a bit more involved than its predecessor. First, you must identify\u000d\u000awhat the ranges are. A range of rows is defined by the values for PROJ_START and\u000d\u000aPROJ_END. For a row to be considered \u201cconsecutive\u201d or part of a group, its\u000d\u000aPROJ_START value must equal the PROJ_END value of the row before it. In the case\u000d\u000awhere a row\u2019s PROJ_START value does not equal the prior row\u2019s PROJ_END value\u000d\u000aand its PROJ_END value does not equal the next row\u2019s PROJ_START value, this is an\u000d\u000ainstance of a single row group. Once you have identify the ranges, you need to be able\u000d\u000ato group the rows in these ranges together (into groups) and return only their start\u000d\u000aand end points.\u000d\u000aExamine the first row of the desired result set. The PROJ_START is the PROJ_\u000d\u000aSTART for PROJ_ID 1 from view V, and the PROJ_END is the PROJ_END for\u000d\u000aPROJ_ID 4 from view V. Despite the fact that PROJ_ID 4 does not have a consecutive\u000d\u000avalue following it, it is the last of a range of consecutive values, and thus it is included\u000d\u000ain the first group.\u000d\u000aThe most straightforward approach for this problem is to use the LAG OVER win\u2010\u000d\u000adow function. Use LAG OVER to determine whether each prior row\u2019s PROJ_END\u000d\u000aequals the current row\u2019s PROJ_START to help place the rows into groups. Once they\u000d\u000aare grouped, use the aggregate functions MIN and MAX to find their start and end\u000d\u000apoints:\u000d\u000a 1 select proj_grp, min(proj_start), max(proj_end)\u000d\u000a 2 from (\u000d\u000a 3 select proj_id,proj_start,proj_end,\u000d\u000a 4 sum(flag)over(order by proj_id) proj_grp\u000d\u000a 5 from (\u000d\u000a 6 select proj_id,proj_start,proj_end,\u000d\u000a 7 case when\u000d\u000a 8 lag(proj_end)over(order by proj_id) = proj_start\u000d\u000a 9 then 0 else 1\u000d\u000a10 end flag\u000d\u000a11 from V\u000d\u000a12 ) alias1\u000d\u000a13 ) alias2\u000d\u000a14 group by proj_grp\u000d\u000aDiscussion\u000d\u000aThe window function LAG OVER is extremely useful in this situation. You can exam\u2010\u000d\u000aine each prior row\u2019s PROJ_END value without a self-join, without a scalar subquery,\u000d\u000aand without a view. The results of the LAG OVER function without the CASE expres\u2010\u000d\u000asion are as follows:\u000d\u000a324 | Chapter 10: Working with Ranges","select proj_id,proj_start,proj_end,\u000d\u000a lag(proj_end)over(order by proj_id) prior_proj_end\u000d\u000a from V\u000d\u000aPROJ_ID PROJ_START PROJ_END PRIOR_PROJ_END\u000d\u000a------- ----------- ----------- --------------\u000d\u000a 1 01-JAN-2020 02-JAN-2020\u000d\u000a 2 02-JAN-2020 03-JAN-2020 02-JAN-2020\u000d\u000a 3 03-JAN-2020 04-JAN-2020 03-JAN-2020\u000d\u000a 4 04-JAN-2020 05-JAN-2020 04-JAN-2020\u000d\u000a 5 06-JAN-2020 07-JAN-2020 05-JAN-2020\u000d\u000a 6 16-JAN-2020 17-JAN-2020 07-JAN-2020\u000d\u000a 7 17-JAN-2020 18-JAN-2020 17-JAN-2020\u000d\u000a 8 18-JAN-2020 19-JAN-2020 18-JAN-2020\u000d\u000a 9 19-JAN-2020 20-JAN-2020 19-JAN-2020\u000d\u000a 10 21-JAN-2020 22-JAN-2020 20-JAN-2020\u000d\u000a 11 26-JAN-2020 27-JAN-2020 22-JAN-2020\u000d\u000a 12 27-JAN-2020 28-JAN-2020 27-JAN-2020\u000d\u000a 13 28-JAN-2020 29-JAN-2020 28-JAN-2020\u000d\u000a 14 29-JAN-2020 30-JAN-2020 29-JAN-2020\u000d\u000aThe CASE expression in the complete solution simply compares the value returned\u000d\u000aby LAG OVER to the current row\u2019s PROJ_START value; if they are the same, return\u000d\u000a0, else return 1. The next step is to create a running total on the zeros and ones\u000d\u000areturned by the CASE expression to put each row into a group. The results of the\u000d\u000arunning total are shown here:\u000d\u000aselect proj_id,proj_start,proj_end,\u000d\u000a sum(flag)over(order by proj_id) proj_grp\u000d\u000a from (\u000d\u000aselect proj_id,proj_start,proj_end,\u000d\u000a case when\u000d\u000a lag(proj_end)over(order by proj_id) = proj_start\u000d\u000a then 0 else 1\u000d\u000a end flag\u000d\u000a from V\u000d\u000a )\u000d\u000aPROJ_ID PROJ_START PROJ_END PROJ_GRP\u000d\u000a------- ----------- ----------- ----------\u000d\u000a 1 01-JAN-2020 02-JAN-2020 1\u000d\u000a 2 02-JAN-2020 03-JAN-2020 1\u000d\u000a 3 03-JAN-2020 04-JAN-2020 1\u000d\u000a 4 04-JAN-2020 05-JAN-2020 1\u000d\u000a 5 06-JAN-2020 07-JAN-2020 2\u000d\u000a 6 16-JAN-2020 17-JAN-2020 3\u000d\u000a 7 17-JAN-2020 18-JAN-2020 3\u000d\u000a 8 18-JAN-2020 19-JAN-2020 3\u000d\u000a 9 19-JAN-2020 20-JAN-2020 3\u000d\u000a 10 21-JAN-2020 22-JAN-2020 4\u000d\u000a10.3 Locating the Beginning and End of a Range of Consecutive Values | 325"," 11 26-JAN-2020 27-JAN-2020 5\u000d\u000a 12 27-JAN-2020 28-JAN-2020 5\u000d\u000a 13 28-JAN-2020 29-JAN-2020 5\u000d\u000a 14 29-JAN-2020 30-JAN-2020 5\u000d\u000aNow that each row has been placed into a group, simply use the aggregate functions\u000d\u000aMIN and MAX on PROJ_START and PROJ_END, respectively, and group by the val\u2010\u000d\u000aues created in the PROJ_GRP running total column.\u000d\u000a10.4 Filling in Missing Values in a Range of Values\u000d\u000aProblem\u000d\u000aYou want to return the number of employees hired each year for the entire decade of\u000d\u000athe 2005s, but there are some years in which no employees were hired. You would like\u000d\u000ato return the following result set:\u000d\u000aYR CNT\u000d\u000a---- ----------\u000d\u000a2005 1\u000d\u000a2006 10\u000d\u000a2007 2\u000d\u000a2008 1\u000d\u000a2009 0\u000d\u000a2010 0\u000d\u000a2011 0\u000d\u000a2012 0\u000d\u000a2013 0\u000d\u000a2014 0\u000d\u000aSolution\u000d\u000aThe trick to this solution is returning zeros for years that saw no employees hired. If\u000d\u000ano employee was hired in a given year, then no rows for that year will exist in table\u000d\u000aEMP. If the year does not exist in the table, how can you return a count, any count,\u000d\u000aeven zero? The solution requires you to outer join. You must supply a result set that\u000d\u000areturns all the years you want to see, and then perform a count against table EMP to\u000d\u000asee if there were any employees hired in each of those years.\u000d\u000aDB2\u000d\u000aUse table EMP as a pivot table (because it has 14 rows) and the built-in function \u000d\u000aYEAR to generate one row for each year in the decade of 2005. Outer join to table\u000d\u000aEMP and count how many employees were hired each year:\u000d\u000a 1 select x.yr, coalesce(y.cnt,0) cnt\u000d\u000a 2 from (\u000d\u000a 3 select year(min(hiredate)over()) -\u000d\u000a 4 mod(year(min(hiredate)over()),10) +\u000d\u000a326 | Chapter 10: Working with Ranges"," 5 row_number()over()-1 yr\u000d\u000a 6 from emp fetch first 10 rows only\u000d\u000a 7 ) x\u000d\u000a 8 left join\u000d\u000a 9 (\u000d\u000a10 select year(hiredate) yr1, count(*) cnt\u000d\u000a11 from emp\u000d\u000a12 group by year(hiredate)\u000d\u000a13 ) y\u000d\u000a14 on ( x.yr = y.yr1 )\u000d\u000aOracle\u000d\u000aThe Oracle solution follows the same structure as the DB2 solution, with only the dif\u2010\u000d\u000aferences in the syntax Oracle handles causing a distinct solution to be required:\u000d\u000a 1 select x.yr, coalesce(cnt,0) cnt\u000d\u000a 2 from (\u000d\u000a 3 select extract(year from min(hiredate)over()) -\u000d\u000a 4 mod(extract(year from min(hiredate)over()),10) +\u000d\u000a 5 rownum-1 yr\u000d\u000a 6 from emp\u000d\u000a 7 where rownum <= 10\u000d\u000a 8 ) x\u000d\u000a 9 left join\u000d\u000a10 (\u000d\u000a11 select to_number(to_char(hiredate,'YYYY')) yr, count(*) cnt\u000d\u000a12 from emp\u000d\u000a13 group by to_number(to_char(hiredate,'YYYY'))\u000d\u000a14 ) y\u000d\u000a15 on ( x.yr = y.yr )\u000d\u000aPostgreSQL and MySQL\u000d\u000aUse table T10 as a pivot table (because it has 10 rows) and the built-in function\u000d\u000aEXTRACT to generate one row for each year in the decade of 2005. Outer join to\u000d\u000atable EMP and count how many employees were hired each year:\u000d\u000a 1 select y.yr, coalesce(x.cnt,0) as cnt\u000d\u000a 2 from (\u000d\u000a 3 selectmin_year-mod(cast(min_year as int),10)+rn as yr\u000d\u000a 4 from (\u000d\u000a 5 select (select min(extract(year from hiredate))\u000d\u000a 6 from emp) as min_year,\u000d\u000a 7 id-1 as rn\u000d\u000a 8 from t10\u000d\u000a 9 ) a\u000d\u000a10 ) y\u000d\u000a11 left join\u000d\u000a12 (\u000d\u000a13 select extract(year from hiredate) as yr, count(*) as cnt\u000d\u000a14 from emp\u000d\u000a10.4 Filling in Missing Values in a Range of Values | 327","15 group by extract(year from hiredate)\u000d\u000a16 ) x\u000d\u000a17 on ( y.yr = x.yr )\u000d\u000aSQL Server\u000d\u000aUse table EMP as a pivot table (because it has 14 rows) and the built-in function\u000d\u000aYEAR to generate one row for each year in the decade of 2005. Outer join to table\u000d\u000aEMP and count how many employees were hired each year:\u000d\u000a 1 select x.yr, coalesce(y.cnt,0) cnt\u000d\u000a 2 from (\u000d\u000a 3 select top (10)\u000d\u000a 4 (year(min(hiredate)over()) -\u000d\u000a 5 year(min(hiredate)over())%10)+\u000d\u000a 6 row_number()over(order by hiredate)-1 yr\u000d\u000a 7 from emp\u000d\u000a 8 ) x\u000d\u000a 9 left join\u000d\u000a10 (\u000d\u000a11 select year(hiredate) yr, count(*) cnt\u000d\u000a12 from emp\u000d\u000a13 group by year(hiredate)\u000d\u000a14 ) y\u000d\u000a15 on ( x.yr = y.yr )\u000d\u000aDiscussion\u000d\u000aDespite the difference in syntax, the approach is the same for all solutions. Inline\u000d\u000aview X returns each year in the decade of the \u201980s by first finding the year of the earli\u2010\u000d\u000aest HIREDATE. The next step is to add RN\u20131 to the difference between the earliest\u000d\u000ayear and the earliest year modulus ten. To see how this works, simply execute inline\u000d\u000aview X and return each of the values involved separately. Listed here is the result set\u000d\u000afor inline view X using the window function MIN OVER (DB2, Oracle, SQL Server)\u000d\u000aand a scalar subquery (MySQL, PostgreSQL):\u000d\u000aselect year(min(hiredate)over()) -\u000d\u000a mod(year(min(hiredate)over()),10) +\u000d\u000a row_number()over()-1 yr,\u000d\u000a year(min(hiredate)over()) min_year,\u000d\u000a mod(year(min(hiredate)over()),10) mod_yr,\u000d\u000a row_number()over()-1 rn\u000d\u000a from emp fetch first 10 rows only\u000d\u000a YR MIN_YEAR MOD_YR RN\u000d\u000a---- ---------- ---------- ----------\u000d\u000a2005 2005 0 0\u000d\u000a2006 2005 0 1\u000d\u000a2007 2005 0 2\u000d\u000a2008 2005 0 3\u000d\u000a1984 2005 0 4\u000d\u000a328 | Chapter 10: Working with Ranges","2010 2005 0 5\u000d\u000a2011 2005 0 6\u000d\u000a2012 2005 0 7\u000d\u000a2013 2005 0 8\u000d\u000a2014 2005 0 9\u000d\u000aselect min_year-mod(min_year,10)+rn as yr,\u000d\u000a min_year,\u000d\u000a mod(min_year,10) as mod_yr\u000d\u000a rn\u000d\u000a from (\u000d\u000aselect (select min(extract(year from hiredate))\u000d\u000a from emp) as min_year,\u000d\u000a id-1 as rn\u000d\u000a from t10\u000d\u000a ) x\u000d\u000a YR MIN_YEAR MOD_YR RN\u000d\u000a---- ---------- ---------- ----------\u000d\u000a2005 2005 0 0\u000d\u000a2006 2005 0 1\u000d\u000a2007 2005 0 2\u000d\u000a2008 2005 0 3\u000d\u000a2009 2005 0 4\u000d\u000a2010 2005 0 5\u000d\u000a2011 2005 0 6\u000d\u000a2012 2005 0 7\u000d\u000a2013 2005 0 8\u000d\u000a2014 2005 0 9\u000d\u000aInline view Y returns the year for each HIREDATE and the number of employees\u000d\u000ahired during that year:\u000d\u000aselect year(hiredate) yr, count(*) cnt\u000d\u000a from emp\u000d\u000a group by year(hiredate)\u000d\u000a YR CNT\u000d\u000a----- ----------\u000d\u000a 2005 1\u000d\u000a 2006 10\u000d\u000a 2007 2\u000d\u000a 2008 1\u000d\u000aFinally, outer join inline view Y to inline view X so that every year is returned even if\u000d\u000athere are no employees hired.\u000d\u000a10.4 Filling in Missing Values in a Range of Values | 329","10.5 Generating Consecutive Numeric Values\u000d\u000aProblem\u000d\u000aYou would like to have a \u201crow source generator\u201d available to you in your queries. Row\u000d\u000asource generators are useful for queries that require pivoting. For example, you want\u000d\u000ato return a result set such as the following, up to any number of rows that you specify:\u000d\u000aID\u000d\u000a---\u000d\u000a 1\u000d\u000a 2\u000d\u000a 3\u000d\u000a 4\u000d\u000a 5\u000d\u000a 6\u000d\u000a 7\u000d\u000a 8\u000d\u000a 9\u000d\u000a 10\u000d\u000a\u2026\u000d\u000aIf your RDBMS provides built-in functions for returning rows dynamically, you do\u000d\u000anot need to create a pivot table in advance with a fixed number of rows. That\u2019s why a\u000d\u000adynamic row generator can be so handy. Otherwise, you must use a traditional pivot\u000d\u000atable with a fixed number of rows (that may not always be enough) to generate rows\u000d\u000awhen needed.\u000d\u000aSolution\u000d\u000aThis solution shows how to return 10 rows of increasing numbers starting from 1.\u000d\u000aYou can easily adapt the solution to return any number of rows.\u000d\u000aThe ability to return increasing values from one opens the door to many other solu\u2010\u000d\u000ations. For example, you can generate numbers to add to dates in order to generate\u000d\u000asequences of days. You can also use such numbers to parse through strings.\u000d\u000aDB2 and SQL Server\u000d\u000aUse the recursive WITH clause to generate a sequence of rows with incrementing val\u2010\u000d\u000aues. Using a recursive CTE will in fact work with the majority of RDBMSs today:\u000d\u000a 1 with x (id)\u000d\u000a 2 as (\u000d\u000a 3 select 1\u000d\u000a 4 union all\u000d\u000a 5 select id+1\u000d\u000a 6 from x\u000d\u000a 7 where id+1 <= 10\u000d\u000a330 | Chapter 10: Working with Ranges"," 8 )\u000d\u000a 9 select * from x\u000d\u000aOracle\u000d\u000aIn Oracle Database you can generate rows using the MODEL clause:\u000d\u000a1 select array id\u000d\u000a2 from dual\u000d\u000a3 model\u000d\u000a4 dimension by (0 idx)\u000d\u000a5 measures(1 array)\u000d\u000a6 rules iterate (10) (\u000d\u000a7 array[iteration_number] = iteration_number+1\u000d\u000a8 )\u000d\u000aPostgreSQL\u000d\u000aUse the handy function GENERATE_SERIES, which is designed for the express pur\u2010\u000d\u000apose of generating rows:\u000d\u000a1 select id\u000d\u000a2 from generate_series (1, 10) x(id)\u000d\u000aDiscussion\u000d\u000aDB2 and SQL Server\u000d\u000aThe recursive WITH clause increments ID (which starts at one) until the WHERE\u000d\u000aclause is satisfied. To kick things off, you must generate one row having the value 1.\u000d\u000aYou can do this by selecting 1 from a one-row table or, in the case of DB2, by using\u000d\u000athe VALUES clause to create a one-row result set.\u000d\u000aOracle\u000d\u000aIn the MODEL clause solution, there is an explicit ITERATE command that allows\u000d\u000ayou to generate multiple rows. Without the ITERATE clause, only one row will be\u000d\u000areturned, since DUAL has only one row. For example:\u000d\u000aselect array id\u000d\u000a from dual\u000d\u000amodel\u000d\u000a dimension by (0 idx)\u000d\u000a measures(1 array)\u000d\u000a rules ()\u000d\u000a ID\u000d\u000a --\u000d\u000a 1\u000d\u000a10.5 Generating Consecutive Numeric Values | 331","The MODEL clause not only allows you array access to rows, it allows you to easily\u000d\u000a\u201ccreate\u201d or return rows that are not in the table you are selecting against. In this solu\u2010\u000d\u000ation, IDX is the array index (location of a specific value in the array) and ARRAY\u000d\u000a(aliased ID) is the \u201carray\u201d of rows. The first row defaults to 1 and can be referenced\u000d\u000awith ARRAY[0]. Oracle provides the function ITERATION_NUMBER so you can\u000d\u000atrack the number of times you\u2019ve iterated. The solution iterates 10 times, causing\u000d\u000aITERATION_NUMBER to go from 0 to 9. Adding one to each of those values yields\u000d\u000athe results 1 through 10.\u000d\u000aIt may be easier to visualize what\u2019s happening with the model clause if you execute the\u000d\u000afollowing query:\u000d\u000aselect 'array['||idx||'] = '||array as output\u000d\u000a from dual\u000d\u000a model\u000d\u000a dimension by (0 idx)\u000d\u000a measures(1 array)\u000d\u000a rules iterate (10) (\u000d\u000a array[iteration_number] = iteration_number+1\u000d\u000a )\u000d\u000aOUTPUT\u000d\u000a------------------\u000d\u000aarray[0] = 1\u000d\u000aarray[1] = 2\u000d\u000aarray[2] = 3\u000d\u000aarray[3] = 4\u000d\u000aarray[4] = 5\u000d\u000aarray[5] = 6\u000d\u000aarray[6] = 7\u000d\u000aarray[7] = 8\u000d\u000aarray[8] = 9\u000d\u000aarray[9] = 10\u000d\u000aPostgreSQL\u000d\u000aAll the work is done by the function GENERATE_SERIES. The function accepts\u000d\u000athree parameters, all numeric values. The first parameter is the start value, the second\u000d\u000aparameter is the ending value, and the third parameter is an optional \u201cstep\u201d value\u000d\u000a(how much each value is incremented by). If you do not pass a third parameter, the\u000d\u000aincrement defaults to one.\u000d\u000aThe GENERATE_SERIES function is flexible enough so that you do not have to\u000d\u000ahardcode parameters. For example, if you wanted to return 5 rows starting from\u000d\u000avalue 10 and ending with value 30, incrementing by 5 such that the result set is the\u000d\u000afollowing:\u000d\u000a332 | Chapter 10: Working with Ranges"," ID\u000d\u000a---\u000d\u000a 10\u000d\u000a 15\u000d\u000a 20\u000d\u000a 25\u000d\u000a 30\u000d\u000ayou can be creative and do something like this:\u000d\u000aselect id\u000d\u000a from generate_series(\u000d\u000a (select min(deptno) from emp),\u000d\u000a (select max(deptno) from emp),\u000d\u000a 5\u000d\u000a ) x(id)\u000d\u000aNotice here that the actual values passed to GENERATE_SERIES are not known\u000d\u000awhen the query is written. Instead, they are generated by subqueries when the main\u000d\u000aquery executes.\u000d\u000a10.6 Summing Up\u000d\u000aQueries that take into account ranges are one of the most common requests from\u000d\u000abusiness users\u2014they are a natural consquence of the way that businesses operate. At\u000d\u000aleast some of the time, however, a degree of dexterity is needed to apply the range\u000d\u000acorrectly, and the recipes in this chapter should demonstrate how to apply that\u000d\u000adexterity.\u000d\u000a10.6 Summing Up | 333","","CHAPTER 11\u000d\u000aAdvanced Searching\u000d\u000aIn a very real sense, this entire book so far has been about searching. You\u2019ve seen all\u000d\u000asorts of queries that use joins and WHERE clauses and grouping techniques to search\u000d\u000aout and return the results you need. Some types of searching operations, though,\u000d\u000astand apart from others in that they represent a different way of thinking about\u000d\u000asearching. Perhaps you\u2019re displaying a result set one page at a time. Half of that prob\u2010\u000d\u000alem is to identify (search for) the entire set of records that you want to display. The\u000d\u000aother half of that problem is to repeatedly search for the next page to display as a user\u000d\u000acycles through the records on a display. Your first thought may not be to think of pag\u2010\u000d\u000aination as a searching problem, but it can be thought of that way, and it can be solved\u000d\u000athat way; that is the type of searching solution this chapter is all about.\u000d\u000a11.1 Paginating Through a Result Set\u000d\u000aProblem\u000d\u000aYou want to paginate or \u201cscroll through\u201d a result set. For example, you want to return\u000d\u000athe first five salaries from table EMP, then the next five, and so forth. Your goal is to\u000d\u000aallow a user to view five records at a time, scrolling forward with each click of a Next\u000d\u000abutton.\u000d\u000aSolution\u000d\u000aBecause there is no concept of first, last, or next in SQL, you must impose order on\u000d\u000athe rows you are working with. Only by imposing order can you accurately return\u000d\u000aranges of records.\u000d\u000a335","Use the window function ROW_NUMBER OVER to impose order, and specify the\u000d\u000awindow of records that you want returned in your WHERE clause. For example, use\u000d\u000athis to return rows 1 through 5:\u000d\u000aselect sal\u000d\u000a from (\u000d\u000aselect row_number() over (order by sal) as rn,\u000d\u000a sal\u000d\u000a from emp\u000d\u000a ) x\u000d\u000a where rn between 1 and 5\u000d\u000a SAL\u000d\u000a----\u000d\u000a 800\u000d\u000a 950\u000d\u000a1100\u000d\u000a1250\u000d\u000a1250\u000d\u000aThen use this to return rows 6 through 10:\u000d\u000aselect sal\u000d\u000a from (\u000d\u000aselect row_number() over (order by sal) as rn,\u000d\u000a sal\u000d\u000a from emp\u000d\u000a ) x\u000d\u000a where rn between 6 and 10\u000d\u000a SAL\u000d\u000a-----\u000d\u000a 1300\u000d\u000a 1500\u000d\u000a 1600\u000d\u000a 2450\u000d\u000a 2850\u000d\u000aYou can return any range of rows that you want simply by changing the WHERE\u000d\u000aclause of your query.\u000d\u000aDiscussion\u000d\u000aThe window function ROW_NUMBER OVER in inline view X will assign a unique\u000d\u000anumber to each salary (in increasing order starting from 1). Listed here is the result\u000d\u000aset for inline view X:\u000d\u000aselect row_number() over (order by sal) as rn,\u000d\u000a sal\u000d\u000a from emp\u000d\u000a336 | Chapter 11: Advanced Searching","RN SAL\u000d\u000a-- ----------\u000d\u000a 1 800\u000d\u000a 2 950\u000d\u000a 3 1100\u000d\u000a 4 1250\u000d\u000a 5 1250\u000d\u000a 6 1300\u000d\u000a 7 1500\u000d\u000a 8 1600\u000d\u000a 9 2450\u000d\u000a10 2850\u000d\u000a11 2975\u000d\u000a12 3000\u000d\u000a13 3000\u000d\u000a14 5000\u000d\u000aOnce a number has been assigned to a salary, simply pick the range you want to\u000d\u000areturn by specifying values for RN.\u000d\u000aFor Oracle users, an alternative: you can use ROWNUM instead of ROW NUMBER\u000d\u000aOVER to generate sequence numbers for the rows:\u000d\u000aselect sal\u000d\u000a from (\u000d\u000aselect sal, rownum rn\u000d\u000a from (\u000d\u000aselect sal\u000d\u000a from emp\u000d\u000a order by sal\u000d\u000a )\u000d\u000a )\u000d\u000a where rn between 6 and 10\u000d\u000a SAL\u000d\u000a-----\u000d\u000a 1300\u000d\u000a 1500\u000d\u000a 1600\u000d\u000a 2450\u000d\u000a 2850\u000d\u000aUsing ROWNUM forces you into writing an extra level of subquery. The innermost\u000d\u000asubquery sorts rows by salary. The next outermost subquery applies row numbers to\u000d\u000athose rows, and, finally, the very outermost SELECT returns the data you are after.\u000d\u000a11.1 Paginating Through a Result Set | 337","11.2 Skipping n Rows from a Table\u000d\u000aProblem\u000d\u000aYou want a query to return every other employee in table EMP; you want the first\u000d\u000aemployee, third employee, and so forth. For example, from the following result set:\u000d\u000aENAME\u000d\u000a--------\u000d\u000aADAMS\u000d\u000aALLEN\u000d\u000aBLAKE\u000d\u000aCLARK\u000d\u000aFORD\u000d\u000aJAMES\u000d\u000aJONES\u000d\u000aKING\u000d\u000aMARTIN\u000d\u000aMILLER\u000d\u000aSCOTT\u000d\u000aSMITH\u000d\u000aTURNER\u000d\u000aWARD\u000d\u000ayou want to return the following:\u000d\u000aENAME\u000d\u000a----------\u000d\u000aADAMS\u000d\u000aBLAKE\u000d\u000aFORD\u000d\u000aJONES\u000d\u000aMARTIN\u000d\u000aSCOTT\u000d\u000aTURNER\u000d\u000aSolution\u000d\u000aTo skip the second or fourth or nth row from a result set, you must impose order on\u000d\u000athe result set; otherwise, there is no concept of first or next, second, or fourth.\u000d\u000aUse the window function ROW_NUMBER OVER to assign a number to each row,\u000d\u000awhich you can then use in conjunction with the modulo function to skip unwanted\u000d\u000arows. The modulo function is MOD for DB2, MySQL, PostgreSQL, and Oracle. In\u000d\u000aSQL Server, use the percent (%) operator. The following example uses MOD to skip\u000d\u000aeven-numbered rows:\u000d\u000a1 select ename\u000d\u000a2 from (\u000d\u000a3 select row_number() over (order by ename) rn,\u000d\u000a4 ename\u000d\u000a338 | Chapter 11: Advanced Searching","5 from emp\u000d\u000a6 ) x\u000d\u000a7 where mod(rn,2) = 1\u000d\u000aDiscussion\u000d\u000aThe call to the window function ROW_NUMBER OVER in inline view X will assign\u000d\u000aa rank to each row (no ties, even with duplicate names). The results are shown here:\u000d\u000aselect row_number() over (order by ename) rn, ename\u000d\u000a from emp\u000d\u000aRN ENAME\u000d\u000a-- --------\u000d\u000a 1 ADAMS\u000d\u000a 2 ALLEN\u000d\u000a 3 BLAKE\u000d\u000a 4 CLARK\u000d\u000a 5 FORD\u000d\u000a 6 JAMES\u000d\u000a 7 JONES\u000d\u000a 8 KING\u000d\u000a 9 MARTIN\u000d\u000a10 MILLER\u000d\u000a11 SCOTT\u000d\u000a12 SMITH\u000d\u000a13 TURNER\u000d\u000a14 WARD\u000d\u000aThe last step is to simply use modulus to skip every other row.\u000d\u000a11.3 Incorporating OR Logic When Using Outer Joins\u000d\u000aProblem\u000d\u000aYou want to return the name and department information for all employees in\u000d\u000adepartments 10 and 20 along with department information for departments 30 and\u000d\u000a40 (but no employee information). Your first attempt looks like this:\u000d\u000aselect e.ename, d.deptno, d.dname, d.loc\u000d\u000a from dept d, emp e\u000d\u000a where d.deptno = e.deptno\u000d\u000a and (e.deptno = 10 or e.deptno = 20)\u000d\u000a order by 2\u000d\u000aENAME DEPTNO DNAME LOC\u000d\u000a------- ---------- -------------- -----------\u000d\u000aCLARK 10 ACCOUNTING NEW YORK\u000d\u000aKING 10 ACCOUNTING NEW YORK\u000d\u000aMILLER 10 ACCOUNTING NEW YORK\u000d\u000aSMITH 20 RESEARCH DALLAS\u000d\u000a11.3 Incorporating OR Logic When Using Outer Joins | 339","ADAMS 20 RESEARCH DALLAS\u000d\u000aFORD 20 RESEARCH DALLAS\u000d\u000aSCOTT 20 RESEARCH DALLAS\u000d\u000aJONES 20 RESEARCH DALLAS\u000d\u000aBecause the join in this query is an inner join, the result set does not include depart\u2010\u000d\u000ament information for DEPTNOs 30 and 40.\u000d\u000aYou attempt to outer join EMP to DEPT with the following query, but you still do not\u000d\u000aget the correct results:\u000d\u000aselect e.ename, d.deptno, d.dname, d.loc\u000d\u000a from dept d left join emp e\u000d\u000a on (d.deptno = e.deptno)\u000d\u000a where e.deptno = 10\u000d\u000a or e.deptno = 20\u000d\u000a order by 2\u000d\u000aENAME DEPTNO DNAME LOC\u000d\u000a------- ---------- ------------ -----------\u000d\u000aCLARK 10 ACCOUNTING NEW YORK\u000d\u000aKING 10 ACCOUNTING NEW YORK\u000d\u000aMILLER 10 ACCOUNTING NEW YORK\u000d\u000aSMITH 20 RESEARCH DALLAS\u000d\u000aADAMS 20 RESEARCH DALLAS\u000d\u000aFORD 20 RESEARCH DALLAS\u000d\u000aSCOTT 20 RESEARCH DALLAS\u000d\u000aJONES 20 RESEARCH DALLAS\u000d\u000aUltimately, you would like the result set to be the following:\u000d\u000aENAME DEPTNO DNAME LOC\u000d\u000a------- ---------- ------------ ---------\u000d\u000aCLARK 10 ACCOUNTING NEW YORK\u000d\u000aKING 10 ACCOUNTING NEW YORK\u000d\u000aMILLER 10 ACCOUNTING NEW YORK\u000d\u000aSMITH 20 RESEARCH DALLAS\u000d\u000aJONES 20 RESEARCH DALLAS\u000d\u000aSCOTT 20 RESEARCH DALLAS\u000d\u000aADAMS 20 RESEARCH DALLAS\u000d\u000aFORD 20 RESEARCH DALLAS\u000d\u000a 30 SALES CHICAGO\u000d\u000a 40 OPERATIONS BOSTON\u000d\u000aSolution\u000d\u000aMove the OR condition into the JOIN clause:\u000d\u000a1 select e.ename, d.deptno, d.dname, d.loc\u000d\u000a2 from dept d left join emp e\u000d\u000a3 on (d.deptno = e.deptno\u000d\u000a4 and (e.deptno=10 or e.deptno=20))\u000d\u000a5 order by 2\u000d\u000a340 | Chapter 11: Advanced Searching","Alternatively, you can filter on EMP.DEPTNO first in an inline view and then outer\u000d\u000ajoin:\u000d\u000a1 select e.ename, d.deptno, d.dname, d.loc\u000d\u000a2 from dept d\u000d\u000a3 left join\u000d\u000a4 (select ename, deptno\u000d\u000a5 from emp\u000d\u000a6 where deptno in ( 10, 20 )\u000d\u000a7 ) e on ( e.deptno = d.deptno )\u000d\u000a8 order by 2\u000d\u000aDiscussion\u000d\u000aDB2, MySQL, PostgreSQL, and SQL Server\u000d\u000aTwo solutions are given for these products. The first moves the OR condition into the\u000d\u000aJOIN clause, making it part of the join condition. By doing that, you can filter the\u000d\u000arows returned from EMP without losing DEPTNOs 30 and 40 from DEPT.\u000d\u000aThe second solution moves the filtering into an inline view. Inline view E filters on\u000d\u000aEMP.DEPTNO and returns EMP rows of interest. These are then outer joined to\u000d\u000aDEPT. Because DEPT is the anchor table in the outer join, all departments, including\u000d\u000a30 and 40, are returned.\u000d\u000a11.4 Determining Which Rows Are Reciprocals\u000d\u000aProblem\u000d\u000aYou have a table containing the results of two tests, and you want to determine which\u000d\u000apair of scores are reciprocals. Consider the following result set from view V:\u000d\u000aselect *\u000d\u000a from V\u000d\u000aTEST1 TEST2\u000d\u000a----- ----------\u000d\u000a 20 20\u000d\u000a 50 25\u000d\u000a 20 20\u000d\u000a 60 30\u000d\u000a 70 90\u000d\u000a 80 130\u000d\u000a 90 70\u000d\u000a 100 50\u000d\u000a 110 55\u000d\u000a 120 60\u000d\u000a 130 80\u000d\u000a 140 70\u000d\u000a11.4 Determining Which Rows Are Reciprocals | 341","Examining these results, you see that a test score for TEST1 of 70 and TEST2 of 90 is\u000d\u000aa reciprocal (there exists a score of 90 for TEST1 and a score of 70 for TEST2). Like\u2010\u000d\u000awise, the scores of 80 for TEST1 and 130 for TEST2 are reciprocals of 130 for TEST1\u000d\u000aand 80 for TEST2. Additionally, the scores of 20 for TEST1 and 20 for TEST2 are\u000d\u000areciprocals of 20 for TEST2 and 20 for TEST1. You want to identify only one set of\u000d\u000areciprocals. You want your result set to be this:\u000d\u000aTEST1 TEST2\u000d\u000a----- ---------\u000d\u000a 20 20\u000d\u000a 70 90\u000d\u000a 80 130\u000d\u000anot this:\u000d\u000aTEST1 TEST2\u000d\u000a----- ---------\u000d\u000a 20 20\u000d\u000a 20 20\u000d\u000a 70 90\u000d\u000a 80 130\u000d\u000a 90 70\u000d\u000a 130 80\u000d\u000aSolution\u000d\u000aUse a self-join to identify rows where TEST1 equals TEST2, and vice versa:\u000d\u000aselect distinct v1.*\u000d\u000a from V v1, V v2\u000d\u000a where v1.test1 = v2.test2\u000d\u000a and v1.test2 = v2.test1\u000d\u000a and v1.test1 <= v1.test2\u000d\u000aDiscussion\u000d\u000aThe self-join results in a Cartesian product in which every TEST1 score can be com\u2010\u000d\u000apared against every TEST2 score, and vice versa. The following query will identify the\u000d\u000areciprocals:\u000d\u000aselect v1.*\u000d\u000a from V v1, V v2\u000d\u000a where v1.test1 = v2.test2\u000d\u000a and v1.test2 = v2.test1\u000d\u000aTEST1 TEST2\u000d\u000a----- ----------\u000d\u000a 20 20\u000d\u000a 20 20\u000d\u000a 20 20\u000d\u000a 20 20\u000d\u000a342 | Chapter 11: Advanced Searching"," 90 70\u000d\u000a 130 80\u000d\u000a 70 90\u000d\u000a 80 130\u000d\u000aThe use of DISTINCT ensures that duplicate rows are removed from the final result\u000d\u000aset. The final filter in the WHERE clause (and V1.TEST1 <= V1.TEST2) will ensure\u000d\u000athat only one pair of reciprocals (where TEST1 is the smaller or equal value) is\u000d\u000areturned.\u000d\u000a11.5 Selecting the Top n Records\u000d\u000aProblem\u000d\u000aYou want to limit a result set to a specific number of records based on a ranking of\u000d\u000asome sort. For example, you want to return the names and salaries of the employees\u000d\u000awith the top five salaries.\u000d\u000aSolution\u000d\u000aThe solution to this problem depends on the use of a window function. Which win\u2010\u000d\u000adow function you will use depends on how you want to deal with ties. The following\u000d\u000asolution uses DENSE_RANK so that each tie in salary will count as only one against\u000d\u000athe total:\u000d\u000a1 select ename,sal\u000d\u000a2 from (\u000d\u000a3 select ename, sal,\u000d\u000a4 dense_rank() over (order by sal desc) dr\u000d\u000a5 from emp\u000d\u000a6 ) x\u000d\u000a7 where dr <= 5\u000d\u000aThe total number of rows returned may exceed five, but there will be only five dis\u2010\u000d\u000atinct salaries. Use ROW_NUMBER OVER if you want to return five rows regardless\u000d\u000aof ties (as no ties are allowed with this function).\u000d\u000aDiscussion\u000d\u000aThe window function DENSE_RANK OVER in inline view X does all the work. The\u000d\u000afollowing example shows the entire table after applying that function:\u000d\u000aselect ename, sal,\u000d\u000a dense_rank() over (order by sal desc) dr\u000d\u000a from emp\u000d\u000aENAME SAL DR\u000d\u000a------- ------ ----------\u000d\u000aKING 5000 1\u000d\u000a11.5 Selecting the Top n Records | 343","SCOTT 3000 2\u000d\u000aFORD 3000 2\u000d\u000aJONES 2975 3\u000d\u000aBLAKE 2850 4\u000d\u000aCLARK 2450 5\u000d\u000aALLEN 1600 6\u000d\u000aTURNER 1500 7\u000d\u000aMILLER 1300 8\u000d\u000aWARD 1250 9\u000d\u000aMARTIN 1250 9\u000d\u000aADAMS 1100 10\u000d\u000aJAMES 950 11\u000d\u000aSMITH 800 12\u000d\u000aNow it\u2019s just a matter of returning rows where DR is less than or equal to five.\u000d\u000a11.6 Finding Records with the Highest and Lowest Values\u000d\u000aProblem\u000d\u000aYou want to find \u201cextreme\u201d values in your table. For example, you want to find the\u000d\u000aemployees with the highest and lowest salaries in table EMP.\u000d\u000aSolution\u000d\u000aDB2, Oracle, and SQL Server\u000d\u000aUse the window functions MIN OVER and MAX OVER to find the lowest and high\u2010\u000d\u000aest salaries, respectively:\u000d\u000a1 select ename\u000d\u000a2 from (\u000d\u000a3 select ename, sal,\u000d\u000a4 min(sal)over() min_sal,\u000d\u000a5 max(sal)over() max_sal\u000d\u000a6 from emp\u000d\u000a7 ) x\u000d\u000a8 where sal in (min_sal,max_sal)\u000d\u000aDiscussion\u000d\u000aDB2, Oracle, and SQL Server\u000d\u000aThe window functions MIN OVER and MAX OVER allow each row to have access to\u000d\u000athe lowest and highest salaries. The result set from inline view X is as follows:\u000d\u000aselect ename, sal,\u000d\u000a min(sal)over() min_sal,\u000d\u000a max(sal)over() max_sal\u000d\u000a from emp\u000d\u000a344 | Chapter 11: Advanced Searching","ENAME SAL MIN_SAL MAX_SAL\u000d\u000a------- ------ ---------- ----------\u000d\u000aSMITH 800 800 5000\u000d\u000aALLEN 1600 800 5000\u000d\u000aWARD 1250 800 5000\u000d\u000aJONES 2975 800 5000\u000d\u000aMARTIN 1250 800 5000\u000d\u000aBLAKE 2850 800 5000\u000d\u000aCLARK 2450 800 5000\u000d\u000aSCOTT 3000 800 5000\u000d\u000aKING 5000 800 5000\u000d\u000aTURNER 1500 800 5000\u000d\u000aADAMS 1100 800 5000\u000d\u000aJAMES 950 800 5000\u000d\u000aFORD 3000 800 5000\u000d\u000aMILLER 1300 800 5000\u000d\u000aGiven this result set, all that\u2019s left is to return rows where SAL equals MIN_SAL or\u000d\u000aMAX_SAL.\u000d\u000a11.7 Investigating Future Rows\u000d\u000aProblem\u000d\u000aYou want to find any employees who earn less than the employee hired immediately\u000d\u000aafter them. Based on the following result set:\u000d\u000aENAME SAL HIREDATE\u000d\u000a---------- ---------- ---------\u000d\u000aSMITH 800 17-DEC-80\u000d\u000aALLEN 1600 20-FEB-81\u000d\u000aWARD 1250 22-FEB-81\u000d\u000aJONES 2975 02-APR-81\u000d\u000aBLAKE 2850 01-MAY-81\u000d\u000aCLARK 2450 09-JUN-81\u000d\u000aTURNER 1500 08-SEP-81\u000d\u000aMARTIN 1250 28-SEP-81\u000d\u000aKING 5000 17-NOV-81\u000d\u000aJAMES 950 03-DEC-81\u000d\u000aFORD 3000 03-DEC-81\u000d\u000aMILLER 1300 23-JAN-82\u000d\u000aSCOTT 3000 09-DEC-82\u000d\u000aADAMS 1100 12-JAN-83\u000d\u000aSMITH, WARD, MARTIN, JAMES, and MILLER earn less than the person hired\u000d\u000aimmediately after they were hired, so those are the employees you want to find with a\u000d\u000aquery.\u000d\u000a11.7 Investigating Future Rows | 345","Solution\u000d\u000aThe first step is to define what \u201cfuture\u201d means. You must impose order on your result\u000d\u000aset to be able to define a row as having a value that is \u201clater\u201d than another.\u000d\u000aYou can use the LEAD OVER window function to access the salary of the next\u000d\u000aemployee that was hired. It\u2019s then a simple matter to check whether that salary is\u000d\u000alarger:\u000d\u000a1 select ename, sal, hiredate\u000d\u000a2 from (\u000d\u000a3 select ename, sal, hiredate,\u000d\u000a4 lead(sal)over(order by hiredate) next_sal\u000d\u000a5 from emp\u000d\u000a6 ) alias\u000d\u000a7 where sal < next_sal\u000d\u000aDiscussion\u000d\u000aThe window function LEAD OVER is perfect for a problem such as this one. It not\u000d\u000aonly makes for a more readable query than the solution for the other products, LEAD\u000d\u000aOVER also leads to a more flexible solution because an argument can be passed to it\u000d\u000athat will determine how many rows ahead it should look (by default one). Being able\u000d\u000ato leap ahead more than one row is important in the case of duplicates in the column\u000d\u000ayou are ordering by.\u000d\u000aThe following example shows how easy it is to use LEAD OVER to look at the salary\u000d\u000aof the \u201cnext\u201d employee hired:\u000d\u000aselect ename, sal, hiredate,\u000d\u000a lead(sal)over(order by hiredate) next_sal\u000d\u000a from emp\u000d\u000aENAME SAL HIREDATE NEXT_SAL\u000d\u000a------- ------ --------- ----------\u000d\u000aSMITH 800 17-DEC-80 1600\u000d\u000aALLEN 1600 20-FEB-81 1250\u000d\u000aWARD 1250 22-FEB-81 2975\u000d\u000aJONES 2975 02-APR-81 2850\u000d\u000aBLAKE 2850 01-MAY-81 2450\u000d\u000aCLARK 2450 09-JUN-81 1500\u000d\u000aTURNER 1500 08-SEP-81 1250\u000d\u000aMARTIN 1250 28-SEP-81 5000\u000d\u000aKING 5000 17-NOV-81 950\u000d\u000aJAMES 950 03-DEC-81 3000\u000d\u000aFORD 3000 03-DEC-81 1300\u000d\u000aMILLER 1300 23-JAN-82 3000\u000d\u000aSCOTT 3000 09-DEC-82 1100\u000d\u000aADAMS 1100 12-JAN-83\u000d\u000a346 | Chapter 11: Advanced Searching","The final step is to return only rows where SAL is less than NEXT_SAL. Because of \u000d\u000aLEAD OVER\u2019s default range of one row, if there had been duplicates in table EMP\u2014\u000d\u000ain particular, multiple employees hired on the same date\u2014their SAL would be com\u2010\u000d\u000apared. This may or may not have been what you intended. If your goal is to compare\u000d\u000athe SAL of each employee with SAL of the next employee hired, excluding other\u000d\u000aemployees hired on the same day, you can use the following solution as an alternative:\u000d\u000aselect ename, sal, hiredate\u000d\u000a from (\u000d\u000aselect ename, sal, hiredate,\u000d\u000a lead(sal,cnt-rn+1)over(order by hiredate) next_sal\u000d\u000a from (\u000d\u000aselect ename,sal,hiredate,\u000d\u000a count(*)over(partition by hiredate) cnt,\u000d\u000a row_number()over(partition by hiredate order by empno) rn\u000d\u000a from emp\u000d\u000a )\u000d\u000a )\u000d\u000a where sal < next_sal\u000d\u000aThe idea behind this solution is to find the distance from the current row to the row\u000d\u000ait should be compared with. For example, if there are five duplicates, the first of the\u000d\u000afive needs to leap five rows to get to its correct LEAD OVER row. The value for CNT\u000d\u000arepresents, for each employee with a duplicate HIREDATE, how many duplicates\u000d\u000athere are in total for their HIREDATE. The value for RN represents a ranking for the\u000d\u000aemployees in DEPTNO 10. The rank is partitioned by HIREDATE so only employees\u000d\u000awith a HIREDATE that another employee has will have a value greater than one. The\u000d\u000aranking is sorted by EMPNO (this is arbitrary). Now that you know how many total\u000d\u000aduplicates there are and you have a ranking of each duplicate, the distance to the next\u000d\u000aHIREDATE is simply the total number of duplicates minus the current rank plus one\u000d\u000a(CNT-RN+1).\u000d\u000aSee Also\u000d\u000aFor additional examples of using LEAD OVER in the presence of duplicates (and a\u000d\u000amore thorough discussion of this technique), see Recipe 8.7 and Recipe 10.2.\u000d\u000a11.8 Shifting Row Values\u000d\u000aProblem\u000d\u000aYou want to return each employee\u2019s name and salary along with the next highest and\u000d\u000alowest salaries. If there are no higher or lower salaries, you want the results to wrap\u000d\u000a(first SAL shows last SAL and vice versa). You want to return the following result set:\u000d\u000a11.8 Shifting Row Values | 347","ENAME SAL FORWARD REWIND\u000d\u000a---------- ---------- ---------- ----------\u000d\u000aSMITH 800 950 5000\u000d\u000aJAMES 950 1100 800\u000d\u000aADAMS 1100 1250 950\u000d\u000aWARD 1250 1250 1100\u000d\u000aMARTIN 1250 1300 1250\u000d\u000aMILLER 1300 1500 1250\u000d\u000aTURNER 1500 1600 1300\u000d\u000aALLEN 1600 2450 1500\u000d\u000aCLARK 2450 2850 1600\u000d\u000aBLAKE 2850 2975 2450\u000d\u000aJONES 2975 3000 2850\u000d\u000aSCOTT 3000 3000 2975\u000d\u000aFORD 3000 5000 3000\u000d\u000aKING 5000 800 3000\u000d\u000aSolution\u000d\u000aThe window functions LEAD OVER and LAG OVER make this problem easy to\u000d\u000asolve and the resulting queries very readable. Use the window functions LAG OVER\u000d\u000aand LEAD OVER to access prior and next rows relative to the current row:\u000d\u000a1 select ename,sal,\u000d\u000a2 coalesce(lead(sal)over(order by sal),min(sal)over()) forward,\u000d\u000a3 coalesce(lag(sal)over(order by sal),max(sal)over()) rewind\u000d\u000a4 from emp\u000d\u000aDiscussion\u000d\u000aThe window functions LAG OVER and LEAD OVER will (by default and unless\u000d\u000aotherwise specified) return values from the row before and after the current row,\u000d\u000arespectively. You define what \u201cbefore\u201d or \u201cafter\u201d means in the ORDER BY portion of\u000d\u000athe OVER clause. If you examine the solution, the first step is to return the next and\u000d\u000aprior rows relative to the current row, ordered by SAL:\u000d\u000aselect ename,sal,\u000d\u000a lead(sal)over(order by sal) forward,\u000d\u000a lag(sal)over(order by sal) rewind\u000d\u000a from emp\u000d\u000aENAME SAL FORWARD REWIND\u000d\u000a---------- ---------- ---------- ----------\u000d\u000aSMITH 800 950\u000d\u000aJAMES 950 1100 800\u000d\u000aADAMS 1100 1250 950\u000d\u000aWARD 1250 1250 1100\u000d\u000aMARTIN 1250 1300 1250\u000d\u000aMILLER 1300 1500 1250\u000d\u000aTURNER 1500 1600 1300\u000d\u000a348 | Chapter 11: Advanced Searching","ALLEN 1600 2450 1500\u000d\u000aCLARK 2450 2850 1600\u000d\u000aBLAKE 2850 2975 2450\u000d\u000aJONES 2975 3000 2850\u000d\u000aSCOTT 3000 3000 2975\u000d\u000aFORD 3000 5000 3000\u000d\u000aKING 5000 3000\u000d\u000aNotice that REWIND is NULL for employee SMITH, and FORWARD is NULL for\u000d\u000aemployee KING; that is because those two employees have the lowest and highest sal\u2010\u000d\u000aaries, respectively. The requirement in the \u201cProblem\u201d section should NULL values\u000d\u000aexist in FORWARD or REWIND is to \u201cwrap\u201d the results, meaning that for the highest\u000d\u000aSAL, FORWARD should be the value of the lowest SAL in the table, and for the low\u2010\u000d\u000aest SAL, REWIND should be the value of the highest SAL in the table. The window\u000d\u000afunctions MIN OVER and MAX OVER with no partition or window specified (i.e.,\u000d\u000aan empty parentheses after the OVER clause) will return the lowest and highest salar\u2010\u000d\u000aies in the table, respectively. The results are shown here:\u000d\u000aselect ename,sal,\u000d\u000a coalesce(lead(sal)over(order by sal),min(sal)over()) forward,\u000d\u000a coalesce(lag(sal)over(order by sal),max(sal)over()) rewind\u000d\u000a from emp\u000d\u000aENAME SAL FORWARD REWIND\u000d\u000a---------- ---------- ---------- ----------\u000d\u000aSMITH 800 950 5000\u000d\u000aJAMES 950 1100 800\u000d\u000aADAMS 1100 1250 950\u000d\u000aWARD 1250 1250 1100\u000d\u000aMARTIN 1250 1300 1250\u000d\u000aMILLER 1300 1500 1250\u000d\u000aTURNER 1500 1600 1300\u000d\u000aALLEN 1600 2450 1500\u000d\u000aCLARK 2450 2850 1600\u000d\u000aBLAKE 2850 2975 2450\u000d\u000aJONES 2975 3000 2850\u000d\u000aSCOTT 3000 3000 2975\u000d\u000aFORD 3000 5000 3000\u000d\u000aKING 5000 800 3000\u000d\u000aAnother useful feature of LAG OVER and LEAD OVER is the ability to define how\u000d\u000afar forward or back you would like to go. In the example for this recipe, you go only\u000d\u000aone row forward or back. If want to move three rows forward and five rows back,\u000d\u000adoing so is simple. Just specify the values 3 and 5, as shown here:\u000d\u000aselect ename,sal,\u000d\u000a lead(sal,3)over(order by sal) forward,\u000d\u000a lag(sal,5)over(order by sal) rewind\u000d\u000a from emp\u000d\u000a11.8 Shifting Row Values | 349","ENAME SAL FORWARD REWIND\u000d\u000a---------- ---------- ---------- ----------\u000d\u000aSMITH 800 1250\u000d\u000aJAMES 950 1250\u000d\u000aADAMS 1100 1300\u000d\u000aWARD 1250 1500\u000d\u000aMARTIN 1250 1600\u000d\u000aMILLER 1300 2450 800\u000d\u000aTURNER 1500 2850 950\u000d\u000aALLEN 1600 2975 1100\u000d\u000aCLARK 2450 3000 1250\u000d\u000aBLAKE 2850 3000 1250\u000d\u000aJONES 2975 5000 1300\u000d\u000aSCOTT 3000 1500\u000d\u000aFORD 3000 1600\u000d\u000aKING 5000 2450\u000d\u000a11.9 Ranking Results\u000d\u000aProblem\u000d\u000aYou want to rank the salaries in table EMP while allowing for ties. You want to return\u000d\u000athe following result set:\u000d\u000aRNK SAL\u000d\u000a--- -------\u000d\u000a 1 800\u000d\u000a 2 950\u000d\u000a 3 1100\u000d\u000a 4 1250\u000d\u000a 4 1250\u000d\u000a 5 1300\u000d\u000a 6 1500\u000d\u000a 7 1600\u000d\u000a 8 2450\u000d\u000a 9 2850\u000d\u000a 10 2975\u000d\u000a 11 3000\u000d\u000a 11 3000\u000d\u000a 12 5000\u000d\u000aSolution\u000d\u000aWindow functions make ranking queries extremely simple. Three window functions\u000d\u000aare particularly useful for ranking: DENSE_RANK OVER, ROW_NUMBER OVER,\u000d\u000aand RANK OVER.\u000d\u000aBecause you want to allow for ties, use the window function DENSE_RANK OVER:\u000d\u000a1 select dense_rank() over(order by sal) rnk, sal\u000d\u000a2 from emp\u000d\u000a350 | Chapter 11: Advanced Searching","Discussion\u000d\u000aThe window function DENSE_RANK OVER does all the legwork here. In parenthe\u2010\u000d\u000ases following the OVER keyword you place an ORDER BY clause to specify the order\u000d\u000ain which rows are ranked. The solution uses ORDER BY SAL, so rows from EMP are\u000d\u000aranked in ascending order of salary.\u000d\u000a11.10 Suppressing Duplicates\u000d\u000aProblem\u000d\u000aYou want to find the different job types in table EMP but do not want to see dupli\u2010\u000d\u000acates. The result set should be as follows:\u000d\u000aJOB\u000d\u000a---------\u000d\u000aANALYST\u000d\u000aCLERK\u000d\u000aMANAGER\u000d\u000aPRESIDENT\u000d\u000aSALESMAN\u000d\u000aSolution\u000d\u000aAll of the RDBMSs support the keyword DISTINCT, and it arguably is the easiest\u000d\u000amechanism for suppressing duplicates from the result set. However, this recipe will\u000d\u000aalso cover two additional methods for suppressing duplicates.\u000d\u000aThe traditional method of using DISTINCT and sometimes GROUP BY certainly\u000d\u000aworks. The following solution is an alternative that makes use of the window function\u000d\u000aROW_NUMBER OVER:\u000d\u000a1 select job\u000d\u000a2 from (\u000d\u000a3 select job,\u000d\u000a4 row_number()over(partition by job order by job) rn\u000d\u000a5 from emp\u000d\u000a6 ) x\u000d\u000a7 where rn = 1\u000d\u000aTraditional alternatives\u000d\u000aUse the DISTINCT keyword to suppress duplicates from the result set:\u000d\u000aselect distinct job\u000d\u000a from emp\u000d\u000a11.10 Suppressing Duplicates | 351","Additionally, it is also possible to use GROUP BY to suppress duplicates:\u000d\u000aselect job\u000d\u000a from emp\u000d\u000a group by job\u000d\u000aDiscussion\u000d\u000aDB2, Oracle, and SQL Server\u000d\u000aThis solution depends on some outside-the-box thinking about partitioned window\u000d\u000afunctions. By using PARTITION BY in the OVER clause of ROW_NUMBER, you\u000d\u000acan reset the value returned by ROW_NUMBER to 1 whenever a new job is encoun\u2010\u000d\u000atered. The following results are from inline view X:\u000d\u000aselect job,\u000d\u000a row_number()over(partition by job order by job) rn\u000d\u000a from emp\u000d\u000aJOB RN\u000d\u000a--------- ----------\u000d\u000aANALYST 1\u000d\u000aANALYST 2\u000d\u000aCLERK 1\u000d\u000aCLERK 2\u000d\u000aCLERK 3\u000d\u000aCLERK 4\u000d\u000aMANAGER 1\u000d\u000aMANAGER 2\u000d\u000aMANAGER 3\u000d\u000aPRESIDENT 1\u000d\u000aSALESMAN 1\u000d\u000aSALESMAN 2\u000d\u000aSALESMAN 3\u000d\u000aSALESMAN 4\u000d\u000aEach row is given an increasing, sequential number, and that number is reset to one\u000d\u000awhenever the job changes. To filter out the duplicates, all you must do is keep the\u000d\u000arows where RN is 1.\u000d\u000aAn ORDER BY clause is mandatory when using ROW_NUMBER OVER (except in\u000d\u000aDB2) but doesn\u2019t affect the result. Which job is returned is irrelevant so long as you\u000d\u000areturn one of each job.\u000d\u000aTraditional alternatives\u000d\u000aThe first solution shows how to use the keyword DISTINCT to suppress duplicates\u000d\u000afrom a result set. Keep in mind that DISTINCT is applied to the whole SELECT list;\u000d\u000a352 | Chapter 11: Advanced Searching","additional columns can and will change the result set. Consider the difference\u000d\u000abetween these two queries:\u000d\u000aselect distinct job select distinct job, deptno\u000d\u000a from emp from emp\u000d\u000aJOB JOB DEPTNO\u000d\u000a--------- --------- ----------\u000d\u000aANALYST ANALYST 20\u000d\u000aCLERK CLERK 10\u000d\u000aMANAGER CLERK 20\u000d\u000aPRESIDENT CLERK 30\u000d\u000aSALESMAN MANAGER 10\u000d\u000a MANAGER 20\u000d\u000a MANAGER 30\u000d\u000a PRESIDENT 10\u000d\u000a SALESMAN 30\u000d\u000aBy adding DEPTNO to the SELECT list, what you return is each DISTINCT pair of\u000d\u000aJOB/DEPTNO values from table EMP.\u000d\u000aThe second solution uses GROUP BY to suppress duplicates. While using GROUP\u000d\u000aBY in this way is not uncommon, keep in mind that GROUP BY and DISTINCT are\u000d\u000atwo very different clauses that are not interchangeable. I\u2019ve included GROUP BY in\u000d\u000athis solution for completeness, as you will no doubt come across it at some point.\u000d\u000a11.11 Finding Knight Values\u000d\u000aProblem\u000d\u000aYou want return a result set that contains each employee\u2019s name, the department they\u000d\u000awork in, their salary, the date they were hired, and the salary of the last employee\u000d\u000ahired, in each department. You want to return the following result set:\u000d\u000aDEPTNO ENAME SAL HIREDATE LATEST_SAL\u000d\u000a------ ---------- ---------- ----------- ----------\u000d\u000a 10 MILLER 1300 23-JAN-2007 1300\u000d\u000a 10 KING 5000 17-NOV-2006 1300\u000d\u000a 10 CLARK 2450 09-JUN-2006 1300\u000d\u000a 20 ADAMS 1100 12-JAN-2007 1100\u000d\u000a 20 SCOTT 3000 09-DEC-2007 1100\u000d\u000a 20 FORD 3000 03-DEC-2006 1100\u000d\u000a 20 JONES 2975 02-APR-2006 1100\u000d\u000a 20 SMITH 800 17-DEC-2005 1100\u000d\u000a 30 JAMES 950 03-DEC-2006 950\u000d\u000a 30 MARTIN 1250 28-SEP-2006 950\u000d\u000a 30 TURNER 1500 08-SEP-2006 950\u000d\u000a 30 BLAKE 2850 01-MAY-2006 950\u000d\u000a 30 WARD 1250 22-FEB-2006 950\u000d\u000a 30 ALLEN 1600 20-FEB-2006 950\u000d\u000a11.11 Finding Knight Values | 353","The values in LATEST_SAL are the \u201cknight values\u201d because the path to find them is\u000d\u000aanalogous to a knight\u2019s path in the game of chess. You determine the result the way a\u000d\u000aknight determines a new location: by jumping to a row and then turning and jumping\u000d\u000ato a different column (see Figure 11-1). To find the correct values for LATEST_SAL,\u000d\u000ayou must first locate (jump to) the row with the latest HIREDATE in each DEPTNO,\u000d\u000aand then you select (jump to) the SAL column of that row.\u000d\u000aFigure 11-1. A knight value comes from \u201cup and over\u201d\u000d\u000aThe term knight value was coined by a clever coworker of Antho\u2010\u000d\u000any\u2019s, Kay Young. After having him review the recipes for correct\u2010\u000d\u000aness, Anthony admitted to Kay that he was stumped and could not\u000d\u000acome up with a good title. Because you need to initially evaluate\u000d\u000aone row and then \u201cjump\u201d and take a value from another, Kay came\u000d\u000aup with the term knight value.\u000d\u000aSolution\u000d\u000aDB2 and SQL Server\u000d\u000aUse a CASE expression in a subquery to return the SAL of the last employee hired in\u000d\u000aeach DEPTNO; for all other salaries, return 0. Use the window function MAX OVER\u000d\u000ain the outer query to return the nonzero SAL for each employee\u2019s department:\u000d\u000a 1 select deptno,\u000d\u000a 2 ename,\u000d\u000a 3 sal,\u000d\u000a 4 hiredate,\u000d\u000a 5 max(latest_sal)over(partition by deptno) latest_sal\u000d\u000a 6 from (\u000d\u000a 7 select deptno,\u000d\u000a 8 ename,\u000d\u000a 9 sal,\u000d\u000a354 | Chapter 11: Advanced Searching","10 hiredate,\u000d\u000a11 case\u000d\u000a12 when hiredate = max(hiredate)over(partition by deptno)\u000d\u000a13 then sal else 0\u000d\u000a14 end latest_sal\u000d\u000a15 from emp\u000d\u000a16 ) x\u000d\u000a17 order by 1, 4 desc\u000d\u000aOracle\u000d\u000aUse the window function MAX OVER to return the highest SAL for each DEPTNO. \u000d\u000aUse the functions DENSE_RANK and LAST, while ordering by HIREDATE in the\u000d\u000aKEEP clause to return the highest SAL for the latest HIREDATE in a given DEPTNO:\u000d\u000a1 select deptno,\u000d\u000a2 ename,\u000d\u000a3 sal,\u000d\u000a4 hiredate,\u000d\u000a5 max(sal)\u000d\u000a6 keep(dense_rank last order by hiredate)\u000d\u000a7 over(partition by deptno) latest_sal\u000d\u000a8 from emp\u000d\u000a9 order by 1, 4 desc\u000d\u000aDiscussion\u000d\u000aDB2 and SQL Server\u000d\u000aThe first step is to use the window function MAX OVER in a CASE expression to\u000d\u000afind the employee hired last, or most recently, in each DEPTNO. If an employee\u2019s\u000d\u000aHIREDATE matches the value returned by MAX OVER, then use a CASE expression\u000d\u000ato return that employee\u2019s SAL; otherwise, return zero. The results of this are shown\u000d\u000ahere:\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a sal,\u000d\u000a hiredate,\u000d\u000a case\u000d\u000a when hiredate = max(hiredate)over(partition by deptno)\u000d\u000a then sal else 0\u000d\u000a end latest_sal\u000d\u000a from emp\u000d\u000aDEPTNO ENAME SAL HIREDATE LATEST_SAL\u000d\u000a------ --------- ----------- ----------- ----------\u000d\u000a 10 CLARK 2450 09-JUN-2006 0\u000d\u000a 10 KING 5000 17-NOV-2006 0\u000d\u000a 10 MILLER 1300 23-JAN-2007 1300\u000d\u000a11.11 Finding Knight Values | 355"," 20 SMITH 800 17-DEC-2005 0\u000d\u000a 20 ADAMS 1100 12-JAN-2007 1100\u000d\u000a 20 FORD 3000 03-DEC-2006 0\u000d\u000a 20 SCOTT 3000 09-DEC-2007 0\u000d\u000a 20 JONES 2975 02-APR-2006 0\u000d\u000a 30 ALLEN 1600 20-FEB-2006 0\u000d\u000a 30 BLAKE 2850 01-MAY-2006 0\u000d\u000a 30 MARTIN 1250 28-SEP-2006 0\u000d\u000a 30 JAMES 950 03-DEC-2006 950\u000d\u000a 30 TURNER 1500 08-SEP-2006 0\u000d\u000a 30 WARD 1250 22-FEB-2006 0\u000d\u000aBecause the value for LATEST_SAL will be either zero or the SAL of the employee(s)\u000d\u000ahired most recently, you can wrap the previous query in an inline view and use MAX\u000d\u000aOVER again, but this time to return the greatest nonzero LATEST_SAL for each\u000d\u000aDEPTNO:\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a sal,\u000d\u000a hiredate,\u000d\u000a max(latest_sal)over(partition by deptno) latest_sal\u000d\u000a from (\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a sal,\u000d\u000a hiredate,\u000d\u000a case\u000d\u000a when hiredate = max(hiredate)over(partition by deptno)\u000d\u000a then sal else 0\u000d\u000a end latest_sal\u000d\u000a from emp\u000d\u000a ) x\u000d\u000a order by 1, 4 desc\u000d\u000aDEPTNO ENAME SAL HIREDATE LATEST_SAL\u000d\u000a------- --------- ---------- ----------- ----------\u000d\u000a 10 MILLER 1300 23-JAN-2007 1300\u000d\u000a 10 KING 5000 17-NOV-2006 1300\u000d\u000a 10 CLARK 2450 09-JUN-2006 1300\u000d\u000a 20 ADAMS 1100 12-JAN-2007 1100\u000d\u000a 20 SCOTT 3000 09-DEC-2007 1100\u000d\u000a 20 FORD 3000 03-DEC-2006 1100\u000d\u000a 20 JONES 2975 02-APR-2006 1100\u000d\u000a 20 SMITH 800 17-DEC-2005 1100\u000d\u000a 30 JAMES 950 03-DEC-2006 950\u000d\u000a 30 MARTIN 1250 28-SEP-2006 950\u000d\u000a 30 TURNER 1500 08-SEP-2006 950\u000d\u000a 30 BLAKE 2850 01-MAY-2006 950\u000d\u000a 30 WARD 1250 22-FEB-2006 950\u000d\u000a 30 ALLEN 1600 20-FEB-2006 950\u000d\u000a356 | Chapter 11: Advanced Searching","Oracle\u000d\u000aThe key to the Oracle solution is to take advantage of the KEEP clause. The KEEP\u000d\u000aclause allows you to rank the rows returned by a group/partition and work with the\u000d\u000afirst or last row in the group. Consider what the solution looks like without KEEP:\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a sal,\u000d\u000a hiredate,\u000d\u000a max(sal) over(partition by deptno) latest_sal\u000d\u000a from emp\u000d\u000a order by 1, 4 desc\u000d\u000aDEPTNO ENAME SAL HIREDATE LATEST_SAL\u000d\u000a------ ---------- ---------- ----------- ----------\u000d\u000a 10 MILLER 1300 23-JAN-2007 5000\u000d\u000a 10 KING 5000 17-NOV-2006 5000\u000d\u000a 10 CLARK 2450 09-JUN-2006 5000\u000d\u000a 20 ADAMS 1100 12-JAN-2007 3000\u000d\u000a 20 SCOTT 3000 09-DEC-2007 3000\u000d\u000a 20 FORD 3000 03-DEC-2006 3000\u000d\u000a 20 JONES 2975 02-APR-2006 3000\u000d\u000a 20 SMITH 800 17-DEC-2005 3000\u000d\u000a 30 JAMES 950 03-DEC-2006 2850\u000d\u000a 30 MARTIN 1250 28-SEP-2006 2850\u000d\u000a 30 TURNER 1500 08-SEP-2006 2850\u000d\u000a 30 BLAKE 2850 01-MAY-2006 2850\u000d\u000a 30 WARD 1250 22-FEB-2006 2850\u000d\u000a 30 ALLEN 1600 20-FEB-2006 2850\u000d\u000aRather than returning the SAL of the latest employee hired, MAX OVER without\u000d\u000aKEEP simply returns the highest salary in each DEPTNO. KEEP, in this recipe, allows\u000d\u000ayou to order the salaries by HIREDATE in each DEPTNO by specifying ORDER BY\u000d\u000aHIREDATE. Then, the function DENSE_RANK assigns a rank to each HIREDATE in\u000d\u000aascending order. Finally, the function LAST determines which row to apply the\u000d\u000aaggregate function to: the \u201clast\u201d row based on the ranking of DENSE_RANK. In this\u000d\u000acase, the aggregate function MAX is applied to the SAL column for the row with the\u000d\u000a\u201clast\u201d HIREDATE. In essence, keep the SAL of the HIREDATE ranked last in each\u000d\u000aDEPTNO.\u000d\u000aYou are ranking the rows in each DEPTNO based on one column (HIREDATE), but\u000d\u000athen applying the aggregation (MAX) on another column (SAL). This ability to rank\u000d\u000ain one dimension and aggregate over another is convenient as it allows you to avoid\u000d\u000aextra joins and inline views as are used in the other solutions. Finally, by adding the\u000d\u000aOVER clause after the KEEP clause, you can return the SAL \u201ckept\u201d by KEEP for each\u000d\u000arow in the partition.\u000d\u000a11.11 Finding Knight Values | 357","Alternatively, you can order by HIREDATE in descending order and \u201ckeep\u201d the first\u000d\u000aSAL. Compare the following two queries, which return the same result set:\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a sal,\u000d\u000a hiredate,\u000d\u000a max(sal)\u000d\u000a keep(dense_rank last order by hiredate)\u000d\u000a over(partition by deptno) latest_sal\u000d\u000a from emp\u000d\u000a order by 1, 4 desc\u000d\u000aDEPTNO ENAME SAL HIREDATE LATEST_SAL\u000d\u000a------ ---------- ---------- ----------- ----------\u000d\u000a 10 MILLER 1300 23-JAN-2007 1300\u000d\u000a 10 KING 5000 17-NOV-2006 1300\u000d\u000a 10 CLARK 2450 09-JUN-2006 1300\u000d\u000a 20 ADAMS 1100 12-JAN-2007 1100\u000d\u000a 20 SCOTT 3000 09-DEC-2007 1100\u000d\u000a 20 FORD 3000 03-DEC-2006 1100\u000d\u000a 20 JONES 2975 02-APR-2006 1100\u000d\u000a 20 SMITH 800 17-DEC-2005 1100\u000d\u000a 30 JAMES 950 03-DEC-2006 950\u000d\u000a 30 MARTIN 1250 28-SEP-2006 950\u000d\u000a 30 TURNER 1500 08-SEP-2006 950\u000d\u000a 30 BLAKE 2850 01-MAY-2006 950\u000d\u000a 30 WARD 1250 22-FEB-2006 950\u000d\u000a 30 ALLEN 1600 20-FEB-2006 950\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a sal,\u000d\u000a hiredate,\u000d\u000a max(sal)\u000d\u000a keep(dense_rank first order by hiredate desc)\u000d\u000a over(partition by deptno) latest_sal\u000d\u000a from emp\u000d\u000a order by 1, 4 desc\u000d\u000aDEPTNO ENAME SAL HIREDATE LATEST_SAL\u000d\u000a------ ---------- ---------- ----------- ----------\u000d\u000a 10 MILLER 1300 23-JAN-2007 1300\u000d\u000a 10 KING 5000 17-NOV-2006 1300\u000d\u000a 10 CLARK 2450 09-JUN-2006 1300\u000d\u000a 20 ADAMS 1100 12-JAN-2007 1100\u000d\u000a 20 SCOTT 3000 09-DEC-2007 1100\u000d\u000a 20 FORD 3000 03-DEC-2006 1100\u000d\u000a 20 JONES 2975 02-APR-2006 1100\u000d\u000a358 | Chapter 11: Advanced Searching"," 20 SMITH 800 17-DEC-2005 1100\u000d\u000a 30 JAMES 950 03-DEC-2006 950\u000d\u000a 30 MARTIN 1250 28-SEP-2006 950\u000d\u000a 30 TURNER 1500 08-SEP-2006 950\u000d\u000a 30 BLAKE 2850 01-MAY-2006 950\u000d\u000a 30 WARD 1250 22-FEB-2006 950\u000d\u000a 30 ALLEN 1600 20-FEB-2006 950\u000d\u000a11.12 Generating Simple Forecasts\u000d\u000aProblem\u000d\u000aBased on current data, you want to return additional rows and columns representing\u000d\u000afuture actions. For example, consider the following result set:\u000d\u000aID ORDER_DATE PROCESS_DATE\u000d\u000a-- ----------- ------------\u000d\u000a 1 25-SEP-2005 27-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005\u000d\u000aYou want to return three rows per row returned in your result set (each row plus two\u000d\u000aadditional rows for each order). Along with the extra rows, you would like to return\u000d\u000atwo additional columns providing dates for expected order processing.\u000d\u000aFrom the previous result set, you can see that an order takes two days to process. For\u000d\u000athe purposes of this example, let\u2019s say the next step after processing is verification,\u000d\u000aand the last step is shipment. Verification occurs one day after processing, and ship\u2010\u000d\u000ament occurs one day after verification. You want to return a result set expressing the\u000d\u000awhole procedure. Ultimately you want to transform the previous result set to the fol\u2010\u000d\u000alowing result set:\u000d\u000aID ORDER_DATE PROCESS_DATE VERIFIED SHIPPED\u000d\u000a-- ----------- ------------ ----------- -----------\u000d\u000a 1 25-SEP-2005 27-SEP-2005\u000d\u000a 1 25-SEP-2005 27-SEP-2005 28-SEP-2005\u000d\u000a 1 25-SEP-2005 27-SEP-2005 28-SEP-2005 29-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005 29-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005 29-SEP-2005 30-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005 30-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005 30-SEP-2005 01-OCT-2005\u000d\u000aSolution\u000d\u000aThe key is to use a Cartesian product to generate two additional rows for each order\u000d\u000aand then simply use CASE expressions to create the required column values.\u000d\u000a11.12 Generating Simple Forecasts | 359","DB2, MySQL, and SQL Server\u000d\u000aUse the recursive WITH clause to generate rows needed for your Cartesian product.\u000d\u000aThe DB2 and SQL Server solutions are identical except for the function used to\u000d\u000aretrieve the current date. DB2 uses CURRENT_DATE and SQL Server uses GETDATE. MySQL uses the CURDATE and requires the insertion of the keyword\u000d\u000aRECURSIVE after WITH to indicate that this is a recursive CTE. The SQL Server sol\u2010\u000d\u000aution is shown here:\u000d\u000a 1 with nrows(n) as (\u000d\u000a 2 select 1 from t1 union all\u000d\u000a 3 select n+1 from nrows where n+1 <= 3\u000d\u000a 4 )\u000d\u000a 5 select id,\u000d\u000a 6 order_date,\u000d\u000a 7 process_date,\u000d\u000a 8 case when nrows.n >= 2\u000d\u000a 9 then process_date+1\u000d\u000a10 else null\u000d\u000a11 end as verified,\u000d\u000a12 case when nrows.n = 3\u000d\u000a13 then process_date+2\u000d\u000a14 else null\u000d\u000a15 end as shipped\u000d\u000a16 from (\u000d\u000a17 select nrows.n id,\u000d\u000a18 getdate()+nrows.n as order_date,\u000d\u000a19 getdate()+nrows.n+2 as process_date\u000d\u000a20 from nrows\u000d\u000a21 ) orders, nrows\u000d\u000a22 order by 1\u000d\u000aOracle\u000d\u000aUse the hierarchical CONNECT BY clause to generate the three rows needed for the\u000d\u000aCartesian product. Use the WITH clause to allow you to reuse the results returned by\u000d\u000aCONNECT BY without having to call it again:\u000d\u000a 1 with nrows as (\u000d\u000a 2 select level n\u000d\u000a 3 from dual\u000d\u000a 4 connect by level <= 3\u000d\u000a 5 )\u000d\u000a 6 select id,\u000d\u000a 7 order_date,\u000d\u000a 8 process_date,\u000d\u000a 9 case when nrows.n >= 2\u000d\u000a10 then process_date+1\u000d\u000a11 else null\u000d\u000a12 end as verified,\u000d\u000a13 case when nrows.n = 3\u000d\u000a360 | Chapter 11: Advanced Searching","14 then process_date+2\u000d\u000a15 else null\u000d\u000a16 end as shipped\u000d\u000a17 from (\u000d\u000a18 select nrows.n id,\u000d\u000a19 sysdate+nrows.n as order_date,\u000d\u000a20 sysdate+nrows.n+2 as process_date\u000d\u000a21 from nrows\u000d\u000a22 ) orders, nrows\u000d\u000aPostgreSQL\u000d\u000aYou can create a Cartesian product many different ways; this solution uses the Post\u2010\u000d\u000agreSQL function GENERATE_SERIES:\u000d\u000a 1 select id,\u000d\u000a 2 order_date,\u000d\u000a 3 process_date,\u000d\u000a 4 case when gs.n >= 2\u000d\u000a 5 then process_date+1\u000d\u000a 6 else null\u000d\u000a 7 end as verified,\u000d\u000a 8 case when gs.n = 3\u000d\u000a 9 then process_date+2\u000d\u000a10 else null\u000d\u000a11 end as shipped\u000d\u000a12 from (\u000d\u000a13 select gs.id,\u000d\u000a14 current_date+gs.id as order_date,\u000d\u000a15 current_date+gs.id+2 as process_date\u000d\u000a16 from generate_series(1,3) gs (id)\u000d\u000a17 ) orders,\u000d\u000a18 generate_series(1,3)gs(n)\u000d\u000aMySQL\u000d\u000aMySQL does not support a function for automatic row generation.\u000d\u000aDiscussion\u000d\u000aDB2, MySQL, and SQL Server\u000d\u000aThe result set presented in the \u201cProblem\u201d section is returned via inline view\u000d\u000aORDERS, and is shown here:\u000d\u000awith nrows(n) as (\u000d\u000aselect 1 from t1 union all\u000d\u000aselect n+1 from nrows where n+1 <= 3\u000d\u000a)\u000d\u000aselect nrows.n id,getdate()+nrows.n as order_date,\u000d\u000a getdate()+nrows.n+2 as process_date\u000d\u000a from nrows\u000d\u000a11.12 Generating Simple Forecasts | 361","ID ORDER_DATE PROCESS_DATE\u000d\u000a-- ----------- ------------\u000d\u000a 1 25-SEP-2005 27-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005\u000d\u000aThis query simply uses the WITH clause to make up three rows representing the\u000d\u000aorders you must process. NROWS returns the values 1, 2, and 3, and those numbers\u000d\u000aare added to GETDATE (CURRENT_DATE for DB2, CURDATE() for MySQL) to\u000d\u000arepresent the dates of the orders. Because the \u201cProblem\u201d section states that processing\u000d\u000atime takes two days, the query also adds two days to the ORDER_DATE (adds the\u000d\u000avalue returned by NROWS to GETDATE and then adds two more days).\u000d\u000aNow that you have your base result set, the next step is to create a Cartesian product\u000d\u000abecause the requirement is to return three rows for each order. Use NROWS to create\u000d\u000aa Cartesian product to return three rows for each order:\u000d\u000awith nrows(n) as (\u000d\u000aselect 1 from t1 union all\u000d\u000aselect n+1 from nrows where n+1 <= 3\u000d\u000a)\u000d\u000aselect nrows.n,\u000d\u000a orders.*\u000d\u000a from (\u000d\u000aselect nrows.n id,\u000d\u000a getdate()+nrows.n as order_date,\u000d\u000a getdate()+nrows.n+2 as process_date\u000d\u000a from nrows\u000d\u000a ) orders, nrows\u000d\u000a order by 2,1\u000d\u000a N ID ORDER_DATE PROCESS_DATE\u000d\u000a--- --- ----------- ------------\u000d\u000a 1 1 25-SEP-2005 27-SEP-2005\u000d\u000a 2 1 25-SEP-2005 27-SEP-2005\u000d\u000a 3 1 25-SEP-2005 27-SEP-2005\u000d\u000a 1 2 26-SEP-2005 28-SEP-2005\u000d\u000a 2 2 26-SEP-2005 28-SEP-2005\u000d\u000a 3 2 26-SEP-2005 28-SEP-2005\u000d\u000a 1 3 27-SEP-2005 29-SEP-2005\u000d\u000a 2 3 27-SEP-2005 29-SEP-2005\u000d\u000a 3 3 27-SEP-2005 29-SEP-2005\u000d\u000aNow that you have three rows for each order, simply use a CASE expression to create\u000d\u000athe addition column values to represent the status of verification and shipment.\u000d\u000a362 | Chapter 11: Advanced Searching","The first row for each order should have a NULL value for VERIFIED and SHIPPED.\u000d\u000aThe second row for each order should have a NULL value for SHIPPED. The third\u000d\u000arow for each order should have non-NULL values for each column. The final result\u000d\u000aset is shown here:\u000d\u000awith nrows(n) as (\u000d\u000aselect 1 from t1 union all\u000d\u000aselect n+1 from nrows where n+1 <= 3\u000d\u000a)\u000d\u000aselect id,\u000d\u000a order_date,\u000d\u000a process_date,\u000d\u000a case when nrows.n >= 2\u000d\u000a then process_date+1\u000d\u000a else null\u000d\u000a end as verified,\u000d\u000a case when nrows.n = 3\u000d\u000a then process_date+2\u000d\u000a else null\u000d\u000a end as shipped\u000d\u000a from (\u000d\u000aselect nrows.n id,\u000d\u000a getdate()+nrows.n as order_date,\u000d\u000a getdate()+nrows.n+2 as process_date\u000d\u000a from nrows\u000d\u000a ) orders, nrows\u000d\u000a order by 1\u000d\u000aID ORDER_DATE PROCESS_DATE VERIFIED SHIPPED\u000d\u000a-- ----------- ------------ ----------- -----------\u000d\u000a 1 25-SEP-2005 27-SEP-2005\u000d\u000a 1 25-SEP-2005 27-SEP-2005 28-SEP-2005\u000d\u000a 1 25-SEP-2005 27-SEP-2005 28-SEP-2005 29-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005 29-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005 29-SEP-2005 30-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005 30-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005 30-SEP-2005 01-OCT-2005\u000d\u000aThe final result set expresses the complete order process, from the day the order was\u000d\u000areceived to the day it should be shipped.\u000d\u000aOracle\u000d\u000aThe result set presented in the problem section is returned via inline view ORDERS\u000d\u000aand is shown here:\u000d\u000awith nrows as (\u000d\u000aselect level n\u000d\u000a from dual\u000d\u000a11.12 Generating Simple Forecasts | 363","connect by level <= 3\u000d\u000a)\u000d\u000aselect nrows.n id,\u000d\u000a sysdate+nrows.n order_date,\u000d\u000a sysdate+nrows.n+2 process_date\u000d\u000a from nrows\u000d\u000aID ORDER_DATE PROCESS_DATE\u000d\u000a-- ----------- ------------\u000d\u000a 1 25-SEP-2005 27-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005\u000d\u000aThis query simply uses CONNECT BY to make up three rows representing the\u000d\u000aorders you must process. Use the WITH clause to refer to the rows returned by CON\u2010\u000d\u000aNECT BY as NROWS.N. CONNECT BY returns the values 1, 2, and 3, and those\u000d\u000anumbers are added to SYSDATE to represent the dates of the orders. Since the \u201cProb\u2010\u000d\u000alem\u201d section states that processing time takes two days, the query also adds two days\u000d\u000ato the ORDER_DATE (adds the value returned by GENERATE_ SERIES to SYS\u2010\u000d\u000aDATE and then adds two more days).\u000d\u000aNow that you have your base result set, the next step is to create a Cartesian product\u000d\u000abecause the requirement is to return three rows for each order. Use NROWS to create\u000d\u000aa Cartesian product to return three rows for each order:\u000d\u000awith nrows as (\u000d\u000aselect level n\u000d\u000a from dual\u000d\u000aconnect by level <= 3\u000d\u000a)\u000d\u000aselect nrows.n,\u000d\u000a orders.*\u000d\u000a from (\u000d\u000aselect nrows.n id,\u000d\u000a sysdate+nrows.n order_date,\u000d\u000a sysdate+nrows.n+2 process_date\u000d\u000a from nrows\u000d\u000a ) orders, nrows\u000d\u000a N ID ORDER_DATE PROCESS_DATE\u000d\u000a--- --- ----------- ------------\u000d\u000a 1 1 25-SEP-2005 27-SEP-2005\u000d\u000a 2 1 25-SEP-2005 27-SEP-2005\u000d\u000a 3 1 25-SEP-2005 27-SEP-2005\u000d\u000a 1 2 26-SEP-2005 28-SEP-2005\u000d\u000a 2 2 26-SEP-2005 28-SEP-2005\u000d\u000a 3 2 26-SEP-2005 28-SEP-2005\u000d\u000a 1 3 27-SEP-2005 29-SEP-2005\u000d\u000a 2 3 27-SEP-2005 29-SEP-2005\u000d\u000a 3 3 27-SEP-2005 29-SEP-2005\u000d\u000a364 | Chapter 11: Advanced Searching","Now that you have three rows for each order, simply use a CASE expression to create\u000d\u000athe addition column values to represent the status of verification and shipment.\u000d\u000aThe first row for each order should have a NULL value for VERIFIED and SHIPPED.\u000d\u000aThe second row for each order should have a NULL value for SHIPPED. The third\u000d\u000arow for each order should have non-NULL values for each column. The final result\u000d\u000aset is shown here:\u000d\u000awith nrows as (\u000d\u000aselect level n\u000d\u000a from dual\u000d\u000aconnect by level <= 3\u000d\u000a)\u000d\u000aselect id,\u000d\u000a order_date,\u000d\u000a process_date,\u000d\u000a case when nrows.n >= 2\u000d\u000a then process_date+1\u000d\u000a else null\u000d\u000a end as verified,\u000d\u000a case when nrows.n = 3\u000d\u000a then process_date+2\u000d\u000a else null\u000d\u000a end as shipped\u000d\u000a from (\u000d\u000aselect nrows.n id,\u000d\u000a sysdate+nrows.n order_date,\u000d\u000a sysdate+nrows.n+2 process_date\u000d\u000a from nrows\u000d\u000a ) orders, nrows\u000d\u000a ID ORDER_DATE PROCESS_DATE VERIFIED SHIPPED\u000d\u000a -- ----------- ------------ ----------- -----------\u000d\u000a 1 25-SEP-2005 27-SEP-2005\u000d\u000a 1 25-SEP-2005 27-SEP-2005 28-SEP-2005\u000d\u000a 1 25-SEP-2005 27-SEP-2005 28-SEP-2005 29-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005 29-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005 29-SEP-2005 30-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005 30-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005 30-SEP-2005 01-OCT-2005\u000d\u000aThe final result set expresses the complete order process from the day the order was\u000d\u000areceived to the day it should be shipped.\u000d\u000aPostgreSQL\u000d\u000aThe result set presented in the problem section is returned via inline view ORDERS\u000d\u000aand is shown here:\u000d\u000a11.12 Generating Simple Forecasts | 365","select gs.id,\u000d\u000a current_date+gs.id as order_date,\u000d\u000a current_date+gs.id+2 as process_date\u000d\u000a from generate_series(1,3) gs (id)\u000d\u000aID ORDER_DATE PROCESS_DATE\u000d\u000a-- ----------- ------------\u000d\u000a 1 25-SEP-2005 27-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005\u000d\u000aThis query simply uses the GENERATE_SERIES function to make up three rows rep\u2010\u000d\u000aresenting the orders you must process. GENERATE_SERIES returns the values 1, 2,\u000d\u000aand 3, and those numbers are added to CURRENT_DATE to represent the dates of\u000d\u000athe orders. Since the \u201cProblem\u201d section states that processing time takes two days, the\u000d\u000aquery also adds two days to the ORDER_DATE (adds the value returned by GENER\u2010\u000d\u000aATE_SERIES to CURRENT_DATE and then adds two more days). Now that you\u000d\u000ahave your base result set, the next step is to create a Cartesian product because the\u000d\u000arequirement is to return three rows for each order. Use the GENERATE_ SERIES\u000d\u000afunction to create a Cartesian product to return three rows for each order:\u000d\u000aselect gs.n,\u000d\u000a orders.*\u000d\u000a from (\u000d\u000aselect gs.id,\u000d\u000a current_date+gs.id as order_date,\u000d\u000a current_date+gs.id+2 as process_date\u000d\u000a from generate_series(1,3) gs (id)\u000d\u000a ) orders,\u000d\u000a generate_series(1,3)gs(n)\u000d\u000a N ID ORDER_DATE PROCESS_DATE\u000d\u000a--- --- ----------- ------------\u000d\u000a 1 1 25-SEP-2005 27-SEP-2005\u000d\u000a 2 1 25-SEP-2005 27-SEP-2005\u000d\u000a 3 1 25-SEP-2005 27-SEP-2005\u000d\u000a 1 2 26-SEP-2005 28-SEP-2005\u000d\u000a 2 2 26-SEP-2005 28-SEP-2005\u000d\u000a 3 2 26-SEP-2005 28-SEP-2005\u000d\u000a 1 3 27-SEP-2005 29-SEP-2005\u000d\u000a 2 3 27-SEP-2005 29-SEP-2005\u000d\u000a 3 3 27-SEP-2005 29-SEP-2005\u000d\u000aNow that you have three rows for each order, simply use a CASE expression to create\u000d\u000athe addition column values to represent the status of verification and shipment.\u000d\u000aThe first row for each order should have a NULL value for VERIFIED and SHIPPED.\u000d\u000aThe second row for each order should have a NULL value for SHIPPED. The third\u000d\u000arow for each order should have non-NULL values for each column. The final result\u000d\u000aset is shown here:\u000d\u000a366 | Chapter 11: Advanced Searching","select id,\u000d\u000a order_date,\u000d\u000a process_date,\u000d\u000a case when gs.n >= 2\u000d\u000a then process_date+1\u000d\u000a else null\u000d\u000a end as verified,\u000d\u000a case when gs.n = 3\u000d\u000a then process_date+2\u000d\u000a else null\u000d\u000a end as shipped\u000d\u000a from (\u000d\u000aselect gs.id,\u000d\u000a current_date+gs.id as order_date,\u000d\u000a current_date+gs.id+2 as process_date\u000d\u000a from generate_series(1,3) gs(id)\u000d\u000a ) orders,\u000d\u000a generate_series(1,3)gs(n)\u000d\u000aID ORDER_DATE PROCESS_DATE VERIFIED SHIPPED\u000d\u000a-- ----------- ------------ ----------- -----------\u000d\u000a 1 25-SEP-2005 27-SEP-2005\u000d\u000a 1 25-SEP-2005 27-SEP-2005 28-SEP-2005\u000d\u000a 1 25-SEP-2005 27-SEP-2005 28-SEP-2005 29-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005 29-SEP-2005\u000d\u000a 2 26-SEP-2005 28-SEP-2005 29-SEP-2005 30-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005 30-SEP-2005\u000d\u000a 3 27-SEP-2005 29-SEP-2005 30-SEP-2005 01-OCT-2005\u000d\u000aThe final result set expresses the complete order process from the day the order was\u000d\u000areceived to the day it should be shipped.\u000d\u000a11.13 Summing Up\u000d\u000aThe recipes from this chapter represent practical problems that can\u2019t be solved with a\u000d\u000asingle function. They are some the kinds of problems that business users will fre\u2010\u000d\u000aquently look to you to solve for them.\u000d\u000a11.13 Summing Up | 367","","CHAPTER 12\u000d\u000aReporting and Reshaping\u000d\u000aThis chapter introduces queries you may find helpful for creating reports. These typi\u2010\u000d\u000acally involve reporting-specific formatting considerations along with different levels\u000d\u000aof aggregation. Another focus of this chapter is transposing or pivoting result sets:\u000d\u000areshaping the data by turning rows into columns.\u000d\u000aIn general, these recipes have in common that they allow you to present data in for\u2010\u000d\u000amats or shapes different from the way they are stored. As your comfort level with piv\u2010\u000d\u000aoting increases, you\u2019ll undoubtedly find uses for it outside of what are presented in\u000d\u000athis chapter.\u000d\u000a12.1 Pivoting a Result Set into One Row\u000d\u000aProblem\u000d\u000aYou want to take values from groups of rows and turn those values into columns in a\u000d\u000asingle row per group. For example, you have a result set displaying the number of\u000d\u000aemployees in each department:\u000d\u000aDEPTNO CNT\u000d\u000a------ ----------\u000d\u000a 10 3\u000d\u000a 20 5\u000d\u000a 30 6\u000d\u000aYou would like to reformat the output so that the result set looks as follows:\u000d\u000aDEPTNO_10 DEPTNO_20 DEPTNO_30\u000d\u000a--------- ---------- ----------\u000d\u000a 3 5 6\u000d\u000a369","This is a classic example of data presented in a different shape than the way it is\u000d\u000astored.\u000d\u000aSolution\u000d\u000aTranspose the result set using CASE and the aggregate function SUM:\u000d\u000a1 select sum(case when deptno=10 then 1 else 0 end) as deptno_10,\u000d\u000a2 sum(case when deptno=20 then 1 else 0 end) as deptno_20,\u000d\u000a3 sum(case when deptno=30 then 1 else 0 end) as deptno_30\u000d\u000a4 from emp\u000d\u000aDiscussion\u000d\u000aThis example is an excellent introduction to pivoting. The concept is simple: for each\u000d\u000arow returned by the unpivoted query, use a CASE expression to separate the rows\u000d\u000ainto columns. Then, because this particular problem is to count the number of\u000d\u000aemployees per department, use the aggregate function SUM to count the occurrence\u000d\u000aof each DEPTNO. If you\u2019re having trouble understanding how this works exactly,\u000d\u000aexecute the query with the aggregate function SUM and include DEPTNO for\u000d\u000areadability:\u000d\u000aselect deptno,\u000d\u000a case when deptno=10 then 1 else 0 end as deptno_10,\u000d\u000a case when deptno=20 then 1 else 0 end as deptno_20,\u000d\u000a case when deptno=30 then 1 else 0 end as deptno_30\u000d\u000a from emp\u000d\u000a order by 1\u000d\u000a DEPTNO DEPTNO_10 DEPTNO_20 DEPTNO_30\u000d\u000a ------ ---------- ---------- ----------\u000d\u000a 10 1 0 0\u000d\u000a 10 1 0 0\u000d\u000a 10 1 0 0\u000d\u000a 20 0 1 0\u000d\u000a 20 0 1 0\u000d\u000a 20 0 1 0\u000d\u000a 20 0 1 0\u000d\u000a 30 0 0 1\u000d\u000a 30 0 0 1\u000d\u000a 30 0 0 1\u000d\u000a 30 0 0 1\u000d\u000a 30 0 0 1\u000d\u000a 30 0 0 1\u000d\u000aYou can think of each CASE expression as a flag to determine which DEPTNO a row\u000d\u000abelongs to. At this point, the \u201crows to columns\u201d transformation is already done; the\u000d\u000anext step is to simply sum the values returned by DEPTNO_10, DEPTNO_20, and\u000d\u000aDEPTNO_30, and then to group by DEPTNO. The following are the results:\u000d\u000a370 | Chapter 12: Reporting and Reshaping","select deptno,\u000d\u000a sum(case when deptno=10 then 1 else 0 end) as deptno_10,\u000d\u000a sum(case when deptno=20 then 1 else 0 end) as deptno_20,\u000d\u000a sum(case when deptno=30 then 1 else 0 end) as deptno_30\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000aDEPTNO DEPTNO_10 DEPTNO_20 DEPTNO_30\u000d\u000a------ ---------- ---------- ----------\u000d\u000a 10 3 0 0\u000d\u000a 20 0 5 0\u000d\u000a 30 0 0 6\u000d\u000aIf you inspect this result set, you see that logically the output makes sense; for exam\u2010\u000d\u000aple, DEPTNO 10 has three employees in DEPTNO_10 and zero in the other depart\u2010\u000d\u000aments. Since the goal is to return one row, the last step is to remove the DEPTNO and\u000d\u000aGROUP BY clause and simply sum the CASE expressions:\u000d\u000aselect sum(case when deptno=10 then 1 else 0 end) as deptno_10,\u000d\u000a sum(case when deptno=20 then 1 else 0 end) as deptno_20,\u000d\u000a sum(case when deptno=30 then 1 else 0 end) as deptno_30\u000d\u000a from emp\u000d\u000a DEPTNO_10 DEPTNO_20 DEPTNO_30\u000d\u000a --------- ---------- ----------\u000d\u000a 3 5 6\u000d\u000aThe following is another approach that you may sometimes see applied to this same\u000d\u000asort of problem:\u000d\u000aselect max(case when deptno=10 then empcount else null end) as deptno_10\u000d\u000a max(case when deptno=20 then empcount else null end) as deptno_20,\u000d\u000a max(case when deptno=10 then empcount else null end) as deptno_30\u000d\u000a from (\u000d\u000aselect deptno, count(*) as empcount\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000a ) x\u000d\u000aThis approach uses an inline view to generate the employee counts per department.\u000d\u000aCASE expressions in the main query translate rows to columns, getting you to the\u000d\u000afollowing results:\u000d\u000aDEPTNO_10 DEPTNO_20 DEPTNO_30\u000d\u000a--------- ---------- ----------\u000d\u000a 3 NULL NULL\u000d\u000a NULL 5 NULL\u000d\u000a NULL NULL 6\u000d\u000aThen the MAX functions collapses the columns into one row:\u000d\u000a12.1 Pivoting a Result Set into One Row | 371","DEPTNO_10 DEPTNO_20 DEPTNO_30\u000d\u000a--------- ---------- ----------\u000d\u000a 3 5 6\u000d\u000a12.2 Pivoting a Result Set into Multiple Rows\u000d\u000aProblem\u000d\u000aYou want to turn rows into columns by creating a column corresponding to each of\u000d\u000athe values in a single given column. However, unlike in the previous recipe, you need\u000d\u000amultiple rows of output. Like the earlier recipe, pivoting into multiple rows is a fun\u2010\u000d\u000adamental method of reshaping data.\u000d\u000aFor example, you want to return each employee and their position (JOB), and you\u000d\u000acurrently use a query that returns the following result set:\u000d\u000aJOB ENAME\u000d\u000a--------- ----------\u000d\u000aANALYST SCOTT\u000d\u000aANALYST FORD\u000d\u000aCLERK SMITH\u000d\u000aCLERK ADAMS\u000d\u000aCLERK MILLER\u000d\u000aCLERK JAMES\u000d\u000aMANAGER JONES\u000d\u000aMANAGER CLARK\u000d\u000aMANAGER BLAKE\u000d\u000aPRESIDENT KING\u000d\u000aSALESMAN ALLEN\u000d\u000aSALESMAN MARTIN\u000d\u000aSALESMAN TURNER\u000d\u000aSALESMAN WARD\u000d\u000aYou would like to format the result set such that each job gets its own column:\u000d\u000aCLERKS ANALYSTS MGRS PREZ SALES\u000d\u000a------ -------- ----- ---- ------\u000d\u000aMILLER FORD CLARK KING TURNER\u000d\u000aJAMES SCOTT BLAKE MARTIN\u000d\u000aADAMS JONES WARD\u000d\u000aSMITH ALLEN\u000d\u000aSolution\u000d\u000aUnlike the first recipe in this chapter, the result set for this recipe consists of more\u000d\u000athan one row. Using the previous recipe\u2019s technique will not work for this recipe, as\u000d\u000athe MAX(ENAME) for each JOB would be returned, which would result in one\u000d\u000aENAME for each JOB (i.e., one row will be returned as in the first recipe). To solve\u000d\u000a372 | Chapter 12: Reporting and Reshaping","this problem, you must make each JOB/ENAME combination unique. Then, when\u000d\u000ayou apply an aggregate function to remove NULLs, you don\u2019t lose any ENAMEs.\u000d\u000aUse the ranking function ROW_NUMBER OVER to make each JOB/ENAME combi\u2010\u000d\u000anation unique. Pivot the result set using a CASE expression and the aggregate func\u2010\u000d\u000ation MAX while grouping on the value returned by the window function:\u000d\u000a 1 select max(case when job='CLERK'\u000d\u000a 2 then ename else null end) as clerks,\u000d\u000a 3 max(case when job='ANALYST'\u000d\u000a 4 then ename else null end) as analysts,\u000d\u000a 5 max(case when job='MANAGER'\u000d\u000a 6 then ename else null end) as mgrs,\u000d\u000a 7 max(case when job='PRESIDENT'\u000d\u000a 8 then ename else null end) as prez,\u000d\u000a 9 max(case when job='SALESMAN'\u000d\u000a10 then ename else null end) as sales\u000d\u000a11 from (\u000d\u000a12 select job,\u000d\u000a13 ename,\u000d\u000a14 row_number()over(partition by job order by ename) rn\u000d\u000a15 from emp\u000d\u000a16 ) x\u000d\u000a17 group by rn\u000d\u000aDiscussion\u000d\u000aThe first step is to use the window function ROW_NUMBER OVER to help make\u000d\u000aeach JOB/ENAME combination unique:\u000d\u000aselect job,\u000d\u000a ename,\u000d\u000a row_number()over(partition by job order by ename) rn\u000d\u000a from emp\u000d\u000a JOB ENAME RN\u000d\u000a --------- ---------- ----------\u000d\u000a ANALYST FORD 1\u000d\u000a ANALYST SCOTT 2\u000d\u000a CLERK ADAMS 1\u000d\u000a CLERK JAMES 2\u000d\u000a CLERK MILLER 3\u000d\u000a CLERK SMITH 4\u000d\u000a MANAGER BLAKE 1\u000d\u000a MANAGER CLARK 2\u000d\u000a MANAGER JONES 3\u000d\u000a PRESIDENT KING 1\u000d\u000a SALESMAN ALLEN 1\u000d\u000a SALESMAN MARTIN 2\u000d\u000a SALESMAN TURNER 3\u000d\u000a SALESMAN WARD 4\u000d\u000a12.2 Pivoting a Result Set into Multiple Rows | 373","Giving each ENAME a unique \u201crow number\u201d within a given job prevents any prob\u2010\u000d\u000alems that might otherwise result from two employees having the same name and job.\u000d\u000aThe goal here is to be able to group on row number (on RN) without dropping any\u000d\u000aemployees from the result set due to the use of MAX. This step is the most important\u000d\u000astep in solving the problem. Without this first step, the aggregation in the outer query\u000d\u000awill remove necessary rows. Consider what the result set would look like without\u000d\u000ausing ROW_NUMBER OVER, using the same technique as shown in the first recipe:\u000d\u000aselect max(case when job='CLERK'\u000d\u000a then ename else null end) as clerks,\u000d\u000a max(case when job='ANALYST'\u000d\u000a then ename else null end) as analysts,\u000d\u000a max(case when job='MANAGER'\u000d\u000a then ename else null end) as mgrs,\u000d\u000a max(case when job='PRESIDENT'\u000d\u000a then ename else null end) as prez,\u000d\u000a max(case when job='SALESMAN'\u000d\u000a then ename else null end) as sales\u000d\u000a from emp\u000d\u000aCLERKS ANALYSTS MGRS PREZ SALES\u000d\u000a---------- ---------- ---------- ---------- ----------\u000d\u000aSMITH SCOTT JONES KING WARD\u000d\u000aUnfortunately, only one row is returned for each JOB: the employee with the MAX\u000d\u000aENAME. When it comes time to pivot the result set, using MIN or MAX should serve\u000d\u000aas a means to remove NULLs from the result set, not restrict the ENAMEs returned.\u000d\u000aHow this works will be come clearer as you continue through the explanation.\u000d\u000aThe next step uses a CASE expression to organize the ENAMEs into their proper col\u2010\u000d\u000aumn (JOB):\u000d\u000aselect rn,\u000d\u000a case when job='CLERK'\u000d\u000a then ename else null end as clerks,\u000d\u000a case when job='ANALYST'\u000d\u000a then ename else null end as analysts,\u000d\u000a case when job='MANAGER'\u000d\u000a then ename else null end as mgrs,\u000d\u000a case when job='PRESIDENT'\u000d\u000a then ename else null end as prez,\u000d\u000a case when job='SALESMAN'\u000d\u000a then ename else null end as sales\u000d\u000a from (\u000d\u000aselect job,\u000d\u000a ename,\u000d\u000a row_number()over(partition by job order by ename) rn\u000d\u000a from emp\u000d\u000a ) x\u000d\u000a374 | Chapter 12: Reporting and Reshaping","RN CLERKS ANALYSTS MGRS PREZ SALES\u000d\u000a-- ---------- ---------- ---------- ---------- ----------\u000d\u000a 1 FORD\u000d\u000a 2 SCOTT\u000d\u000a 1 ADAMS\u000d\u000a 2 JAMES\u000d\u000a 3 MILLER\u000d\u000a 4 SMITH\u000d\u000a 1 BLAKE\u000d\u000a 2 CLARK\u000d\u000a 3 JONES\u000d\u000a 1 KING\u000d\u000a 1 ALLEN\u000d\u000a 2 MARTIN\u000d\u000a 3 TURNER\u000d\u000a 4 WARD\u000d\u000aAt this point, the rows are transposed into columns, and the last step is to remove the\u000d\u000aNULLs to make the result set more readable. To remove the NULLs, use the aggregate\u000d\u000afunction MAX and group by RN. (You can use the function MIN as well. The choice\u000d\u000ato use MAX is arbitrary, as you will only ever be aggregating one value per group.)\u000d\u000aThere is only one value for each RN/JOB/ENAME combination. Grouping by RN in\u000d\u000aconjunction with the CASE expressions embedded within the calls to MAX ensures\u000d\u000athat each call to MAX results in picking only one name from a group of otherwise\u000d\u000aNULL values:\u000d\u000aselect max(case when job='CLERK'\u000d\u000a then ename else null end) as clerks,\u000d\u000a max(case when job='ANALYST'\u000d\u000a then ename else null end) as analysts,\u000d\u000a max(case when job='MANAGER'\u000d\u000a then ename else null end) as mgrs,\u000d\u000a max(case when job='PRESIDENT'\u000d\u000a then ename else null end) as prez,\u000d\u000a max(case when job='SALESMAN'\u000d\u000a then ename else null end) as sales\u000d\u000a from (\u000d\u000aselect job,\u000d\u000a ename,\u000d\u000a row_number()over(partition by job order by ename) rn\u000d\u000a from emp\u000d\u000a ) x\u000d\u000agroup by rn\u000d\u000aCLERKS ANALYSTS MGRS PREZ SALES\u000d\u000a------ -------- ----- ---- ------\u000d\u000aMILLER FORD CLARK KING TURNER\u000d\u000aJAMES SCOTT BLAKE MARTIN\u000d\u000aADAMS JONES WARD\u000d\u000aSMITH ALLEN\u000d\u000a12.2 Pivoting a Result Set into Multiple Rows | 375","The technique of using ROW_NUMBER OVER to create unique combinations of\u000d\u000arows is extremely useful for formatting query results. Consider the following query\u000d\u000athat creates a sparse report showing employees by DEPTNO and JOB:\u000d\u000aselect deptno dno, job,\u000d\u000a max(case when deptno=10\u000d\u000a then ename else null end) as d10,\u000d\u000a max(case when deptno=20\u000d\u000a then ename else null end) as d20,\u000d\u000a max(case when deptno=30\u000d\u000a then ename else null end) as d30,\u000d\u000a max(case when job='CLERK'\u000d\u000a then ename else null end) as clerks,\u000d\u000a max(case when job='ANALYST'\u000d\u000a then ename else null end) as anals,\u000d\u000a max(case when job='MANAGER'\u000d\u000a then ename else null end) as mgrs,\u000d\u000a max(case when job='PRESIDENT'\u000d\u000a then ename else null end) as prez,\u000d\u000a max(case when job='SALESMAN'\u000d\u000a then ename else null end) as sales\u000d\u000a from (\u000d\u000aSelect deptno,\u000d\u000a job,\u000d\u000a ename,\u000d\u000a row_number()over(partition by job order by ename) rn_job,\u000d\u000a row_number()over(partition by job order by ename) rn_deptno\u000d\u000a from emp\u000d\u000a ) x\u000d\u000a group by deptno, job, rn_deptno, rn_job\u000d\u000a order by 1\u000d\u000aDNO JOB D10 D20 D30 CLERKS ANALS MGRS PREZ SALES\u000d\u000a--- --------- ------ ----- ------ ------ ----- ----- ---- ------\u000d\u000a 10 CLERK MILLER MILLER\u000d\u000a 10 MANAGER CLARK CLARK\u000d\u000a 10 PRESIDENT KING KING\u000d\u000a 20 ANALYST FORD FORD\u000d\u000a 20 ANALYST SCOTT SCOTT\u000d\u000a 20 CLERK ADAMS ADAMS\u000d\u000a 20 CLERK SMITH SMITH\u000d\u000a 20 MANAGER JONES JONES\u000d\u000a 30 CLERK JAMES JAMES\u000d\u000a 30 MANAGER BLAKE BLAKE\u000d\u000a 30 SALESMAN ALLEN ALLEN\u000d\u000a 30 SALESMAN MARTIN MARTIN\u000d\u000a 30 SALESMAN TURNER TURNER\u000d\u000a 30 SALESMAN WARD WARD\u000d\u000aBy simply modifying what you group by (hence the nonaggregate items in the previ\u2010\u000d\u000aous SELECT list), you can produce reports with different formats. It is worth the time\u000d\u000a376 | Chapter 12: Reporting and Reshaping","of changing things around to understand how these formats change based on what\u000d\u000ayou include in your GROUP BY clause.\u000d\u000a12.3 Reverse Pivoting a Result Set\u000d\u000aProblem\u000d\u000aYou want to transform columns to rows. Consider the following result set:\u000d\u000aDEPTNO_10 DEPTNO_20 DEPTNO_30\u000d\u000a---------- ---------- ----------\u000d\u000a 3 5 6\u000d\u000aYou would like to convert that to the following:\u000d\u000aDEPTNO COUNTS_BY_DEPT\u000d\u000a------ --------------\u000d\u000a 10 3\u000d\u000a 20 5\u000d\u000a 30 6\u000d\u000aSome readers may have noticed that the first listing is the output from the first recipe\u000d\u000ain this chapter. To make this output available for this recipe, we can store it in a view\u000d\u000awith the following query:\u000d\u000acreate view emp_cnts as\u000d\u000a(\u000d\u000aselect sum(case when deptno=10 then 1 else 0 end) as deptno_10,\u000d\u000a sum(case when deptno=20 then 1 else 0 end) as deptno_20,\u000d\u000a sum(case when deptno=30 then 1 else 0 end) as deptno_30\u000d\u000a from emp\u000d\u000a)\u000d\u000aIn the solution and discussion that follow, the queries will refer to the EMP_CNTS\u000d\u000aview created by the preceding query.\u000d\u000aSolution\u000d\u000aExamining the desired result set, it\u2019s easy to see that you can execute a simple\u000d\u000aCOUNT and GROUP BY on table EMP to produce the desired result. The object\u000d\u000ahere, though, is to imagine that the data is not stored as rows; perhaps the data is\u000d\u000adenormalized and aggregated values are stored as multiple columns.\u000d\u000aTo convert columns to rows, use a Cartesian product. You\u2019ll need to know in advance\u000d\u000ahow many columns you want to convert to rows because the table expression you use\u000d\u000ato create the Cartesian product must have a cardinality of at least the number of col\u2010\u000d\u000aumns you want to transpose.\u000d\u000a12.3 Reverse Pivoting a Result Set | 377","Rather than create a denormalized table of data, the solution for this recipe will use\u000d\u000athe solution from the first recipe of this chapter to create a \u201cwide\u201d result set. The full\u000d\u000asolution is as follows:\u000d\u000a 1 select dept.deptno,\u000d\u000a 2 case dept.deptno\u000d\u000a 3 when 10 then emp_cnts.deptno_10\u000d\u000a 4 when 20 then emp_cnts.deptno_20\u000d\u000a 5 when 30 then emp_cnts.deptno_30\u000d\u000a 6 end as counts_by_dept\u000d\u000a 7 from emp_cnts cross join\u000d\u000a 8 (select deptno from dept where deptno <= 30) dept\u000d\u000aDiscussion\u000d\u000aThe view EMP_CNTS represents the denormalized view, or \u201cwide\u201d result set that you\u000d\u000awant to convert to rows, and is shown here:\u000d\u000aDEPTNO_10 DEPTNO_20 DEPTNO_30\u000d\u000a--------- ---------- ----------\u000d\u000a 3 5 6\u000d\u000aBecause there are three columns, you will create three rows. Begin by creating a Car\u2010\u000d\u000atesian product between inline view EMP_CNTS and some table expression that has at\u000d\u000aleast three rows. The following code uses table DEPT to create the Cartesian product;\u000d\u000aDEPT has four rows:\u000d\u000aselect dept.deptno,\u000d\u000a emp_cnts.deptno_10,\u000d\u000a emp_cnts.deptno_20,\u000d\u000a emp_cnts.deptno_30\u000d\u000a from (\u000d\u000a Select sum(case when deptno=10 then 1 else 0 end) as deptno_10,\u000d\u000a sum(case when deptno=20 then 1 else 0 end) as deptno_20,\u000d\u000a sum(case when deptno=30 then 1 else 0 end) as deptno_30\u000d\u000a from emp\u000d\u000a ) emp_cnts,\u000d\u000a (select deptno from dept where deptno <= 30) dept\u000d\u000a DEPTNO DEPTNO_10 DEPTNO_20 DEPTNO_30\u000d\u000a ------ ---------- ---------- ---------\u000d\u000a 10 3 5 6\u000d\u000a 20 3 5 6\u000d\u000a 30 3 5 6\u000d\u000aThe Cartesian product enables you to return a row for each column in inline view\u000d\u000aEMP_CNTS. Since the final result set should have only the DEPTNO and the number\u000d\u000aof employees in said DEPTNO, use a CASE expression to transform the three col\u2010\u000d\u000aumns into one:\u000d\u000a378 | Chapter 12: Reporting and Reshaping"," select dept.deptno,\u000d\u000a case dept.deptno\u000d\u000a when 10 then emp_cnts.deptno_10\u000d\u000a when 20 then emp_cnts.deptno_20\u000d\u000a when 30 then emp_cnts.deptno_30\u000d\u000a end as counts_by_dept\u000d\u000a from (\u000d\u000a emp_cnts\u000d\u000across join (select deptno from dept where deptno <= 30) dept\u000d\u000a DEPTNO COUNTS_BY_DEPT\u000d\u000a ------ --------------\u000d\u000a 10 3\u000d\u000a 20 5\u000d\u000a 30 6\u000d\u000a12.4 Reverse Pivoting a Result Set into One Column\u000d\u000aProblem\u000d\u000aYou want to return all columns from a query as just one column. For example, you\u000d\u000awant to return the ENAME, JOB, and SAL of all employees in DEPTNO 10, and you\u000d\u000awant to return all three values in one column. You want to return three rows for each\u000d\u000aemployee and one row of white space between employees. You want to return the fol\u2010\u000d\u000alowing result set:\u000d\u000aEMPS\u000d\u000a----------\u000d\u000aCLARK\u000d\u000aMANAGER\u000d\u000a2450\u000d\u000aKING\u000d\u000aPRESIDENT\u000d\u000a5000\u000d\u000aMILLER\u000d\u000aCLERK\u000d\u000a1300\u000d\u000aSolution\u000d\u000aThe key is to use a recursive CTE combined with Cartesian product to return four\u000d\u000arows for each employee. Chapter 10 covers the recursive CTE we need, and it\u2019s\u000d\u000aexplored further in Appendix B. Using the Cartesian join lets you return one column\u000d\u000avalue per row and have an extra row for spacing between employees.\u000d\u000a12.4 Reverse Pivoting a Result Set into One Column | 379","Use the window function ROW_NUMBER OVER to rank each row based on\u000d\u000aEMPNO (1\u20134). Then use a CASE expression to transform three columns into one\u000d\u000a(the keyword RECURSIVE is needed after the first WITH in PostgreSQL and\u000d\u000aMySQL):\u000d\u000a1 with four_rows (id)\u000d\u000a2 as\u000d\u000a3 (\u000d\u000a4 select 1\u000d\u000a5 union all\u000d\u000a6 select id+1\u000d\u000a7 from four_rows\u000d\u000a8 where id < 4\u000d\u000a9 )\u000d\u000a10 ,\u000d\u000a11 x_tab (ename,job,sal,rn )\u000d\u000a12 as\u000d\u000a13 (\u000d\u000a select e.ename,e.job,e.sal,\u000d\u000a14 row_number()over(partition by e.empno\u000d\u000a15 order by e.empno)\u000d\u000a16 from emp e\u000d\u000a17 join four_rows on 1=1\u000d\u000a18 )\u000d\u000a19\u000d\u000a20 select\u000d\u000a21 case rn\u000d\u000a22 when 1 then ename\u000d\u000a23 when 2 then job\u000d\u000a24 when 3 then cast(sal as char(4))\u000d\u000a25 end emps\u000d\u000a26 from x_tab\u000d\u000aDiscussion\u000d\u000aThe first step is to use the window function ROW_NUMBER OVER to create a rank\u2010\u000d\u000aing for each employee in DEPTNO 10:\u000d\u000aselect e.ename,e.job,e.sal,\u000d\u000a row_number()over(partition by e.empno\u000d\u000a order by e.empno) rn\u000d\u000afrom emp e\u000d\u000a where e.deptno=10\u000d\u000aENAME JOB SAL RN\u000d\u000a---------- --------- ---------- ----------\u000d\u000aCLARK MANAGER 2450 1\u000d\u000aKING PRESIDENT 5000 1\u000d\u000aMILLER CLERK 1300 1\u000d\u000a380 | Chapter 12: Reporting and Reshaping","At this point, the ranking doesn\u2019t mean much. You are partitioning by EMPNO, so\u000d\u000athe rank is 1 for all three rows in DEPTNO 10. Once you add the Cartesian product,\u000d\u000athe rank will begin to take shape, as shown in the following results:\u000d\u000awith four_rows (id)\u000d\u000a as\u000d\u000a (select 1\u000d\u000a union all\u000d\u000a select id+1\u000d\u000a from four_rows\u000d\u000a where id < 4\u000d\u000a )\u000d\u000a select e.ename,e.job,e.sal,\u000d\u000a row_number()over(partition by e.empno\u000d\u000a order by e.empno)\u000d\u000a from emp e\u000d\u000a join four_rows on 1=1\u000d\u000a ENAME JOB SAL RN\u000d\u000a ---------- --------- ---------- ----------\u000d\u000a CLARK MANAGER 2450 1\u000d\u000a CLARK MANAGER 2450 2\u000d\u000a CLARK MANAGER 2450 3\u000d\u000a CLARK MANAGER 2450 4\u000d\u000a KING PRESIDENT 5000 1\u000d\u000a KING PRESIDENT 5000 2\u000d\u000a KING PRESIDENT 5000 3\u000d\u000a KING PRESIDENT 5000 4\u000d\u000a MILLER CLERK 1300 1\u000d\u000a MILLER CLERK 1300 2\u000d\u000a MILLER CLERK 1300 3\u000d\u000a MILLER CLERK 1300 4\u000d\u000aYou should stop at this point and understand two key points:\u000d\u000a\u2022 RN is no longer 1 for each employee; it is now a repeating sequence of values\u000d\u000afrom 1 to 4, the reason being that window functions are applied after the FROM\u000d\u000aand WHERE clauses are evaluated. So, partitioning by EMPNO causes the RN to\u000d\u000areset to 1 when a new employee is encountered.\u000d\u000a\u2022 We\u2019ve used a recursive CTE to ensure that for each employee there are four rows.\u000d\u000aWe don\u2019t need the RECURSIVE keyword in SQL Server or DB2, but we do for\u000d\u000aOracle, MySQL, and PostgreSQL.\u000d\u000aThe hard work is now done, and all that is left is to use a CASE expression to put\u000d\u000aENAME, JOB, and SAL into one column for each employee (you need to use CAST\u000d\u000ato convert SAL to a string to keep CASE happy):\u000d\u000a with four_rows (id)\u000d\u000a as\u000d\u000a (select 1\u000d\u000a12.4 Reverse Pivoting a Result Set into One Column | 381"," union all\u000d\u000a select id+1\u000d\u000a from four_rows\u000d\u000a where id < 4\u000d\u000a )\u000d\u000a ,\u000d\u000a x_tab (ename,job,sal,rn )\u000d\u000a as\u000d\u000a (select e.ename,e.job,e.sal,\u000d\u000a row_number()over(partition by e.empno\u000d\u000a order by e.empno)\u000d\u000a from emp e\u000d\u000a join four_rows on 1=1)\u000d\u000a select case rn\u000d\u000a when 1 then ename\u000d\u000a when 2 then job\u000d\u000a when 3 then cast(sal as char(4))\u000d\u000a end emps\u000d\u000a from x_tab\u000d\u000a EMPS\u000d\u000a ----------\u000d\u000a CLARK\u000d\u000a MANAGER\u000d\u000a 2450\u000d\u000a KING\u000d\u000a PRESIDENT\u000d\u000a 5000\u000d\u000a MILLER\u000d\u000a CLERK\u000d\u000a 1300\u000d\u000a12.5 Suppressing Repeating Values from a Result Set\u000d\u000aProblem\u000d\u000aYou are generating a report, and when two rows have the same value in a column,\u000d\u000ayou want to display that value only once. For example, you want to return DEPTNO\u000d\u000aand ENAME from table EMP, you want to group all rows for each DEPTNO, and you\u000d\u000awant to display each DEPTNO only one time. You want to return the following result\u000d\u000aset:\u000d\u000aDEPTNO ENAME\u000d\u000a------ ---------\u000d\u000a 10 CLARK\u000d\u000a KING\u000d\u000a MILLER\u000d\u000a382 | Chapter 12: Reporting and Reshaping"," 20 SMITH\u000d\u000a ADAMS\u000d\u000a FORD\u000d\u000a SCOTT\u000d\u000a JONES\u000d\u000a 30 ALLEN\u000d\u000a BLAKE\u000d\u000a MARTIN\u000d\u000a JAMES\u000d\u000a TURNER\u000d\u000a WARD\u000d\u000aSolution\u000d\u000aThis is a simple formatting problem that is easily solved by the window function LAG\u000d\u000aOVER:\u000d\u000a1 select\u000d\u000a2 case when\u000d\u000a3 lag(deptno)over(order by deptno) = deptno then null\u000d\u000a4 else deptno end DEPTNO\u000d\u000a5 , ename\u000d\u000a6 from emp\u000d\u000aOracle users can also use DECODE as an alternative to CASE:\u000d\u000a1 select to_number(\u000d\u000a2 decode(lag(deptno)over(order by deptno),\u000d\u000a3 deptno,null,deptno)\u000d\u000a4 ) deptno, ename\u000d\u000a5 from emp\u000d\u000aDiscussion\u000d\u000aThe first step is to use the window function LAG OVER to return the prior DEPTNO\u000d\u000afor each row:\u000d\u000aselect lag(deptno)over(order by deptno) lag_deptno,\u000d\u000a deptno,\u000d\u000a ename\u000d\u000a from emp\u000d\u000aLAG_DEPTNO DEPTNO ENAME\u000d\u000a---------- ---------- ----------\u000d\u000a 10 CLARK\u000d\u000a 10 10 KING\u000d\u000a 10 10 MILLER\u000d\u000a 10 20 SMITH\u000d\u000a 20 20 ADAMS\u000d\u000a 20 20 FORD\u000d\u000a 20 20 SCOTT\u000d\u000a 20 20 JONES\u000d\u000a12.5 Suppressing Repeating Values from a Result Set | 383"," 20 30 ALLEN\u000d\u000a 30 30 BLAKE\u000d\u000a 30 30 MARTIN\u000d\u000a 30 30 JAMES\u000d\u000a 30 30 TURNER\u000d\u000a 30 30 WARD\u000d\u000aIf you inspect the previous result set, you can easily see where DEPTNO matches\u000d\u000aLAG_ DEPTNO. For those rows, you want to set DEPTNO to NULL. Do that by\u000d\u000ausing DECODE (TO_NUMBER is included to cast DEPTNO as a number):\u000d\u000aselect to_number(\u000d\u000a CASE WHEN (lag(deptno)over(order by deptno)\u000d\u000a= deptno THEN null else deptno END deptno ,\u000d\u000a deptno,null,deptno)\u000d\u000a ) deptno, ename\u000d\u000a from emp\u000d\u000aDEPTNO ENAME\u000d\u000a------ ----------\u000d\u000a 10 CLARK\u000d\u000a KING\u000d\u000a MILLER\u000d\u000a 20 SMITH\u000d\u000a ADAMS\u000d\u000a FORD\u000d\u000a SCOTT\u000d\u000a JONES\u000d\u000a 30 ALLEN\u000d\u000a BLAKE\u000d\u000a MARTIN\u000d\u000a JAMES\u000d\u000a TURNER\u000d\u000a WARD\u000d\u000a12.6 Pivoting a Result Set to Facilitate Inter-Row\u000d\u000aCalculations\u000d\u000aProblem\u000d\u000aYou want to make calculations involving data from multiple rows. To make your job\u000d\u000aeasier, you want to pivot those rows into columns such that all values you need are\u000d\u000athen in a single row.\u000d\u000aIn this book\u2019s example data, DEPTNO 20 is the department with the highest com\u2010\u000d\u000abined salary, which you can confirm by executing the following query:\u000d\u000aselect deptno, sum(sal) as sal\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000a384 | Chapter 12: Reporting and Reshaping","DEPTNO SAL\u000d\u000a------ ----------\u000d\u000a 10 8750\u000d\u000a 20 10875\u000d\u000a 30 9400\u000d\u000aYou want to calculate the difference between the salaries of DEPTNO 20 and\u000d\u000aDEPTNO 10 and between DEPTNO 20 and DEPTNO 30.\u000d\u000aThe final result will look like this:\u000d\u000ad20_10_diff d20_30_diff\u000d\u000a------------ ----------\u000d\u000a2125 1475\u000d\u000aSolution\u000d\u000aTranspose the totals using the aggregate function SUM and a CASE expression. Then\u000d\u000acode your expressions in the select list:\u000d\u000a1 select d20_sal - d10_sal as d20_10_diff,\u000d\u000a2 d20_sal - d30_sal as d20_30_diff\u000d\u000a3 from (\u000d\u000a4 select sum(case when deptno=10 then sal end) as d10_sal,\u000d\u000a5 sum(case when deptno=20 then sal end) as d20_sal,\u000d\u000a6 sum(case when deptno=30 then sal end) as d30_sal\u000d\u000a7 from emp\u000d\u000a8 ) totals_by_dept\u000d\u000aIt is also possible to write this query using a CTE, which some people may find more\u000d\u000areadable:\u000d\u000awith totals_by_dept (d10_sal, d20_sal, d30_sal)\u000d\u000aas\u000d\u000a(select\u000d\u000a sum(case when deptno=10 then sal end) as d10_sal,\u000d\u000a sum(case when deptno=20 then sal end) as d20_sal,\u000d\u000a sum(case when deptno=30 then sal end) as d30_sal\u000d\u000afrom emp)\u000d\u000aselect d20_sal - d10_sal as d20_10_diff,\u000d\u000a d20_sal - d30_sal as d20_30_diff\u000d\u000a from totals_by_dept\u000d\u000aDiscussion\u000d\u000aThe first step is to pivot the salaries for each DEPTNO from rows to columns by\u000d\u000ausing a CASE expression:\u000d\u000a12.6 Pivoting a Result Set to Facilitate Inter-Row Calculations | 385","select case when deptno=10 then sal end as d10_sal,\u000d\u000a case when deptno=20 then sal end as d20_sal,\u000d\u000a case when deptno=30 then sal end as d30_sal\u000d\u000a from emp\u000d\u000aD10_SAL D20_SAL D30_SAL\u000d\u000a------- ---------- ----------\u000d\u000a 800\u000d\u000a 1600\u000d\u000a 1250\u000d\u000a 2975\u000d\u000a 1250\u000d\u000a 2850\u000d\u000a 2450\u000d\u000a 3000\u000d\u000a 5000\u000d\u000a 1500\u000d\u000a 1100\u000d\u000a 950\u000d\u000a 3000\u000d\u000a 1300\u000d\u000aThe next step is to sum all the salaries for each DEPTNO by applying the aggregate\u000d\u000afunction SUM to each CASE expression:\u000d\u000aselect sum(case when deptno=10 then sal end) as d10_sal,\u000d\u000a sum(case when deptno=20 then sal end) as d20_sal,\u000d\u000a sum(case when deptno=30 then sal end) as d30_sal\u000d\u000a from emp\u000d\u000aD10_SAL D20_SAL D30_SAL\u000d\u000a------- ---------- ----------\u000d\u000a 8750 10875 9400\u000d\u000aThe final step is to simply wrap the previous SQL in an inline view and perform the\u000d\u000asubtractions.\u000d\u000a12.7 Creating Buckets of Data, of a Fixed Size\u000d\u000aProblem\u000d\u000aYou want to organize data into evenly sized buckets, with a predetermined number of\u000d\u000aelements in each bucket. The total number of buckets may be unknown, but you want\u000d\u000ato ensure that each bucket has five elements. For example, you want to organize the\u000d\u000aemployees in table EMP into groups of five based on the value of EMPNO, as shown\u000d\u000ain the following results:\u000d\u000aGRP EMPNO ENAME\u000d\u000a--- ---------- -------\u000d\u000a 1 7369 SMITH\u000d\u000a 1 7499 ALLEN\u000d\u000a386 | Chapter 12: Reporting and Reshaping"," 1 7521 WARD\u000d\u000a 1 7566 JONES\u000d\u000a 1 7654 MARTIN\u000d\u000a 2 7698 BLAKE\u000d\u000a 2 7782 CLARK\u000d\u000a 2 7788 SCOTT\u000d\u000a 2 7839 KING\u000d\u000a 2 7844 TURNER\u000d\u000a 3 7876 ADAMS\u000d\u000a 3 7900 JAMES\u000d\u000a 3 7902 FORD\u000d\u000a 3 7934 MILLER\u000d\u000aSolution\u000d\u000aThe solution to this problem is greatly simplified by functions for ranking rows. Once\u000d\u000athe rows are ranked, creating buckets of five is simply a matter of dividing and then\u000d\u000ataking the mathematical ceiling of the quotient.\u000d\u000aUse the window function ROW_NUMBER OVER to rank each employee by\u000d\u000aEMPNO. Then divide by five to create the groups (SQL Server users will use CEIL\u2010\u000d\u000aING, not CEIL):\u000d\u000a1 select ceil(row_number()over(order by empno)/5.0) grp,\u000d\u000a2 empno,\u000d\u000a3 ename\u000d\u000a4 from emp\u000d\u000aDiscussion\u000d\u000aThe window function ROW_NUMBER OVER assigns a rank or \u201crow number\u201d to\u000d\u000aeach row sorted by EMPNO:\u000d\u000aselect row_number()over(order by empno) rn,\u000d\u000a empno,\u000d\u000a ename\u000d\u000a from emp\u000d\u000aRN EMPNO ENAME\u000d\u000a-- ---------- ----------\u000d\u000a 1 7369 SMITH\u000d\u000a 2 7499 ALLEN\u000d\u000a 3 7521 WARD\u000d\u000a 4 7566 JONES\u000d\u000a 5 7654 MARTIN\u000d\u000a 6 7698 BLAKE\u000d\u000a 7 7782 CLARK\u000d\u000a 8 7788 SCOTT\u000d\u000a 9 7839 KING\u000d\u000a10 7844 TURNER\u000d\u000a11 7876 ADAMS\u000d\u000a12.7 Creating Buckets of Data, of a Fixed Size | 387","12 7900 JAMES\u000d\u000a13 7902 FORD\u000d\u000a14 7934 MILLER\u000d\u000aThe next step is to apply the function CEIL (or CEILING) after dividing ROW_\u000d\u000aNUMBER OVER by five. Dividing by five logically organizes the rows into groups of\u000d\u000afive (i.e., five values less than or equal to 1, five values greater than 1 but less than or\u000d\u000aequal to 2); the remaining group (composed of the last 4 rows since 14, the number of\u000d\u000arows in table EMP, is not a multiple of 5) has a value greater than 2 but less than or\u000d\u000aequal to 3.\u000d\u000aThe CEIL function will return the smallest whole number greater than the value\u000d\u000apassed to it; this will create whole number groups. The results of the division and\u000d\u000aapplication of the CEIL are shown here. You can follow the order of operation from\u000d\u000aleft to right, from RN to DIVISION to GRP:\u000d\u000aselect row_number()over(order by empno) rn,\u000d\u000a row_number()over(order by empno)/5.0 division,\u000d\u000a ceil(row_number()over(order by empno)/5.0) grp,\u000d\u000a empno,\u000d\u000a ename\u000d\u000a from emp\u000d\u000aRN DIVISION GRP EMPNO ENAME\u000d\u000a-- ---------- --- ----- ----------\u000d\u000a 1 .2 1 7369 SMITH\u000d\u000a 2 .4 1 7499 ALLEN\u000d\u000a 3 .6 1 7521 WARD\u000d\u000a 4 .8 1 7566 JONES\u000d\u000a 5 1 1 7654 MARTIN\u000d\u000a 6 1.2 2 7698 BLAKE\u000d\u000a 7 1.4 2 7782 CLARK\u000d\u000a 8 1.6 2 7788 SCOTT\u000d\u000a 9 1.8 2 7839 KING\u000d\u000a10 2 2 7844 TURNER\u000d\u000a11 2.2 3 7876 ADAMS\u000d\u000a12 2.4 3 7900 JAMES\u000d\u000a13 2.6 3 7902 FORD\u000d\u000a14 2.8 3 7934 MILLER\u000d\u000a12.8 Creating a Predefined Number of Buckets\u000d\u000aProblem\u000d\u000aYou want to organize your data into a fixed number of buckets. For example, you\u000d\u000awant to organize the employees in table EMP into four buckets. The result set should\u000d\u000alook similar to the following:\u000d\u000a388 | Chapter 12: Reporting and Reshaping","GRP EMPNO ENAME\u000d\u000a--- ----- ---------\u000d\u000a 1 7369 SMITH\u000d\u000a 1 7499 ALLEN\u000d\u000a 1 7521 WARD\u000d\u000a 1 7566 JONES\u000d\u000a 2 7654 MARTIN\u000d\u000a 2 7698 BLAKE\u000d\u000a 2 7782 CLARK\u000d\u000a 2 7788 SCOTT\u000d\u000a 3 7839 KING\u000d\u000a 3 7844 TURNER\u000d\u000a 3 7876 ADAMS\u000d\u000a 4 7900 JAMES\u000d\u000a 4 7902 FORD\u000d\u000a 4 7934 MILLER\u000d\u000aThis is a common way to organize categorical data as dividing a set into a number of\u000d\u000asmaller equal sized sets is an important first step for many kinds of analysis. For\u000d\u000aexample, taking the averages of these groups on salary or any other value may reveal a\u000d\u000atrend that is concealed by variability when looking at the cases individually.\u000d\u000aThis problem is the opposite of the previous recipe, where you had an unknown\u000d\u000anumber of buckets but a predetermined number of elements in each bucket. In this\u000d\u000arecipe, the goal is such that you may not necessarily know how many elements are in\u000d\u000aeach bucket, but you are defining a fixed (known) number of buckets to be created.\u000d\u000aSolution\u000d\u000aThe solution to this problem is simple now that the NTILE function is widely avail\u2010\u000d\u000aable. NTILE organizes an ordered set into the number of buckets you specify, with\u000d\u000aany stragglers distributed into the available buckets starting from the first bucket. The\u000d\u000adesired result set for this recipe reflects this: buckets 1 and 2 have four rows, while\u000d\u000abuckets 3 and 4 have three rows.\u000d\u000aUse the NTILE window function to create four buckets:\u000d\u000a1 select ntile(4)over(order by empno) grp,\u000d\u000a2 empno,\u000d\u000a3 ename\u000d\u000a4 from emp\u000d\u000aDiscussion\u000d\u000aAll the work is done by the NTILE function. The ORDER BY clause puts the rows\u000d\u000ainto the desired order, and the function itself then assigns a group number to each\u000d\u000arow, for example, so that the first quarter (in this case) are put into group one, the\u000d\u000asecond into group two, etc.\u000d\u000a12.8 Creating a Predefined Number of Buckets | 389","12.9 Creating Horizontal Histograms\u000d\u000aProblem\u000d\u000aYou want to use SQL to generate histograms that extend horizontally. For example,\u000d\u000ayou want to display the number of employees in each department as a horizontal his\u2010\u000d\u000atogram with each employee represented by an instance of *. You want to return the\u000d\u000afollowing result set:\u000d\u000aDEPTNO CNT\u000d\u000a------ ----------\u000d\u000a 10 ***\u000d\u000a 20 *****\u000d\u000a 30 ******\u000d\u000aSolution\u000d\u000aThe key to this solution is to use the aggregate function COUNT and use GROUP BY\u000d\u000aDEPTNO to determine the number of employees in each DEPTNO. The value\u000d\u000areturned by COUNT is then passed to a string function that generates a series of *\u000d\u000acharacters.\u000d\u000aDB2\u000d\u000aUse the REPEAT function to generate the histogram:\u000d\u000a1 select deptno,\u000d\u000a2 repeat('*',count(*)) cnt\u000d\u000a3 from emp\u000d\u000a4 group by deptno\u000d\u000aOracle, PostgreSQL, and MySQL\u000d\u000aUse the LPAD function to generate the needed strings of * characters:\u000d\u000a1 select deptno,\u000d\u000a2 lpad('*',count(*),'*') as cnt\u000d\u000a3 from emp\u000d\u000a4 group by deptno\u000d\u000aSQL Server\u000d\u000aGenerate the histogram using the REPLICATE function:\u000d\u000a1 select deptno,\u000d\u000a2 replicate('*',count(*)) cnt\u000d\u000a3 from emp\u000d\u000a4 group by deptno\u000d\u000a390 | Chapter 12: Reporting and Reshaping","Discussion\u000d\u000aThe technique is the same for all vendors. The only difference lies in the string func\u2010\u000d\u000ation used to return a * for each employee. The Oracle solution will be used for this\u000d\u000adiscussion, but the explanation is relevant for all the solutions.\u000d\u000aThe first step is to count the number of employees in each department:\u000d\u000aselect deptno,\u000d\u000a count(*)\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000aDEPTNO COUNT(*)\u000d\u000a------ ----------\u000d\u000a 10 3\u000d\u000a 20 5\u000d\u000a 30 6\u000d\u000aThe next step is to use the value returned by COUNT to control the number of *\u000d\u000acharacters to return for each department. Simply pass COUNT( * ) as an argument to\u000d\u000athe string function LPAD to return the desired number of *:\u000d\u000aselect deptno,\u000d\u000a lpad('*',count(*),'*') as cnt\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000aDEPTNO CNT\u000d\u000a------ ----------\u000d\u000a 10 ***\u000d\u000a 20 *****\u000d\u000a 30 ******\u000d\u000aFor PostgreSQL users, you may need to use CAST to ensure that COUNT(*) returns\u000d\u000aan integer as shown here:\u000d\u000aselect deptno,\u000d\u000a lpad('*',count(*)::integer,'*') as cnt\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000aDEPTNO CNT\u000d\u000a------ ----------\u000d\u000a 10 ***\u000d\u000a 20 *****\u000d\u000a 30 ******\u000d\u000aThis CAST is necessary because PostgreSQL requires the numeric argument to LPAD\u000d\u000ato be an integer.\u000d\u000a12.9 Creating Horizontal Histograms | 391","12.10 Creating Vertical Histograms\u000d\u000aProblem\u000d\u000aYou want to generate a histogram that grows from the bottom up. For example, you\u000d\u000awant to display the number of employees in each department as a vertical histogram\u000d\u000awith each employee represented by an instance of *. You want to return the following\u000d\u000aresult set:\u000d\u000aD10 D20 D30\u000d\u000a--- --- ---\u000d\u000a *\u000d\u000a * *\u000d\u000a * *\u000d\u000a* * *\u000d\u000a* * *\u000d\u000a* * *\u000d\u000aSolution\u000d\u000aThe technique used to solve this problem is built on a technique used earlier in this\u000d\u000achapter: use the ROW_NUMBER OVER function to uniquely identify each instance\u000d\u000aof * for each DEPTNO. Use the aggregate function MAX to pivot the result set and\u000d\u000agroup by the values returned by ROW_NUMBER OVER (SQL Server users should\u000d\u000anot use DESC in the ORDER BY clause):\u000d\u000a 1 select max(deptno_10) d10,\u000d\u000a 2 max(deptno_20) d20,\u000d\u000a 3 max(deptno_30) d30\u000d\u000a 4 from (\u000d\u000a 5 select row_number()over(partition by deptno order by empno) rn,\u000d\u000a 6 case when deptno=10 then '*' else null end deptno_10,\u000d\u000a 7 case when deptno=20 then '*' else null end deptno_20,\u000d\u000a 8 case when deptno=30 then '*' else null end deptno_30\u000d\u000a 9 from emp\u000d\u000a10 ) x\u000d\u000a11 group by rn\u000d\u000a12 order by 1 desc, 2 desc, 3 desc\u000d\u000aDiscussion\u000d\u000aThe first step is to use the window function ROW_NUMBER to uniquely identify\u000d\u000aeach instance of * in each department. Use a CASE expression to return a * for each\u000d\u000aemployee in each department:\u000d\u000a392 | Chapter 12: Reporting and Reshaping","select row_number()over(partition by deptno order by empno) rn,\u000d\u000a case when deptno=10 then '*' else null end deptno_10,\u000d\u000a case when deptno=20 then '*' else null end deptno_20,\u000d\u000a case when deptno=30 then '*' else null end deptno_30\u000d\u000a from emp\u000d\u000aRN DEPTNO_10 DEPTNO_20 DEPTNO_30\u000d\u000a-- ---------- ---------- ---------\u000d\u000a 1 *\u000d\u000a 2 *\u000d\u000a 3 *\u000d\u000a 1 *\u000d\u000a 2 *\u000d\u000a 3 *\u000d\u000a 4 *\u000d\u000a 5 *\u000d\u000a 1 *\u000d\u000a 2 *\u000d\u000a 3 *\u000d\u000a 4 *\u000d\u000a 5 *\u000d\u000a 6 *\u000d\u000aThe next and last step is to use the aggregate function MAX on each CASE expres\u2010\u000d\u000asion, grouping by RN to remove the NULLs from the result set. Order the results\u000d\u000aASC or DESC depending on how your RDBMS sorts NULLs:\u000d\u000aselect max(deptno_10) d10,\u000d\u000a max(deptno_20) d20,\u000d\u000a max(deptno_30) d30\u000d\u000a from (\u000d\u000aselect row_number()over(partition by deptno order by empno) rn,\u000d\u000a case when deptno=10 then '*' else null end deptno_10,\u000d\u000a case when deptno=20 then '*' else null end deptno_20,\u000d\u000a case when deptno=30 then '*' else null end deptno_30\u000d\u000a from emp\u000d\u000a ) x\u000d\u000a group by rn\u000d\u000a order by 1 desc, 2 desc, 3 desc\u000d\u000aD10 D20 D30\u000d\u000a--- --- ---\u000d\u000a *\u000d\u000a * *\u000d\u000a * *\u000d\u000a* * *\u000d\u000a* * *\u000d\u000a* * *\u000d\u000a12.10 Creating Vertical Histograms | 393","12.11 Returning Non-GROUP BY Columns\u000d\u000aProblem\u000d\u000aYou are executing a GROUP BY query, and you want to return columns in your select\u000d\u000alist that are not also listed in your GROUP BY clause. This is not normally possible,\u000d\u000aas such ungrouped columns would not represent a single value per row.\u000d\u000aSay that you want to find the employees who earn the highest and lowest salaries in\u000d\u000aeach department, as well as the employees who earn the highest and lowest salaries in\u000d\u000aeach job. You want to see each employee\u2019s name, the department he works in, his job\u000d\u000atitle, and his salary. You want to return the following result set:\u000d\u000aDEPTNO ENAME JOB SAL DEPT_STATUS JOB_STATUS\u000d\u000a------ ------ --------- ----- --------------- --------------\u000d\u000a 10 MILLER CLERK 1300 LOW SAL IN DEPT TOP SAL IN JOB\u000d\u000a 10 CLARK MANAGER 2450 LOW SAL IN JOB\u000d\u000a 10 KING PRESIDENT 5000 TOP SAL IN DEPT TOP SAL IN JOB\u000d\u000a 20 SCOTT ANALYST 3000 TOP SAL IN DEPT TOP SAL IN JOB\u000d\u000a 20 FORD ANALYST 3000 TOP SAL IN DEPT TOP SAL IN JOB\u000d\u000a 20 SMITH CLERK 800 LOW SAL IN DEPT LOW SAL IN JOB\u000d\u000a 20 JONES MANAGER 2975 TOP SAL IN JOB\u000d\u000a 30 JAMES CLERK 950 LOW SAL IN DEPT\u000d\u000a 30 MARTIN SALESMAN 1250 LOW SAL IN JOB\u000d\u000a 30 WARD SALESMAN 1250 LOW SAL IN JOB\u000d\u000a 30 ALLEN SALESMAN 1600 TOP SAL IN JOB\u000d\u000a 30 BLAKE MANAGER 2850 TOP SAL IN DEPT\u000d\u000aUnfortunately, including all these columns in the SELECT clause will ruin the group\u2010\u000d\u000aing. Consider the following example: employee KING earns the highest salary. You\u000d\u000awant to verify this with the following query:\u000d\u000aselect ename,max(sal)\u000d\u000a from empgroup by ename\u000d\u000aInstead of seeing KING and KING\u2019s salary, the previous query will return all 14 rows\u000d\u000afrom table EMP. The reason is because of the grouping: the MAX(SAL) is applied to\u000d\u000aeach ENAME. So, it would seem the previous query can be stated as \u201cfind the\u000d\u000aemployee with the highest salary,\u201d but in fact what it is doing is \u201cfind the highest sal\u2010\u000d\u000aary for each ENAME in table EMP.\u201d This recipe explains a technique for including\u000d\u000aENAME without the need to GROUP BY that column.\u000d\u000aSolution\u000d\u000aUse an inline view to find the high and low salaries by DEPTNO and JOB. Then keep\u000d\u000aonly the employees who make those salaries.\u000d\u000a394 | Chapter 12: Reporting and Reshaping","Use the window functions MAX OVER and MIN OVER to find the highest and low\u2010\u000d\u000aest salaries by DEPTNO and JOB. Then keep the rows where the salaries are those\u000d\u000athat are highest or lowest by DEPTNO or JOB:\u000d\u000a 1 select deptno,ename,job,sal,\u000d\u000a 2 case when sal = max_by_dept\u000d\u000a 3 then 'TOP SAL IN DEPT'\u000d\u000a 4 when sal = min_by_dept\u000d\u000a 5 then 'LOW SAL IN DEPT'\u000d\u000a 6 end dept_status,\u000d\u000a 7 case when sal = max_by_job\u000d\u000a 8 then 'TOP SAL IN JOB'\u000d\u000a 9 when sal = min_by_job\u000d\u000a10 then 'LOW SAL IN JOB'\u000d\u000a11 end job_status\u000d\u000a12 from (\u000d\u000a13 select deptno,ename,job,sal,\u000d\u000a14 max(sal)over(partition by deptno) max_by_dept,\u000d\u000a15 max(sal)over(partition by job) max_by_job,\u000d\u000a16 min(sal)over(partition by deptno) min_by_dept,\u000d\u000a17 min(sal)over(partition by job) min_by_job\u000d\u000a18 from emp\u000d\u000a19 ) emp_sals\u000d\u000a20 where sal in (max_by_dept,max_by_job,\u000d\u000a21 min_by_dept,min_by_job)\u000d\u000aDiscussion\u000d\u000aThe first step is to use the window functions MAX OVER and MIN OVER to find the\u000d\u000ahighest and lowest salaries by DEPTNO and JOB:\u000d\u000aselect deptno,ename,job,sal,\u000d\u000a max(sal)over(partition by deptno) maxDEPT,\u000d\u000a max(sal)over(partition by job) maxJOB,\u000d\u000a min(sal)over(partition by deptno) minDEPT,\u000d\u000a min(sal)over(partition by job) minJOB\u000d\u000a from emp\u000d\u000aDEPTNO ENAME JOB SAL MAXDEPT MAXJOB MINDEPT MINJOB\u000d\u000a------ ------ --------- ----- ------- ------ ------- ------\u000d\u000a 10 MILLER CLERK 1300 5000 1300 1300 800\u000d\u000a 10 CLARK MANAGER 2450 5000 2975 1300 2450\u000d\u000a 10 KING PRESIDENT 5000 5000 5000 1300 5000\u000d\u000a 20 SCOTT ANALYST 3000 3000 3000 800 3000\u000d\u000a 20 FORD ANALYST 3000 3000 3000 800 3000\u000d\u000a 20 SMITH CLERK 800 3000 1300 800 800\u000d\u000a 20 JONES MANAGER 2975 3000 2975 800 2450\u000d\u000a 20 ADAMS CLERK 1100 3000 1300 800 800\u000d\u000a 30 JAMES CLERK 950 2850 1300 950 800\u000d\u000a 30 MARTIN SALESMAN 1250 2850 1600 950 1250\u000d\u000a 30 TURNER SALESMAN 1500 2850 1600 950 1250\u000d\u000a 30 WARD SALESMAN 1250 2850 1600 950 1250\u000d\u000a12.11 Returning Non-GROUP BY Columns | 395"," 30 ALLEN SALESMAN 1600 2850 1600 950 1250\u000d\u000a 30 BLAKE MANAGER 2850 2850 2975 950 2450\u000d\u000aAt this point, every salary can be compared with the highest and lowest salaries by\u000d\u000aDEPTNO and JOB. Notice that the grouping (the inclusion of multiple columns in\u000d\u000athe SELECT clause) does not affect the values returned by MIN OVER and MAX\u000d\u000aOVER. This is the beauty of window functions: the aggregate is computed over a\u000d\u000adefined \u201cgroup\u201d or partition and returns multiple rows for each group. The last step is\u000d\u000ato simply wrap the window functions in an inline view and keep only those rows that\u000d\u000amatch the values returned by the window functions. Use a simple CASE expression to\u000d\u000adisplay the \u201cstatus\u201d of each employee in the final result set:\u000d\u000aselect deptno,ename,job,sal,\u000d\u000a case when sal = max_by_dept\u000d\u000a then 'TOP SAL IN DEPT'\u000d\u000a when sal = min_by_dept\u000d\u000a then 'LOW SAL IN DEPT'\u000d\u000a end dept_status,\u000d\u000a case when sal = max_by_job\u000d\u000a then 'TOP SAL IN JOB'\u000d\u000a when sal = min_by_job\u000d\u000a then 'LOW SAL IN JOB'\u000d\u000a end job_status\u000d\u000a from (\u000d\u000aselect deptno,ename,job,sal,\u000d\u000a max(sal)over(partition by deptno) max_by_dept,\u000d\u000a max(sal)over(partition by job) max_by_job,\u000d\u000a min(sal)over(partition by deptno) min_by_dept,\u000d\u000a min(sal)over(partition by job) min_by_job\u000d\u000a from emp\u000d\u000a ) x\u000d\u000a where sal in (max_by_dept,max_by_job,\u000d\u000a min_by_dept,min_by_job)\u000d\u000aDEPTNO ENAME JOB SAL DEPT_STATUS JOB_STATUS\u000d\u000a------ ------ --------- ----- --------------- --------------\u000d\u000a 10 MILLER CLERK 1300 LOW SAL IN DEPT TOP SAL IN JOB\u000d\u000a 10 CLARK MANAGER 2450 LOW SAL IN JOB\u000d\u000a 10 KING PRESIDENT 5000 TOP SAL IN DEPT TOP SAL IN JOB\u000d\u000a 20 SCOTT ANALYST 3000 TOP SAL IN DEPT TOP SAL IN JOB\u000d\u000a 20 FORD ANALYST 3000 TOP SAL IN DEPT TOP SAL IN JOB\u000d\u000a 20 SMITH CLERK 800 LOW SAL IN DEPT LOW SAL IN JOB\u000d\u000a 20 JONES MANAGER 2975 TOP SAL IN JOB\u000d\u000a 30 JAMES CLERK 950 LOW SAL IN DEPT\u000d\u000a 30 MARTIN SALESMAN 1250 LOW SAL IN JOB\u000d\u000a 30 WARD SALESMAN 1250 LOW SAL IN JOB\u000d\u000a 30 ALLEN SALESMAN 1600 TOP SAL IN JOB\u000d\u000a 30 BLAKE MANAGER 2850 TOP SAL IN DEPT\u000d\u000a396 | Chapter 12: Reporting and Reshaping","12.12 Calculating Simple Subtotals\u000d\u000aProblem\u000d\u000aFor the purposes of this recipe, a simple subtotal is defined as a result set that contains\u000d\u000avalues from the aggregation of one column along with a grand total value for the\u000d\u000atable. An example would be a result set that sums the salaries in table EMP by JOB\u000d\u000aand that also includes the sum of all salaries in table EMP. The summed salaries by\u000d\u000aJOB are the subtotals, and the sum of all salaries in table EMP is the grand total. Such\u000d\u000aa result set should look as follows:\u000d\u000aJOB SAL\u000d\u000a--------- ----------\u000d\u000aANALYST 6000\u000d\u000aCLERK 4150\u000d\u000aMANAGER 8275\u000d\u000aPRESIDENT 5000\u000d\u000aSALESMAN 5600\u000d\u000aTOTAL 29025\u000d\u000aSolution\u000d\u000aThe ROLLUP extension to the GROUP BY clause solves this problem perfectly. If\u000d\u000aROLLUP is not available for your RDBMS, you can solve the problem, albeit with\u000d\u000amore difficulty, using a scalar subquery or a UNION query.\u000d\u000aDB2 and Oracle\u000d\u000aUse the aggregate function SUM to sum the salaries, and use the ROLLUP extension\u000d\u000aof GROUP BY to organize the results into subtotals (by JOB) and a grand total (for\u000d\u000athe whole table):\u000d\u000a1 select case grouping(job)\u000d\u000a2 when 0 then job\u000d\u000a3 else 'TOTAL'\u000d\u000a4 end job,\u000d\u000a5 sum(sal) sal\u000d\u000a6 from emp\u000d\u000a7 group by rollup(job)\u000d\u000aSQL Server and MySQL\u000d\u000aUse the aggregate function SUM to sum the salaries, and use WITH ROLLUP to\u000d\u000aorganize the results into subtotals (by JOB) and a grand total (for the whole table).\u000d\u000aThen use COALESCE to supply the label TOTAL for the grand total row (which will\u000d\u000aotherwise have a NULL in the JOB column):\u000d\u000a12.12 Calculating Simple Subtotals | 397","1 select coalesce(job,'TOTAL') job,\u000d\u000a2 sum(sal) sal\u000d\u000a3 from emp\u000d\u000a4 group by job with rollup\u000d\u000aWith SQL Server, you also have the option to use the GROUPING function shown in\u000d\u000athe Oracle/DB2 recipe rather than COALESCE to determine the level of aggregation.\u000d\u000aPostgreSQL\u000d\u000aSimilar to the SQL Server and MySQL solutions, you use the ROLLUP extension to\u000d\u000aGROUP BY with slightly different syntax:\u000d\u000aselect coalesce(job,'TOTAL') job,\u000d\u000a sum(sal) sal\u000d\u000a from emp\u000d\u000a group by rollup(job)\u000d\u000aDiscussion\u000d\u000aDB2 and Oracle\u000d\u000aThe first step is to use the aggregate function SUM, grouping by JOB in order to sum\u000d\u000athe salaries by JOB:\u000d\u000aselect job, sum(sal) sal\u000d\u000a from emp\u000d\u000a group by job\u000d\u000aJOB SAL\u000d\u000a--------- -----\u000d\u000aANALYST 6000\u000d\u000aCLERK 4150\u000d\u000aMANAGER 8275\u000d\u000aPRESIDENT 5000\u000d\u000aSALESMAN 5600\u000d\u000aThe next step is to use the ROLLUP extension to GROUP BY to produce a grand\u000d\u000atotal for all salaries along with the subtotals for each JOB:\u000d\u000aselect job, sum(sal) sal\u000d\u000a from emp\u000d\u000a group by rollup(job)\u000d\u000aJOB SAL\u000d\u000a--------- -------\u000d\u000aANALYST 6000\u000d\u000aCLERK 4150\u000d\u000aMANAGER 8275\u000d\u000aPRESIDENT 5000\u000d\u000aSALESMAN 5600\u000d\u000a 29025\u000d\u000a398 | Chapter 12: Reporting and Reshaping","The last step is to use the GROUPING function in the JOB column to display a label\u000d\u000afor the grand total. If the value of JOB is NULL, the GROUPING function will return\u000d\u000a1, which signifies that the value for SAL is the grand total created by ROLLUP. If the\u000d\u000avalue of JOB is not NULL, the GROUPING function will return 0, which signifies the\u000d\u000avalue for SAL is the result of the GROUP BY, not the ROLLUP. Wrap the call to\u000d\u000aGROUPING(JOB) in a CASE expression that returns either the job name or the label\u000d\u000aTOTAL, as appropriate:\u000d\u000aselect case grouping(job)\u000d\u000a when 0 then job\u000d\u000a else 'TOTAL'\u000d\u000a end job,\u000d\u000a sum(sal) sal\u000d\u000a from emp\u000d\u000a group by rollup(job)\u000d\u000aJOB SAL\u000d\u000a--------- ----------\u000d\u000aANALYST 6000\u000d\u000aCLERK 4150\u000d\u000aMANAGER 8275\u000d\u000aPRESIDENT 5000\u000d\u000aSALESMAN 5600\u000d\u000aTOTAL 29025\u000d\u000aSQL Server and MySQL\u000d\u000aThe first step is to use the aggregate function SUM, grouping the results by JOB to\u000d\u000agenerate salary sums by JOB:\u000d\u000aselect job, sum(sal) sal\u000d\u000a from emp\u000d\u000a group by job\u000d\u000aJOB SAL\u000d\u000a--------- -----\u000d\u000aANALYST 6000\u000d\u000aCLERK 4150\u000d\u000aMANAGER 8275\u000d\u000aPRESIDENT 5000\u000d\u000aSALESMAN 5600\u000d\u000aThe next step is to use GROUP BY\u2019s ROLLUP extension to produce a grand total for\u000d\u000aall salaries along with the subtotals for each JOB:\u000d\u000aselect job, sum(sal) sal\u000d\u000a from emp\u000d\u000a group by job with rollup\u000d\u000a12.12 Calculating Simple Subtotals | 399","JOB SAL\u000d\u000a--------- -------\u000d\u000aANALYST 6000\u000d\u000aCLERK 4150\u000d\u000aMANAGER 8275\u000d\u000aPRESIDENT 5000\u000d\u000aSALESMAN 5600\u000d\u000a 29025\u000d\u000aThe last step is to use the COEALESCE function against the JOB column. If the value\u000d\u000aof JOB is NULL, the value for SAL is the grand total created by ROLLUP. If the value\u000d\u000aof JOB is not NULL, the value for SAL is the result of the \u201cregular\u201d GROUP BY, not\u000d\u000athe ROLLUP:\u000d\u000aselect coalesce(job,'TOTAL') job,\u000d\u000a sum(sal) sal\u000d\u000a from emp\u000d\u000a group by job with rollup\u000d\u000aJOB SAL\u000d\u000a--------- ----------\u000d\u000aANALYST 6000\u000d\u000aCLERK 4150\u000d\u000aMANAGER 8275\u000d\u000aPRESIDENT 5000\u000d\u000aSALESMAN 5600\u000d\u000aTOTAL 29025\u000d\u000aPostgreSQL\u000d\u000aThe solution is the same in its manner of operation as the preceeding solution for\u000d\u000aMySQL and SQL Server. The only difference is the syntax for the ROLLUP clause:\u000d\u000awrite ROLLUP(JOB) after GROUP BY.\u000d\u000a12.13 Calculating Subtotals for All Possible Expression\u000d\u000aCombinations\u000d\u000aProblem\u000d\u000aYou want to find the sum of all salaries by DEPTNO, and by JOB, for every JOB/\u000d\u000aDEPTNO combination. You also want a grand total for all salaries in table EMP. You\u000d\u000awant to return the following result set:\u000d\u000aDEPTNO JOB CATEGORY SAL\u000d\u000a------ --------- --------------------- -------\u000d\u000a 10 CLERK TOTAL BY DEPT AND JOB 1300\u000d\u000a 10 MANAGER TOTAL BY DEPT AND JOB 2450\u000d\u000a 10 PRESIDENT TOTAL BY DEPT AND JOB 5000\u000d\u000a 20 CLERK TOTAL BY DEPT AND JOB 1900\u000d\u000a400 | Chapter 12: Reporting and Reshaping"," 30 CLERK TOTAL BY DEPT AND JOB 950\u000d\u000a 30 SALESMAN TOTAL BY DEPT AND JOB 5600\u000d\u000a 30 MANAGER TOTAL BY DEPT AND JOB 2850\u000d\u000a 20 MANAGER TOTAL BY DEPT AND JOB 2975\u000d\u000a 20 ANALYST TOTAL BY DEPT AND JOB 6000\u000d\u000a CLERK TOTAL BY JOB 4150\u000d\u000a ANALYST TOTAL BY JOB 6000\u000d\u000a MANAGER TOTAL BY JOB 8275\u000d\u000a PRESIDENT TOTAL BY JOB 5000\u000d\u000a SALESMAN TOTAL BY JOB 5600\u000d\u000a 10 TOTAL BY DEPT 8750\u000d\u000a 30 TOTAL BY DEPT 9400\u000d\u000a 20 TOTAL BY DEPT 10875\u000d\u000a GRAND TOTAL FOR TABLE 29025\u000d\u000aSolution\u000d\u000aExtensions added to GROUP BY in recent years make this a fairly easy problem to\u000d\u000asolve. If your platform does not supply such extensions for computing various levels\u000d\u000aof subtotals, then you must compute them manually (via self-joins or scalar\u000d\u000asubqueries).\u000d\u000aDB2\u000d\u000aFor DB2, you will need to use CAST to return from GROUPING as the CHAR(1)\u000d\u000adata type:\u000d\u000a 1 select deptno,\u000d\u000a 2 job,\u000d\u000a 3 case cast(grouping(deptno) as char(1))||\u000d\u000a 4 cast(grouping(job) as char(1))\u000d\u000a 5 when '00' then 'TOTAL BY DEPT AND JOB'\u000d\u000a 6 when '10' then 'TOTAL BY JOB'\u000d\u000a 7 when '01' then 'TOTAL BY DEPT'\u000d\u000a 8 when '11' then 'TOTAL FOR TABLE'\u000d\u000a 9 end category,\u000d\u000a10 sum(sal)\u000d\u000a11 from emp\u000d\u000a12 group by cube(deptno,job)\u000d\u000a13 order by grouping(job),grouping(deptno)\u000d\u000aOracle\u000d\u000aUse the CUBE extension to the GROUP BY clause with the concatenation operator ||:\u000d\u000a 1 select deptno,\u000d\u000a 2 job,\u000d\u000a 3 case grouping(deptno)||grouping(job)\u000d\u000a 4 when '00' then 'TOTAL BY DEPT AND JOB'\u000d\u000a 5 when '10' then 'TOTAL BY JOB'\u000d\u000a 6 when '01' then 'TOTAL BY DEPT'\u000d\u000a12.13 Calculating Subtotals for All Possible Expression Combinations | 401"," 7 when '11' then 'GRAND TOTALFOR TABLE'\u000d\u000a 8 end category,\u000d\u000a 9 sum(sal) sal\u000d\u000a10 from emp\u000d\u000a11 group by cube(deptno,job)\u000d\u000a12 order by grouping(job),grouping(deptno)\u000d\u000aSQL Server\u000d\u000aUse the CUBE extension to the GROUP BY clause. For SQL Server, you will need to\u000d\u000aCAST the results from GROUPING to CHAR(1), and you will need to use the +\u000d\u000aoperator for concatenation (as opposed to Oracle\u2019s || operator):\u000d\u000a 1 select deptno,\u000d\u000a 2 job,\u000d\u000a 3 case cast(grouping(deptno)as char(1))+\u000d\u000a 4 cast(grouping(job)as char(1))\u000d\u000a 5 when '00' then 'TOTAL BY DEPT AND JOB'\u000d\u000a 6 when '10' then 'TOTAL BY JOB'\u000d\u000a 7 when '01' then 'TOTAL BY DEPT'\u000d\u000a 8 when '11' then 'GRAND TOTAL FOR TABLE'\u000d\u000a 9 end category,\u000d\u000a10 sum(sal) sal\u000d\u000a11 from emp\u000d\u000a12 group by deptno,job with cube\u000d\u000a13 order by grouping(job),grouping(deptno)\u000d\u000aPostgreSQL\u000d\u000aPostgreSQL is similar to the preceding, but with slightly different syntax for the\u000d\u000aCUBE operator and the concatenation:\u000d\u000aselect deptno,job\u000d\u000a,case concat(\u000d\u000acast (grouping(deptno) as char(1)),cast (grouping(job) as char(1))\u000d\u000a )\u000d\u000a when '00' then 'TOTAL BY DEPT AND JOB'\u000d\u000a when '10' then 'TOTAL BY JOB'\u000d\u000a when '01' then 'TOTAL BY DEPT'\u000d\u000a when '11' then 'GRAND TOTAL FOR TABLE'\u000d\u000a end category\u000d\u000a , sum(sal) as sal\u000d\u000a from emp\u000d\u000a group by cube(deptno,job)\u000d\u000aMySQL\u000d\u000aAlthough part of the functionality is available, it is not complete, as MySQL has no\u000d\u000aCUBE function. Hence, use multiple UNION ALLs, creating different sums for each:\u000d\u000a402 | Chapter 12: Reporting and Reshaping"," 1 select deptno, job,\u000d\u000a 2 'TOTAL BY DEPT AND JOB' as category,\u000d\u000a 3 sum(sal) as sal\u000d\u000a 4 from emp\u000d\u000a 5 group by deptno, job\u000d\u000a 6 union all\u000d\u000a 7 select null, job, 'TOTAL BY JOB', sum(sal)\u000d\u000a 8 from emp\u000d\u000a 9 group by job\u000d\u000a10 union all\u000d\u000a11 select deptno, null, 'TOTAL BY DEPT', sum(sal)\u000d\u000a12 from emp\u000d\u000a13 group by deptno\u000d\u000a14 union all\u000d\u000a15 select null,null,'GRAND TOTAL FOR TABLE', sum(sal)\u000d\u000a16 from emp\u000d\u000aDiscussion\u000d\u000aOracle, DB2, and SQL Server\u000d\u000aThe solutions for all three are essentially the same. The first step is to use the aggre\u2010\u000d\u000agate function SUM and group by both DEPTNO and JOB to find the total salaries for\u000d\u000aeach JOB and DEPTNO combination:\u000d\u000aselect deptno, job, sum(sal) sal\u000d\u000a from emp\u000d\u000a group by deptno, job\u000d\u000aDEPTNO JOB SAL\u000d\u000a------ --------- -------\u000d\u000a 10 CLERK 1300\u000d\u000a 10 MANAGER 2450\u000d\u000a 10 PRESIDENT 5000\u000d\u000a 20 CLERK 1900\u000d\u000a 20 ANALYST 6000\u000d\u000a 20 MANAGER 2975\u000d\u000a 30 CLERK 950\u000d\u000a 30 MANAGER 2850\u000d\u000a 30 SALESMAN 5600\u000d\u000aThe next step is to create subtotals by JOB and DEPTNO along with the grand total\u000d\u000afor the whole table. Use the CUBE extension to the GROUP BY clause to perform\u000d\u000aaggregations on SAL by DEPTNO, JOB, and for the whole table:\u000d\u000aselect deptno,\u000d\u000a job,\u000d\u000a sum(sal) sal\u000d\u000a from emp\u000d\u000a group by cube(deptno,job)\u000d\u000a12.13 Calculating Subtotals for All Possible Expression Combinations | 403","DEPTNO JOB SAL\u000d\u000a------ --------- -------\u000d\u000a 29025\u000d\u000a CLERK 4150\u000d\u000a ANALYST 6000\u000d\u000a MANAGER 8275\u000d\u000a SALESMAN 5600\u000d\u000a PRESIDENT 5000\u000d\u000a 10 8750\u000d\u000a 10 CLERK 1300\u000d\u000a 10 MANAGER 2450\u000d\u000a 10 PRESIDENT 5000\u000d\u000a 20 10875\u000d\u000a 20 CLERK 1900\u000d\u000a 20 ANALYST 6000\u000d\u000a 20 MANAGER 2975\u000d\u000a 30 9400\u000d\u000a 30 CLERK 950\u000d\u000a 30 MANAGER 2850\u000d\u000a 30 SALESMAN 5600\u000d\u000aNext, use the GROUPING function in conjunction with CASE to format the results\u000d\u000ainto more meaningful output. The value from GROUPING(JOB) will be 1 or 0\u000d\u000adepending on whether the values for SAL are due to the GROUP BY or the CUBE. If\u000d\u000athe results are due to the CUBE, the value will be 1; otherwise, it will be 0. The same\u000d\u000agoes for GROUPING(DEPTNO). Looking at the first step of the solution, you should\u000d\u000asee that grouping is done by DEPTNO and JOB. Thus, the expected values from the\u000d\u000acalls to GROUPING when a row represents a combination of both DEPTNO and\u000d\u000aJOB is 0. The following query confirms this:\u000d\u000aselect deptno,\u000d\u000a job,\u000d\u000a grouping(deptno) is_deptno_subtotal,\u000d\u000a grouping(job) is_job_subtotal,\u000d\u000a sum(sal) sal\u000d\u000a from emp\u000d\u000a group by cube(deptno,job)\u000d\u000a order by 3,4\u000d\u000aDEPTNO JOB IS_DEPTNO_SUBTOTAL IS_JOB_SUBTOTAL SAL\u000d\u000a------ --------- ------------------ --------------- -------\u000d\u000a 10 CLERK 0 0 1300\u000d\u000a 10 MANAGER 0 0 2450\u000d\u000a 10 PRESIDENT 0 0 5000\u000d\u000a 20 CLERK 0 0 1900\u000d\u000a 30 CLERK 0 0 950\u000d\u000a 30 SALESMAN 0 0 5600\u000d\u000a 30 MANAGER 0 0 2850\u000d\u000a 20 MANAGER 0 0 2975\u000d\u000a 20 ANALYST 0 0 6000\u000d\u000a 10 0 1 8750\u000d\u000a404 | Chapter 12: Reporting and Reshaping"," 20 0 1 10875\u000d\u000a 30 0 1 9400\u000d\u000a CLERK 1 0 4150\u000d\u000a ANALYST 1 0 6000\u000d\u000a MANAGER 1 0 8275\u000d\u000a PRESIDENT 1 0 5000\u000d\u000a SALESMAN 1 0 5600\u000d\u000a 1 1 29025\u000d\u000aThe final step is to use a CASE expression to determine which category each row\u000d\u000abelongs to based on the values returned by GROUPING(JOB) and GROUP\u2010\u000d\u000aING(DEPTNO) concatenated:\u000d\u000aselect deptno,\u000d\u000a job,\u000d\u000a case grouping(deptno)||grouping(job)\u000d\u000a when '00' then 'TOTAL BY DEPT AND JOB'\u000d\u000a when '10' then 'TOTAL BY JOB'\u000d\u000a when '01' then 'TOTAL BY DEPT'\u000d\u000a when '11' then 'GRAND TOTAL FOR TABLE'\u000d\u000a end category,\u000d\u000a sum(sal) sal\u000d\u000a from emp\u000d\u000a group by cube(deptno,job)\u000d\u000a order by grouping(job),grouping(deptno)\u000d\u000aDEPTNO JOB CATEGORY SAL\u000d\u000a------ --------- --------------------- -------\u000d\u000a 10 CLERK TOTAL BY DEPT AND JOB 1300\u000d\u000a 10 MANAGER TOTAL BY DEPT AND JOB 2450\u000d\u000a 10 PRESIDENT TOTAL BY DEPT AND JOB 5000\u000d\u000a 20 CLERK TOTAL BY DEPT AND JOB 1900\u000d\u000a 30 CLERK TOTAL BY DEPT AND JOB 950\u000d\u000a 30 SALESMAN TOTAL BY DEPT AND JOB 5600\u000d\u000a 30 MANAGER TOTAL BY DEPT AND JOB 2850\u000d\u000a 20 MANAGER TOTAL BY DEPT AND JOB 2975\u000d\u000a 20 ANALYST TOTAL BY DEPT AND JOB 6000\u000d\u000a CLERK TOTAL BY JOB 4150\u000d\u000a ANALYST TOTAL BY JOB 6000\u000d\u000a MANAGER TOTAL BY JOB 8275\u000d\u000a PRESIDENT TOTAL BY JOB 5000\u000d\u000a SALESMAN TOTAL BY JOB 5600\u000d\u000a 10 TOTAL BY DEPT 8750\u000d\u000a 30 TOTAL BY DEPT 9400\u000d\u000a 20 TOTAL BY DEPT 10875\u000d\u000a GRAND TOTAL FOR TABLE 29025\u000d\u000aThis Oracle solution implicitly converts the results from the GROUPING functions\u000d\u000ato a character type in preparation for concatenating the two values. DB2 and SQL\u000d\u000aServer users will need to explicitly CAST the results of the GROUPING functions to\u000d\u000aCHAR(1), as shown in the solution. In addition, SQL Server users must use the +\u000d\u000a12.13 Calculating Subtotals for All Possible Expression Combinations | 405","operator, and not the || operator, to concatenate the results from the two GROUPING\u000d\u000acalls into one string.\u000d\u000aFor Oracle and DB2 users, there is an additional extension to GROUP BY called\u000d\u000aGROUPING SETS; this extension is extremely useful. For example, you can use\u000d\u000aGROUPING SETS to mimic the output created by CUBE as is shown here (DB2 and\u000d\u000aSQL Server users will need to use CAST to ensure the values returned by the\u000d\u000aGROUPING function are in the correct format in the same way as in the CUBE\u000d\u000asolution):\u000d\u000aselect deptno,\u000d\u000a job,\u000d\u000a case grouping(deptno)||grouping(job)\u000d\u000a when '00' then 'TOTAL BY DEPT AND JOB'\u000d\u000a when '10' then 'TOTAL BY JOB'\u000d\u000a when '01' then 'TOTAL BY DEPT'\u000d\u000a when '11' then 'GRAND TOTAL FOR TABLE'\u000d\u000a end category,\u000d\u000a sum(sal) sal\u000d\u000a from emp\u000d\u000a group by grouping sets ((deptno),(job),(deptno,job),())\u000d\u000aDEPTNO JOB CATEGORY SAL\u000d\u000a------ --------- --------------------- -------\u000d\u000a 10 CLERK TOTAL BY DEPT AND JOB 1300\u000d\u000a 20 CLERK TOTAL BY DEPT AND JOB 1900\u000d\u000a 30 CLERK TOTAL BY DEPT AND JOB 950\u000d\u000a 20 ANALYST TOTAL BY DEPT AND JOB 6000\u000d\u000a 10 MANAGER TOTAL BY DEPT AND JOB 2450\u000d\u000a 20 MANAGER TOTAL BY DEPT AND JOB 2975\u000d\u000a 30 MANAGER TOTAL BY DEPT AND JOB 2850\u000d\u000a 30 SALESMAN TOTAL BY DEPT AND JOB 5600\u000d\u000a 10 PRESIDENT TOTAL BY DEPT AND JOB 5000\u000d\u000a CLERK TOTAL BY JOB 4150\u000d\u000a ANALYST TOTAL BY JOB 6000\u000d\u000a MANAGER TOTAL BY JOB 8275\u000d\u000a SALESMAN TOTAL BY JOB 5600\u000d\u000a PRESIDENT TOTAL BY JOB 5000\u000d\u000a 10 TOTAL BY DEPT 8750\u000d\u000a 20 TOTAL BY DEPT 10875\u000d\u000a 30 TOTAL BY DEPT 9400\u000d\u000a GRAND TOTAL FOR TABLE 29025\u000d\u000aWhat\u2019s great about GROUPING SETS is that it allows you to define the groups. The\u000d\u000aGROUPING SETS clause in the preceding query causes groups to be created by\u000d\u000aDEPTNO, by JOB, and by the combination of DEPTNO and JOB, and finally the\u000d\u000aempty parentheses requests a grand total. GROUPING SETS gives you enormous\u000d\u000aflexibility for creating reports with different levels of aggregation; for example, if you\u000d\u000awanted to modify the preceding example to exclude the GRAND TOTAL, simply\u000d\u000amodify the GROUPING SETS clause by excluding the empty parentheses:\u000d\u000a406 | Chapter 12: Reporting and Reshaping","/* no grand total */\u000d\u000aselect deptno,\u000d\u000a job,\u000d\u000a case grouping(deptno)||grouping(job)\u000d\u000a when '00' then 'TOTAL BY DEPT AND JOB'\u000d\u000a when '10' then 'TOTAL BY JOB'\u000d\u000a when '01' then 'TOTAL BY DEPT'\u000d\u000a when '11' then 'GRAND TOTAL FOR TABLE'\u000d\u000a end category,\u000d\u000a sum(sal) sal\u000d\u000a from emp\u000d\u000a group by grouping sets ((deptno),(job),(deptno,job))\u000d\u000aDEPTNO JOB CATEGORY SAL\u000d\u000a------ --------- --------------------- ----------\u000d\u000a 10 CLERK TOTAL BY DEPT AND JOB 1300\u000d\u000a 20 CLERK TOTAL BY DEPT AND JOB 1900\u000d\u000a 30 CLERK TOTAL BY DEPT AND JOB 950\u000d\u000a 20 ANALYST TOTAL BY DEPT AND JOB 6000\u000d\u000a 10 MANAGER TOTAL BY DEPT AND JOB 2450\u000d\u000a 20 MANAGER TOTAL BY DEPT AND JOB 2975\u000d\u000a 30 MANAGER TOTAL BY DEPT AND JOB 2850\u000d\u000a 30 SALESMAN TOTAL BY DEPT AND JOB 5600\u000d\u000a 10 PRESIDENT TOTAL BY DEPT AND JOB 5000\u000d\u000a CLERK TOTAL BY JOB 4150\u000d\u000a ANALYST TOTAL BY JOB 6000\u000d\u000a MANAGER TOTAL BY JOB 8275\u000d\u000a SALESMAN TOTAL BY JOB 5600\u000d\u000a PRESIDENT TOTAL BY JOB 5000\u000d\u000a 10 TOTAL BY DEPT 8750\u000d\u000a 20 TOTAL BY DEPT 10875\u000d\u000a 30 TOTAL BY DEPT 9400\u000d\u000aYou can also eliminate a subtotal, such as the one on DEPTNO, simply by omitting\u000d\u000a(DEPTNO) from the GROUPING SETS clause:\u000d\u000a/* nosubtotals by DEPTNO */\u000d\u000aselect deptno,\u000d\u000a job,\u000d\u000a case grouping(deptno)||grouping(job)\u000d\u000a when '00' then 'TOTAL BY DEPT AND JOB'\u000d\u000a when '10' then 'TOTAL BY JOB'\u000d\u000a when '01' then 'TOTAL BY DEPT'\u000d\u000a when '11' then 'GRAND TOTAL FOR TABLE'\u000d\u000a end category,\u000d\u000a sum(sal) sal\u000d\u000a from emp\u000d\u000a group by grouping sets ((job),(deptno,job),())\u000d\u000a order by 3\u000d\u000a12.13 Calculating Subtotals for All Possible Expression Combinations | 407","DEPTNO JOB CATEGORY SAL\u000d\u000a------ --------- --------------------- ----------\u000d\u000a GRAND TOTAL FOR TABLE 29025\u000d\u000a 10 CLERK TOTAL BY DEPT AND JOB 1300\u000d\u000a 20 CLERK TOTAL BY DEPT AND JOB 1900\u000d\u000a 30 CLERK TOTAL BY DEPT AND JOB 950\u000d\u000a 20 ANALYST TOTAL BY DEPT AND JOB 6000\u000d\u000a 20 MANAGER TOTAL BY DEPT AND JOB 2975\u000d\u000a 30 MANAGER TOTAL BY DEPT AND JOB 2850\u000d\u000a 30 SALESMAN TOTAL BY DEPT AND JOB 5600\u000d\u000a 10 PRESIDENT TOTAL BY DEPT AND JOB 5000\u000d\u000a 10 MANAGER TOTAL BY DEPT AND JOB 2450\u000d\u000a CLERK TOTAL BY JOB 4150\u000d\u000a SALESMAN TOTAL BY JOB 5600\u000d\u000a PRESIDENT TOTAL BY JOB 5000\u000d\u000a MANAGER TOTAL BY JOB 8275\u000d\u000a ANALYST TOTAL BY JOB 6000\u000d\u000aAs you can see, GROUPING SETS makes it easy indeed to play around with totals\u000d\u000aand subtotals to look at your data from different angles.\u000d\u000aMySQL\u000d\u000aThe first step is to use the aggregate function SUM and group by both DEPTNO and\u000d\u000aJOB:\u000d\u000aselect deptno, job,\u000d\u000a 'TOTAL BY DEPT AND JOB' as category,\u000d\u000a sum(sal) as sal\u000d\u000a from emp\u000d\u000a group by deptno, job\u000d\u000aDEPTNO JOB CATEGORY SAL\u000d\u000a------ --------- --------------------- -------\u000d\u000a 10 CLERK TOTAL BY DEPT AND JOB 1300\u000d\u000a 10 MANAGER TOTAL BY DEPT AND JOB 2450\u000d\u000a 10 PRESIDENT TOTAL BY DEPT AND JOB 5000\u000d\u000a 20 CLERK TOTAL BY DEPT AND JOB 1900\u000d\u000a 20 ANALYST TOTAL BY DEPT AND JOB 6000\u000d\u000a 20 MANAGER TOTAL BY DEPT AND JOB 2975\u000d\u000a 30 CLERK TOTAL BY DEPT AND JOB 950\u000d\u000a 30 MANAGER TOTAL BY DEPT AND JOB 2850\u000d\u000a 30 SALESMAN TOTAL BY DEPT AND JOB 5600\u000d\u000aThe next step is to use UNION ALL to append TOTAL BY JOB sums:\u000d\u000aselect deptno, job,\u000d\u000a 'TOTAL BY DEPT AND JOB' as category,\u000d\u000a sum(sal) as sal\u000d\u000a from emp\u000d\u000a group by deptno, job\u000d\u000a union all\u000d\u000a408 | Chapter 12: Reporting and Reshaping","select null, job, 'TOTAL BY JOB', sum(sal)\u000d\u000a from emp\u000d\u000a group by job\u000d\u000aDEPTNO JOB CATEGORY SAL\u000d\u000a------ --------- --------------------- -------\u000d\u000a 10 CLERK TOTAL BY DEPT AND JOB 1300\u000d\u000a 10 MANAGER TOTAL BY DEPT AND JOB 2450\u000d\u000a 10 PRESIDENT TOTAL BY DEPT AND JOB 5000\u000d\u000a 20 CLERK TOTAL BY DEPT AND JOB 1900\u000d\u000a 20 ANALYST TOTAL BY DEPT AND JOB 6000\u000d\u000a 20 MANAGER TOTAL BY DEPT AND JOB 2975\u000d\u000a 30 CLERK TOTAL BY DEPT AND JOB 950\u000d\u000a 30 MANAGER TOTAL BY DEPT AND JOB 2850\u000d\u000a 30 SALESMAN TOTAL BY DEPT AND JOB 5600\u000d\u000a ANALYST TOTAL BY JOB 6000\u000d\u000a CLERK TOTAL BY JOB 4150\u000d\u000a MANAGER TOTAL BY JOB 8275\u000d\u000a PRESIDENT TOTAL BY JOB 5000\u000d\u000a SALESMAN TOTAL BY JOB 5600\u000d\u000aThe next step is to UNION ALL the sum of all the salaries by DEPTNO:\u000d\u000aselect deptno, job,\u000d\u000a 'TOTAL BY DEPT AND JOB' as category,\u000d\u000a sum(sal) as sal\u000d\u000a from emp\u000d\u000a group by deptno, job\u000d\u000a union all\u000d\u000aselect null, job, 'TOTAL BY JOB', sum(sal)\u000d\u000a from emp\u000d\u000a group by job\u000d\u000a union all\u000d\u000aselect deptno, null, 'TOTAL BY DEPT', sum(sal)\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000aDEPTNO JOB CATEGORY SAL\u000d\u000a------ --------- --------------------- -------\u000d\u000a 10 CLERK TOTAL BY DEPT AND JOB 1300\u000d\u000a 10 MANAGER TOTAL BY DEPT AND JOB 2450\u000d\u000a 10 PRESIDENT TOTAL BY DEPT AND JOB 5000\u000d\u000a 20 CLERK TOTAL BY DEPT AND JOB 1900\u000d\u000a 20 ANALYST TOTAL BY DEPT AND JOB 6000\u000d\u000a 20 MANAGER TOTAL BY DEPT AND JOB 2975\u000d\u000a 30 CLERK TOTAL BY DEPT AND JOB 950\u000d\u000a 30 MANAGER TOTAL BY DEPT AND JOB 2850\u000d\u000a 30 SALESMAN TOTAL BY DEPT AND JOB 5600\u000d\u000a ANALYST TOTAL BY JOB 6000\u000d\u000a CLERK TOTAL BY JOB 4150\u000d\u000a MANAGER TOTAL BY JOB 8275\u000d\u000a PRESIDENT TOTAL BY JOB 5000\u000d\u000a SALESMAN TOTAL BY JOB 5600\u000d\u000a12.13 Calculating Subtotals for All Possible Expression Combinations | 409"," 10 TOTAL BY DEPT 8750\u000d\u000a 20 TOTAL BY DEPT 10875\u000d\u000a 30 TOTAL BY DEPT 9400\u000d\u000aThe final step is to use UNION ALL to append the sum of all salaries:\u000d\u000aselect deptno, job,\u000d\u000a 'TOTAL BY DEPT AND JOB' as category,\u000d\u000a sum(sal) as sal\u000d\u000a from emp\u000d\u000a group by deptno, job\u000d\u000a union all\u000d\u000aselect null, job, 'TOTAL BY JOB', sum(sal)\u000d\u000a from emp\u000d\u000a group by job\u000d\u000a union all\u000d\u000aselect deptno, null, 'TOTAL BY DEPT', sum(sal)\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000a union all\u000d\u000aselect null,null, 'GRAND TOTAL FOR TABLE', sum(sal)\u000d\u000a from emp\u000d\u000aDEPTNO JOB CATEGORY SAL\u000d\u000a------ --------- --------------------- -------\u000d\u000a 10 CLERK TOTAL BY DEPT AND JOB 1300\u000d\u000a 10 MANAGER TOTAL BY DEPT AND JOB 2450\u000d\u000a 10 PRESIDENT TOTAL BY DEPT AND JOB 5000\u000d\u000a 20 CLERK TOTAL BY DEPT AND JOB 1900\u000d\u000a 20 ANALYST TOTAL BY DEPT AND JOB 6000\u000d\u000a 20 MANAGER TOTAL BY DEPT AND JOB 2975\u000d\u000a 30 CLERK TOTAL BY DEPT AND JOB 950\u000d\u000a 30 MANAGER TOTAL BY DEPT AND JOB 2850\u000d\u000a 30 SALESMAN TOTAL BY DEPT AND JOB 5600\u000d\u000a ANALYST TOTAL BY JOB 6000\u000d\u000a CLERK TOTAL BY JOB 4150\u000d\u000a MANAGER TOTAL BY JOB 8275\u000d\u000a PRESIDENT TOTAL BY JOB 5000\u000d\u000a SALESMAN TOTAL BY JOB 5600\u000d\u000a 10 TOTAL BY DEPT 8750\u000d\u000a 20 TOTAL BY DEPT 10875\u000d\u000a 30 TOTAL BY DEPT 9400\u000d\u000a GRAND TOTAL FOR TABLE 29025\u000d\u000a12.14 Identifying Rows That Are Not Subtotals\u000d\u000aProblem\u000d\u000aYou\u2019ve used the CUBE extension of the GROUP BY clause to create a report, and you\u000d\u000aneed a way to differentiate between rows that would be generated by a normal \u000d\u000a410 | Chapter 12: Reporting and Reshaping","GROUP BY clause and those rows that have been generated as a result of using CUBE\u000d\u000aor ROLLUP.\u000d\u000aThe following is the result set from a query using the CUBE extension to GROUP BY\u000d\u000ato create a breakdown of the salaries in table EMP:\u000d\u000aDEPTNO JOB SAL\u000d\u000a------ --------- -------\u000d\u000a 29025\u000d\u000a CLERK 4150\u000d\u000a ANALYST 6000\u000d\u000a MANAGER 8275\u000d\u000a SALESMAN 5600\u000d\u000a PRESIDENT 5000\u000d\u000a 10 8750\u000d\u000a 10 CLERK 1300\u000d\u000a 10 MANAGER 2450\u000d\u000a 10 PRESIDENT 5000\u000d\u000a 20 10875\u000d\u000a 20 CLERK 1900\u000d\u000a 20 ANALYST 6000\u000d\u000a 20 MANAGER 2975\u000d\u000a 30 9400\u000d\u000a 30 CLERK 950\u000d\u000a 30 MANAGER 2850\u000d\u000a 30 SALESMAN 5600\u000d\u000aThis report includes the sum of all salaries by DEPTNO and JOB (for each JOB per\u000d\u000aDEPTNO), the sum of all salaries by DEPTNO, the sum of all salaries by JOB, and\u000d\u000afinally a grand total (the sum of all salaries in table EMP). You want to clearly identify\u000d\u000athe different levels of aggregation. You want to be able to identify which category an\u000d\u000aaggregated value belongs to (i.e., does a given value in the SAL column represent a\u000d\u000atotal by DEPTNO? By JOB? The grand total?). You would like to return the following\u000d\u000aresult set:\u000d\u000aDEPTNO JOB SAL DEPTNO_SUBTOTALS JOB_SUBTOTALS\u000d\u000a------ --------- ------- ---------------- -------------\u000d\u000a 29025 1 1\u000d\u000a CLERK 4150 1 0\u000d\u000a ANALYST 6000 1 0\u000d\u000a MANAGER 8275 1 0\u000d\u000a SALESMAN 5600 1 0\u000d\u000a PRESIDENT 5000 1 0\u000d\u000a 10 8750 0 1\u000d\u000a 10 CLERK 1300 0 0\u000d\u000a 10 MANAGER 2450 0 0\u000d\u000a 10 PRESIDENT 5000 0 0\u000d\u000a 20 10875 0 1\u000d\u000a 20 CLERK 1900 0 0\u000d\u000a 20 ANALYST 6000 0 0\u000d\u000a 20 MANAGER 2975 0 0\u000d\u000a12.14 Identifying Rows That Are Not Subtotals | 411"," 30 9400 0 1\u000d\u000a 30 CLERK 950 0 0\u000d\u000a 30 MANAGER 2850 0 0\u000d\u000a 30 SALESMAN 5600 0 0\u000d\u000aSolution\u000d\u000aUse the GROUPING function to identify which values exist due to CUBE\u2019s or ROLL\u2010\u000d\u000aUP\u2019s creation of subtotals, or superaggregate values. The following is an example for\u000d\u000aPostgreSQL, DB2, and Oracle:\u000d\u000a 1 select deptno, jo) sal,\u000d\u000a 2 grouping(deptno) deptno_subtotals,\u000d\u000a 3 grouping(job) job_subtotals\u000d\u000a 4 from emp\u000d\u000a 5 group by cube(deptno,job)\u000d\u000aThe only difference between the SQL Server solution and that for DB2 and Oracle lies\u000d\u000ain how the CUBE/ROLLUP clauses are written:\u000d\u000a 1 select deptno, job, sum(sal) sal,\u000d\u000a 2 grouping(deptno) deptno_subtotals,\u000d\u000a 3 grouping(job) job_subtotals\u000d\u000a 4 from emp\u000d\u000a 5 group by deptno,job with cube\u000d\u000aThis recipe is meant to highlight the use of CUBE and GROUPING when working\u000d\u000awith subtotals. As of the time of this writing, MySQL doesn\u2019t support either CUBE or\u000d\u000aGROUPING.\u000d\u000aDiscussion\u000d\u000aIf DEPTNO_SUBTOTALS is 0 and JOB_SUBTOTALS is 1 (in which case JOB is\u000d\u000aNULL), the value of SAL represents a subtotal of salaries by DEPTNO created by\u000d\u000aCUBE. If JOB_SUBTOTALS is 0 and DEPTNO_SUBTOTALS is 1 (in which case\u000d\u000aDEPTNO is NULL), the value of SAL represents a subtotal of salaries by JOB created\u000d\u000aby CUBE. Rows with 0 for both DEPTNO_SUBTOTALS and JOB_SUBTOTALS rep\u2010\u000d\u000aresent rows created by regular aggregation (the sum of SAL for each DEPTNO/JOB\u000d\u000acombination).\u000d\u000a12.15 Using Case Expressions to Flag Rows\u000d\u000aProblem\u000d\u000aYou want to map the values in a column, perhaps the EMP table\u2019s JOB column, into a\u000d\u000aseries of \u201cBoolean\u201d flags. For example, you want to return the following result set:\u000d\u000a412 | Chapter 12: Reporting and Reshaping","ENAME IS_CLERK IS_SALES IS_MGR IS_ANALYST IS_PREZ\u000d\u000a------ -------- -------- ------ ---------- -------\u000d\u000aKING 0 0 0 0 1\u000d\u000aSCOTT 0 0 0 1 0\u000d\u000aFORD 0 0 0 1 0\u000d\u000aJONES 0 0 1 0 0\u000d\u000aBLAKE 0 0 1 0 0\u000d\u000aCLARK 0 0 1 0 0\u000d\u000aALLEN 0 1 0 0 0\u000d\u000aWARD 0 1 0 0 0\u000d\u000aMARTIN 0 1 0 0 0\u000d\u000aTURNER 0 1 0 0 0\u000d\u000aSMITH 1 0 0 0 0\u000d\u000aMILLER 1 0 0 0 0\u000d\u000aADAMS 1 0 0 0 0\u000d\u000aJAMES 1 0 0 0 0\u000d\u000aSuch a result set can be useful for debugging and to provide yourself a view of the\u000d\u000adata different from what you\u2019d see in a more typical result set.\u000d\u000aSolution\u000d\u000aUse a CASE expression to evaluate each employee\u2019s JOB, and return a 1 or 0 to signify\u000d\u000atheir JOB. You\u2019ll need to write one CASE expression, and thus create one column for\u000d\u000aeach possible job:\u000d\u000a 1 select ename,\u000d\u000a 2 case when job = 'CLERK'\u000d\u000a 3 then 1 else 0\u000d\u000a 4 end as is_clerk,\u000d\u000a 5 case when job = 'SALESMAN'\u000d\u000a 6 then 1 else 0\u000d\u000a 7 end as is_sales,\u000d\u000a 8 case when job = 'MANAGER'\u000d\u000a 9 then 1 else 0\u000d\u000a10 end as is_mgr,\u000d\u000a11 case when job = 'ANALYST'\u000d\u000a12 then 1 else 0\u000d\u000a13 end as is_analyst,\u000d\u000a14 case when job = 'PRESIDENT'\u000d\u000a15 then 1 else 0\u000d\u000a16 end as is_prez\u000d\u000a17 from emp\u000d\u000a18 order by 2,3,4,5,6\u000d\u000a12.15 Using Case Expressions to Flag Rows | 413","Discussion\u000d\u000aThe solution code is pretty much self-explanatory. If you are having trouble under\u2010\u000d\u000astanding it, simply add JOB to the SELECT clause:\u000d\u000aselect ename,\u000d\u000a job,\u000d\u000a case when job = 'CLERK'\u000d\u000a then 1 else 0\u000d\u000a end as is_clerk,\u000d\u000a case when job = 'SALESMAN'\u000d\u000a then 1 else 0\u000d\u000a end as is_sales,\u000d\u000a case when job = 'MANAGER'\u000d\u000a then 1 else 0\u000d\u000a end as is_mgr,\u000d\u000a case when job = 'ANALYST'\u000d\u000a then 1 else 0\u000d\u000a end as is_analyst,\u000d\u000a case when job = 'PRESIDENT'\u000d\u000a then 1 else 0\u000d\u000a end as is_prez\u000d\u000a from emp\u000d\u000a order by 2\u000d\u000aENAME JOB IS_CLERK IS_SALES IS_MGR IS_ANALYST IS_PREZ\u000d\u000a------ --------- -------- -------- ------ ---------- -------\u000d\u000aSCOTT ANALYST 0 0 0 1 0\u000d\u000aFORD ANALYST 0 0 0 1 0\u000d\u000aSMITH CLERK 1 0 0 0 0\u000d\u000aADAMS CLERK 1 0 0 0 0\u000d\u000aMILLER CLERK 1 0 0 0 0\u000d\u000aJAMES CLERK 1 0 0 0 0\u000d\u000aJONES MANAGER 0 0 1 0 0\u000d\u000aCLARK MANAGER 0 0 1 0 0\u000d\u000aBLAKE MANAGER 0 0 1 0 0\u000d\u000aKING PRESIDENT 0 0 0 0 1\u000d\u000aALLEN SALESMAN 0 1 0 0 0\u000d\u000aMARTIN SALESMAN 0 1 0 0 0\u000d\u000aTURNER SALESMAN 0 1 0 0 0\u000d\u000aWARD SALESMAN 0 1 0 0 0\u000d\u000a12.16 Creating a Sparse Matrix\u000d\u000aProblem\u000d\u000aYou want to create a sparse matrix, such as the following one transposing the\u000d\u000aDEPTNO and JOB columns of table EMP:\u000d\u000a414 | Chapter 12: Reporting and Reshaping","D10 D20 D30 CLERKS MGRS PREZ ANALS SALES\u000d\u000a---------- ---------- ---------- ------ ----- ---- ----- ------\u000d\u000a SMITH SMITH\u000d\u000a ALLEN ALLEN\u000d\u000a WARD WARD\u000d\u000a JONES JONES\u000d\u000a MARTIN MARTIN\u000d\u000a BLAKE BLAKE\u000d\u000aCLARK CLARK\u000d\u000a SCOTT SCOTT\u000d\u000aKING KING\u000d\u000a TURNER TURNER\u000d\u000a ADAMS ADAMS\u000d\u000a JAMES JAMES\u000d\u000a FORD FORD\u000d\u000aMILLER MILLER\u000d\u000aSolution\u000d\u000aUse CASE expressions to create a sparse row-to-column transformation:\u000d\u000a 1 select case deptno when 10 then ename end as d10,\u000d\u000a 2 case deptno when 20 then ename end as d20,\u000d\u000a 3 case deptno when 30 then ename end as d30,\u000d\u000a 4 case job when 'CLERK' then ename end as clerks,\u000d\u000a 5 case job when 'MANAGER' then ename end as mgrs,\u000d\u000a 6 case job when 'PRESIDENT' then ename end as prez,\u000d\u000a 7 case job when 'ANALYST' then ename end as anals,\u000d\u000a 8 case job when 'SALESMAN' then ename end as sales\u000d\u000a 9 from emp\u000d\u000aDiscussion\u000d\u000aTo transform the DEPTNO and JOB rows to columns, simply use a CASE expression\u000d\u000ato evaluate the possible values returned by those rows. That\u2019s all there is to it. As an\u000d\u000aaside, if you want to \u201cdensify\u201d the report and get rid of some of those NULL rows,\u000d\u000ayou would need to find something to group by. For example, use the window func\u2010\u000d\u000ation ROW_NUMBER OVER to assign a ranking for each employee per DEPTNO,\u000d\u000aand then use the aggregate function MAX to rub out some of the NULLs:\u000d\u000aselect max(case deptno when 10 then ename end) d10,\u000d\u000a max(case deptno when 20 then ename end) d20,\u000d\u000a max(case deptno when 30 then ename end) d30,\u000d\u000a max(case job when 'CLERK' then ename end) clerks,\u000d\u000a max(case job when 'MANAGER' then ename end) mgrs,\u000d\u000a max(case job when 'PRESIDENT' then ename end) prez, \u000d\u000a max(case job when 'ANALYST' then ename end) anals, \u000d\u000a max(case job when 'SALESMAN' then ename end) sales\u000d\u000a from ( \u000d\u000aselect deptno, job, ename,\u000d\u000a row_number()over(partition by deptno order by empno) rn \u000d\u000a12.16 Creating a Sparse Matrix | 415"," from emp \u000d\u000a ) x \u000d\u000a group by rn\u000d\u000aD10 D20 D30 CLERKS MGRS PREZ ANALS SALES\u000d\u000a---------- ---------- ---------- ------ ----- ---- ----- ------\u000d\u000aCLARK SMITH ALLEN SMITH CLARK ALLEN\u000d\u000aKING JONES WARD JONES KING WARD\u000d\u000aMILLER SCOTT MARTIN MILLER SCOTT MARTIN\u000d\u000a ADAMS BLAKE ADAMS BLAKE\u000d\u000a FORD TURNER FORD TURNER\u000d\u000a JAMES JAMES\u000d\u000a12.17 Grouping Rows by Units of Time\u000d\u000aProblem\u000d\u000aYou want to summarize data by some interval of time. For example, you have a trans\u2010\u000d\u000aaction log and want to summarize transactions by five-second intervals. The rows in\u000d\u000atable TRX_LOG are shown here:\u000d\u000aselect trx_id,\u000d\u000a trx_date,\u000d\u000a trx_cnt\u000d\u000a from trx_log\u000d\u000aTRX_ID TRX_DATE TRX_CNT\u000d\u000a------ -------------------- ----------\u000d\u000a 1 28-JUL-2020 19:03:07 44\u000d\u000a 2 28-JUL-2020 19:03:08 18\u000d\u000a 3 28-JUL-2020 19:03:09 23\u000d\u000a 4 28-JUL-2020 19:03:10 29\u000d\u000a 5 28-JUL-2020 19:03:11 27\u000d\u000a 6 28-JUL-2020 19:03:12 45\u000d\u000a 7 28-JUL-2020 19:03:13 45\u000d\u000a 8 28-JUL-2020 19:03:14 32\u000d\u000a 9 28-JUL-2020 19:03:15 41\u000d\u000a 10 28-JUL-2020 19:03:16 15\u000d\u000a 11 28-JUL-2020 19:03:17 24\u000d\u000a 12 28-JUL-2020 19:03:18 47\u000d\u000a 13 28-JUL-2020 19:03:19 37\u000d\u000a 14 28-JUL-2020 19:03:20 48\u000d\u000a 15 28-JUL-2020 19:03:21 46\u000d\u000a 16 28-JUL-2020 19:03:22 44\u000d\u000a 17 28-JUL-2020 19:03:23 36\u000d\u000a 18 28-JUL-2020 19:03:24 41\u000d\u000a 19 28-JUL-2020 19:03:25 33\u000d\u000a 20 28-JUL-2020 19:03:26 19\u000d\u000aYou want to return the following result set:\u000d\u000a416 | Chapter 12: Reporting and Reshaping","GRP TRX_START TRX_END TOTAL\u000d\u000a--- -------------------- -------------------- ----------\u000d\u000a 1 28-JUL-2020 19:03:07 28-JUL-2020 19:03:11 141\u000d\u000a 2 28-JUL-2020 19:03:12 28-JUL-2020 19:03:16 178\u000d\u000a 3 28-JUL-2020 19:03:17 28-JUL-2020 19:03:21 202\u000d\u000a 4 28-JUL-2020 19:03:22 28-JUL-2020 19:03:26 173\u000d\u000aSolution\u000d\u000aGroup the entries into five row buckets. There are several ways to accomplish that\u000d\u000alogical grouping; this recipe does so by dividing the TRX_ID values by five, using a\u000d\u000atechnique shown earlier in Recipe 12.7.\u000d\u000aOnce you\u2019ve created the \u201cgroups,\u201d use the aggregate functions MIN, MAX, and SUM\u000d\u000ato find the start time, end time, and total number of transactions for each \u201cgroup\u201d\u000d\u000a(SQL Server users should use CEILING instead of CEIL):\u000d\u000a 1 select ceil(trx_id/5.0) as grp,\u000d\u000a 2 min(trx_date) as trx_start,\u000d\u000a 3 max(trx_date) as trx_end,\u000d\u000a 4 sum(trx_cnt) as total\u000d\u000a 5 from trx_log\u000d\u000a 6 group by ceil(trx_id/5.0)\u000d\u000aDiscussion\u000d\u000aThe first step, and the key to the whole solution, is to logically group the rows\u000d\u000atogether. By dividing by five and taking the smallest whole number greater than the\u000d\u000aquotient, you can create logical groups. For example:\u000d\u000aselect trx_id,\u000d\u000a trx_date,\u000d\u000a trx_cnt,\u000d\u000a trx_id/5.0 as val,\u000d\u000a ceil(trx_id/5.0) as grp\u000d\u000a from trx_log\u000d\u000aTRX_ID TRX_DATE TRX_CNT VAL GRP\u000d\u000a------ -------------------- ------- ------ ---\u000d\u000a 1 28-JUL-2020 19:03:07 44 .20 1\u000d\u000a 2 28-JUL-2020 19:03:08 18 .40 1\u000d\u000a 3 28-JUL-2020 19:03:09 23 .60 1\u000d\u000a 4 28-JUL-2020 19:03:10 29 .80 1\u000d\u000a 5 28-JUL-2020 19:03:11 27 1.00 1\u000d\u000a 6 28-JUL-2020 19:03:12 45 1.20 2\u000d\u000a 7 28-JUL-2020 19:03:13 45 1.40 2\u000d\u000a 8 28-JUL-2020 19:03:14 32 1.60 2\u000d\u000a 9 28-JUL-2020 19:03:15 41 1.80 2\u000d\u000a 10 28-JUL-2020 19:03:16 15 2.00 2\u000d\u000a 11 28-JUL-2020 19:03:17 24 2.20 3\u000d\u000a 12 28-JUL-2020 19:03:18 47 2.40 3\u000d\u000a 13 28-JUL-2020 19:03:19 37 2.60 3\u000d\u000a12.17 Grouping Rows by Units of Time | 417"," 14 28-JUL-2020 19:03:20 48 2.80 3\u000d\u000a 15 28-JUL-2020 19:03:21 46 3.00 3\u000d\u000a 16 28-JUL-2020 19:03:22 44 3.20 4\u000d\u000a 17 28-JUL-2020 19:03:23 36 3.40 4\u000d\u000a 18 28-JUL-2020 19:03:24 41 3.60 4\u000d\u000a 19 28-JUL-2020 19:03:25 33 3.80 4\u000d\u000a 20 28-JUL-2020 19:03:26 19 4.00 4\u000d\u000aThe last step is to apply the appropriate aggregate functions to find the total number\u000d\u000aof transactions per five seconds, along with the start and end times for each\u000d\u000atransaction:\u000d\u000aselect ceil(trx_id/5.0) as grp,\u000d\u000a min(trx_date) as trx_start,\u000d\u000a max(trx_date) as trx_end,\u000d\u000a sum(trx_cnt) as total\u000d\u000a from trx_log\u000d\u000a group by ceil(trx_id/5.0)\u000d\u000aGRP TRX_START TRX_END TOTAL\u000d\u000a--- -------------------- -------------------- ----------\u000d\u000a 1 28-JUL-2020 19:03:07 28-JUL-2005 19:03:11 141\u000d\u000a 2 28-JUL-2020 19:03:12 28-JUL-2005 19:03:16 178\u000d\u000a 3 28-JUL-2020 19:03:17 28-JUL-2005 19:03:21 202\u000d\u000a 4 28-JUL-2020 19:03:22 28-JUL-2005 19:03:26 173\u000d\u000aIf your data is slightly different (perhaps you don\u2019t have an ID for each row), you can\u000d\u000aalways \u201cgroup\u201d by dividing the seconds of each TRX_DATE row by five to create a\u000d\u000asimilar grouping. Then you can include the hour for each TRX_DATE and group by\u000d\u000athe actual hour and logical \u201cgrouping,\u201d GRP. The following is an example of this tech\u2010\u000d\u000anique (using Oracle\u2019s TO_CHAR and TO_NUMBER functions, you would use the\u000d\u000aappropriate date and character formatting functions for your platform):\u000d\u000aselect trx_date,trx_cnt,\u000d\u000a to_number(to_char(trx_date,'hh24')) hr,\u000d\u000a ceil(to_number(to_char(trx_date-1/24/60/60,'miss'))/5.0) grp\u000d\u000a from trx_log\u000d\u000aTRX_DATE 20 TRX_CNT HR GRP\u000d\u000a-------------------- ---------- ---------- ----------\u000d\u000a28-JUL-2020 19:03:07 44 19 62\u000d\u000a28-JUL-2020 19:03:08 18 19 62\u000d\u000a28-JUL-2020 19:03:09 23 19 62\u000d\u000a28-JUL-2020 19:03:10 29 19 62\u000d\u000a28-JUL-2020 19:03:11 27 19 62\u000d\u000a28-JUL-2020 19:03:12 45 19 63\u000d\u000a28-JUL-2020 19:03:13 45 19 63\u000d\u000a28-JUL-2020 19:03:14 32 19 63\u000d\u000a28-JUL-2020 19:03:15 41 19 63\u000d\u000a28-JUL-2020 19:03:16 15 19 63\u000d\u000a28-JUL-2020 19:03:17 24 19 64\u000d\u000a28-JUL-2020 19:03:18 47 19 64\u000d\u000a28-JUL-2020 19:03:19 37 19 64\u000d\u000a418 | Chapter 12: Reporting and Reshaping","28-JUL-2020 19:03:20 48 19 64\u000d\u000a28-JUL-2020 19:03:21 46 19 64\u000d\u000a28-JUL-2020 19:03:22 44 19 65\u000d\u000a28-JUL-2020 19:03:23 36 19 65\u000d\u000a28-JUL-2020 19:03:24 41 19 65\u000d\u000a28-JUL-2020 19:03:25 33 19 65\u000d\u000a28-JUL-2020 19:03:26 19 19 65\u000d\u000aRegardless of the actual values for GRP, the key here is that you are grouping for\u000d\u000aevery five seconds. From there you can apply the aggregate functions in the same way\u000d\u000aas in the original solution:\u000d\u000aselect hr,grp,sum(trx_cnt) total\u000d\u000a from (\u000d\u000aselect trx_date,trx_cnt,\u000d\u000a to_number(to_char(trx_date,'hh24')) hr,\u000d\u000a ceil(to_number(to_char(trx_date-1/24/60/60,'miss'))/5.0) grp\u000d\u000a from trx_log\u000d\u000a ) x\u000d\u000a group by hr,grp\u000d\u000aHR GRP TOTAL\u000d\u000a-- ---------- ----------\u000d\u000a19 62 141\u000d\u000a19 63 178\u000d\u000a19 64 202\u000d\u000a19 65 173\u000d\u000aIncluding the hour in the grouping is useful if your transaction log spans hours. In\u000d\u000aDB2 and Oracle, you can also use the window function SUM OVER to produce the\u000d\u000asame result. The following query returns all rows from TRX_LOG along with a run\u2010\u000d\u000aning total for TRX_CNT by logical \u201cgroup,\u201d and the TOTAL for TRX_CNT for each\u000d\u000arow in the \u201cgroup\u201d:\u000d\u000aselect trx_id, trx_date, trx_cnt,\u000d\u000a sum(trx_cnt)over(partition by ceil(trx_id/5.0)\u000d\u000a order by trx_date\u000d\u000a range between unbounded preceding\u000d\u000a and current row) runing_total,\u000d\u000a sum(trx_cnt)over(partition by ceil(trx_id/5.0)) total,\u000d\u000a case when mod(trx_id,5.0) = 0 then 'X' end grp_end\u000d\u000a from trx_log\u000d\u000aTRX_ID TRX_DATE TRX_CNT RUNING_TOTAL TOTAL GRP_END\u000d\u000a------ -------------------- ---------- ------------ ---------- -------\u000d\u000a 1 28-JUL-2020 19:03:07 44 44 141\u000d\u000a 2 28-JUL-2020 19:03:08 18 62 141\u000d\u000a 3 28-JUL-2020 19:03:09 23 85 141\u000d\u000a 4 28-JUL-2020 19:03:10 29 114 141\u000d\u000a 5 28-JUL-2020 19:03:11 27 141 141 X\u000d\u000a 6 28-JUL-2020 19:03:12 45 45 178\u000d\u000a 7 28-JUL-2020 19:03:13 45 90 178\u000d\u000a 8 28-JUL-2020 19:03:14 32 122 178\u000d\u000a12.17 Grouping Rows by Units of Time | 419"," 9 28-JUL-2020 19:03:15 41 163 178\u000d\u000a 10 28-JUL-2020 19:03:16 15 178 178 X\u000d\u000a 11 28-JUL-2020 19:03:17 24 24 202\u000d\u000a 12 28-JUL-2020 19:03:18 47 71 202\u000d\u000a 13 28-JUL-2020 19:03:19 37 108 202\u000d\u000a 14 28-JUL-2020 19:03:20 48 156 202\u000d\u000a 15 28-JUL-2020 19:03:21 46 202 202 X\u000d\u000a 16 28-JUL-2020 19:03:22 44 44 173\u000d\u000a 17 28-JUL-2020 19:03:23 36 80 173\u000d\u000a 18 28-JUL-2020 19:03:24 41 121 173\u000d\u000a 19 28-JUL-2020 19:03:25 33 154 173\u000d\u000a 20 28-JUL-2020 19:03:26 19 173 173 X\u000d\u000a12.18 Performing Aggregations over Different Groups/\u000d\u000aPartitions Simultaneously\u000d\u000aProblem\u000d\u000aYou want to aggregate over different dimensions at the same time. For example, you\u000d\u000awant to return a result set that lists each employee\u2019s name, their department, the num\u2010\u000d\u000aber of employees in their department (themselves included), the number of employ\u2010\u000d\u000aees that have the same job (themselves included in this count as well), and the total\u000d\u000anumber of employees in the EMP table. The result set should look like the following:\u000d\u000aENAME DEPTNO DEPTNO_CNT JOB JOB_CNT TOTAL\u000d\u000a------ ------ ---------- --------- -------- ------\u000d\u000aMILLER 10 3 CLERK 4 14\u000d\u000aCLARK 10 3 MANAGER 3 14\u000d\u000aKING 10 3 PRESIDENT 1 14\u000d\u000aSCOTT 20 5 ANALYST 2 14\u000d\u000aFORD 20 5 ANALYST 2 14\u000d\u000aSMITH 20 5 CLERK 4 14\u000d\u000aJONES 20 5 MANAGER 3 14\u000d\u000aADAMS 20 5 CLERK 4 14\u000d\u000aJAMES 30 6 CLERK 4 14\u000d\u000aMARTIN 30 6 SALESMAN 4 14\u000d\u000aTURNER 30 6 SALESMAN 4 14\u000d\u000aWARD 30 6 SALESMAN 4 14\u000d\u000aALLEN 30 6 SALESMAN 4 14\u000d\u000aBLAKE 30 6 MANAGER 3 14\u000d\u000aSolution\u000d\u000aUse the COUNT OVER window function while specifying different partitions, or\u000d\u000agroups of data, on which to perform aggregation:\u000d\u000aselect ename,\u000d\u000a deptno,\u000d\u000a count(*)over(partition by deptno) deptno_cnt,\u000d\u000a420 | Chapter 12: Reporting and Reshaping"," job,\u000d\u000a count(*)over(partition by job) job_cnt,\u000d\u000a count(*)over() total\u000d\u000a from emp\u000d\u000aDiscussion\u000d\u000aThis example really shows off the power and convenience of window functions. By\u000d\u000asimply specifying different partitions or groups of data to aggregate, you can create\u000d\u000aimmensely detailed reports without having to self-join over and over, and without\u000d\u000ahaving to write cumbersome and perhaps poorly performing subqueries in your\u000d\u000aSELECT list. All the work is done by the window function COUNT OVER. To under\u2010\u000d\u000astand the output, focus on the OVER clause for a moment for each COUNT\u000d\u000aoperation:\u000d\u000acount(*)over(partition by deptno)\u000d\u000acount(*)over(partition by job)\u000d\u000acount(*)over()\u000d\u000aRemember the main parts of the OVER clause: the PARTITION BY subclause, divid\u2010\u000d\u000aing the query into partitions; and the ORDER BY subclause, defining the logical\u000d\u000aorder. Look at the first COUNT, which partitions by DEPTNO. The rows in table\u000d\u000aEMP will be grouped by DEPTNO, and the COUNT operation will be performed on\u000d\u000aall the rows in each group. Since there is no frame or window clause specified (no\u000d\u000aORDER BY), all the rows in the group are counted. The PARTITION BY clause finds\u000d\u000aall the unique DEPTNO values, and then the COUNT function counts the number of\u000d\u000arows having each value. In the specific example of COUNT(*)OVER(PARTITION\u000d\u000aBY DEPTNO), the PARTITION BY clause identifies the partitions or groups to be\u000d\u000avalues 10, 20, and 30.\u000d\u000aThe same processing is applied to the second COUNT, which partitions by JOB. The\u000d\u000alast count does not partition by anything and simply has an empty parentheses. An\u000d\u000aempty parentheses implies \u201cthe whole table.\u201d So, whereas the two prior COUNTs\u000d\u000aaggregate values based on the defined groups or partitions, the final COUNT counts\u000d\u000aall rows in table EMP.\u000d\u000aKeep in mind that window functions are applied after the WHERE\u000d\u000aclause. If you were to filter the result set in some way, for example,\u000d\u000aexcluding all employees in DEPTNO 10, the value for TOTAL\u000d\u000awould not be 14\u2014it would be 11. To filter results after window\u000d\u000afunctions have been evaluated, you must make your windowing\u000d\u000aquery into an inline view and then filter on the results from that\u000d\u000aview.\u000d\u000a12.18 Performing Aggregations over Different Groups/Partitions Simultaneously | 421","12.19 Performing Aggregations over a Moving Range of\u000d\u000aValues\u000d\u000aProblem\u000d\u000aYou want to compute a moving aggregation, such as a moving sum on the salaries in\u000d\u000atable EMP. You want to compute a sum for every 90 days, starting with the HIRE\u2010\u000d\u000aDATE of the first employee. You want to see how spending has fluctuated for every\u000d\u000a90-day period between the first and last employee hired. You want to return the fol\u2010\u000d\u000alowing result set:\u000d\u000aHIREDATE SAL SPENDING_PATTERN\u000d\u000a----------- ------- ----------------\u000d\u000a17-DEC-200 800 800\u000d\u000a20-FEB-2011 1600 2400\u000d\u000a22-FEB-2011 1250 3650\u000d\u000a02-APR-2011 2975 5825\u000d\u000a01-MAY-2011 2850 8675\u000d\u000a09-JUN-2011 2450 8275\u000d\u000a08-SEP-2011 1500 1500\u000d\u000a28-SEP-2011 1250 2750\u000d\u000a17-NOV-2011 5000 7750\u000d\u000a03-DEC-2011 950 11700\u000d\u000a03-DEC-2011 3000 11700\u000d\u000a23-JAN-2012 1300 10250\u000d\u000a09-DEC-2012 3000 3000\u000d\u000a12-JAN-2013 1100 4100\u000d\u000aSolution\u000d\u000aBeing able to specify a moving window in the framing or windowing clause of win\u2010\u000d\u000adow functions makes this problem easy to solve, if your RDBMS supports such func\u2010\u000d\u000ations. The key is to order by HIREDATE in your window function and then specify a\u000d\u000awindow of 90 days starting from the earliest employee hired. The sum will be compu\u2010\u000d\u000ated using the salaries of employees hired up to 90 days prior to the current employee\u2019s\u000d\u000aHIREDATE (the current employee is included in the sum). If you do not have win\u2010\u000d\u000adow functions available, you can use scalar subqueries, but the solution will be more\u000d\u000acomplex.\u000d\u000aDB2 and Oracle\u000d\u000aFor DB2 and Oracle, use the window function SUM OVER and order by HIREDATE.\u000d\u000aSpecify a range of 90 days in the window or \u201cframing\u201d clause to allow the sum to be\u000d\u000acomputed for each employee\u2019s salary and to include the salaries of all employees hired\u000d\u000aup to 90 days earlier. Because DB2 does not allow you to specify HIREDATE in the\u000d\u000a422 | Chapter 12: Reporting and Reshaping","ORDER BY clause of a window function (line 3 in the following code), you can order\u000d\u000aby DAYS(HIREDATE) instead:\u000d\u000a 1 select hiredate,\u000d\u000a 2 sal,\u000d\u000a 3 sum(sal)over(order by days(hiredate)\u000d\u000a 4 range between 90 preceding\u000d\u000a 5 and current row) spending_pattern\u000d\u000a 6 from emp e\u000d\u000aThe Oracle solution is more straightforward than DB2\u2019s, because Oracle allows win\u2010\u000d\u000adow functions to order by datetime types:\u000d\u000a 1 select hiredate,\u000d\u000a 2 sal,\u000d\u000a 3 sum(sal)over(order by hiredate\u000d\u000a 4 range between 90 preceding\u000d\u000a 5 and current row) spending_pattern\u000d\u000a 6 from emp e\u000d\u000aMySQL\u000d\u000aUse the window function with slightly altered syntax:\u000d\u000a1 select hiredate,\u000d\u000a2 sal,\u000d\u000a3 sum(sal)over(order by hiredate\u000d\u000a4 range interval 90 day preceding ) spending_pattern\u000d\u000a5 from emp e\u000d\u000aPostgreSQL and SQL Server\u000d\u000aUse a scalar subquery to sum the salaries of all employees hired up to 90 days prior to\u000d\u000athe day each employee was hired:\u000d\u000a 1 select e.hiredate,\u000d\u000a 2 e.sal,\u000d\u000a 3 (select sum(sal) from emp d\u000d\u000a 4 whered.hiredate between e.hiredate-90\u000d\u000a 5 and e.hiredate) as spending_pattern\u000d\u000a 6 from emp e\u000d\u000a 7 order by 1\u000d\u000aDiscussion\u000d\u000aDB2, MySQL, and Oracle\u000d\u000aDB2, MySQL, and Oracle share the same logical solution. The only minor differences\u000d\u000abetween the solutions are in how you specify HIREDATE in the ORDER BY clause of\u000d\u000athe window function and the syntax of specifying the time interval in MySQL. At the\u000d\u000atime of this book\u2019s writing, DB2 doesn\u2019t allow a DATE value in such an ORDER BY\u000d\u000a12.19 Performing Aggregations over a Moving Range of Values | 423","clause if you are using a numeric value to set the window\u2019s range. (For example,\u000d\u000aRANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW allows\u000d\u000ayou to order by a date, but RANGE BETWEEN 90 PRECEDING AND CURRENT\u000d\u000aROW does not.)\u000d\u000aTo understand what the solution query is doing, you simply need to understand what\u000d\u000athe window clause is doing. The window you are defining orders the salaries for all\u000d\u000aemployees by HIREDATE. Then the function computes a sum. The sum is not com\u2010\u000d\u000aputed for all salaries. Instead, the processing is as follows:\u000d\u000a1. The salary of the first employee hired is evaluated. Since no employees were\u000d\u000ahired before the first employee, the sum at this point is simply the first employee\u2019s\u000d\u000asalary.\u000d\u000a2. The salary of the next employee (by HIREDATE) is evaluated. This employee\u2019s\u000d\u000asalary is included in the moving sum along with any other employees who were\u000d\u000ahired up to 90 days prior.\u000d\u000aThe HIREDATE of the first employee is December 17, 2010, and the HIREDATE of\u000d\u000athe next hired employee is February 20, 2011. The second employee was hired less\u000d\u000athan 90 days after the first employee, and thus the moving sum for the second\u000d\u000aemployee is 2400 (1600 + 800). If you are having trouble understanding where the\u000d\u000avalues in SPENDING_PATTERN come from, examine the following query and result\u000d\u000aset:\u000d\u000aselect distinct\u000d\u000a dense_rank()over(order by e.hiredate) window,\u000d\u000a e.hiredate current_hiredate,\u000d\u000a d.hiredate hiredate_within_90_days,\u000d\u000a d.sal sals_used_for_sum\u000d\u000a from emp e,\u000d\u000a emp d\u000d\u000awhere d.hiredate between e.hiredate-90 and e.hiredate\u000d\u000aWINDOW CURRENT_HIREDATE HIREDATE_WITHIN_90_DAYS SALS_USED_FOR_SUM\u000d\u000a------ ---------------- ----------------------- -----------------\u000d\u000a 1 17-DEC-2010 17-DEC-2010 800\u000d\u000a 2 20-FEB-2011 17-DEC-2010 800\u000d\u000a 2 20-FEB-2011 20-FEB-2011 1600\u000d\u000a 3 22-FEB-2011 17-DEC-2010 800\u000d\u000a 3 22-FEB-2011 20-FEB-2011 1600\u000d\u000a 3 22-FEB-2011 22-FEB-2011 1250\u000d\u000a 4 02-APR-2011 20-FEB-2011 1600\u000d\u000a 4 02-APR-2011 22-FEB-2011 1250\u000d\u000a 4 02-APR-2011 02-APR-2011 2975\u000d\u000a 5 01-MAY-2011 20-FEB-2011 1600\u000d\u000a 5 01-MAY-2011 22-FEB-2011 1250\u000d\u000a 5 01-MAY-2011 02-APR-2011 2975\u000d\u000a 5 01-MAY-2011 01-MAY-2011 2850\u000d\u000a424 | Chapter 12: Reporting and Reshaping"," 6 09-JUN-2011 02-APR-2011 2975\u000d\u000a 6 09-JUN-2011 01-MAY-2011 2850\u000d\u000a 6 09-JUN-2011 09-JUN-2011 2450\u000d\u000a 7 08-SEP-2011 08-SEP-2011 1500\u000d\u000a 8 28-SEP-2011 08-SEP-2011 1500\u000d\u000a 8 28-SEP-2011 28-SEP-2011 1250\u000d\u000a 9 17-NOV-2011 08-SEP-2011 1500\u000d\u000a 9 17-NOV-2011 28-SEP-2011 1250\u000d\u000a 9 17-NOV-2011 17-NOV-2011 5000\u000d\u000a 10 03-DEC-2011 08-SEP-2011 1500\u000d\u000a 10 03-DEC-2011 28-SEP-2011 1250\u000d\u000a 10 03-DEC-2011 17-NOV-2011 5000\u000d\u000a 10 03-DEC-2011 03-DEC-2011 950\u000d\u000a 10 03-DEC-2011 03-DEC-2011 3000\u000d\u000a 11 23-JAN-2012 17-NOV-2011 5000\u000d\u000a 11 23-JAN-2012 03-DEC-2011 950\u000d\u000a 11 23-JAN-2012 03-DEC-2011 3000\u000d\u000a 11 23-JAN-2012 23-JAN-2012 1300\u000d\u000a 12 09-DEC-2012 09-DEC-2012 3000\u000d\u000a 13 12-JAN-2013 09-DEC-2012 3000\u000d\u000a 13 12-JAN-2013 12-JAN-2013 1100\u000d\u000aIf you look at the WINDOW column, only those rows with the same WINDOW\u000d\u000avalue will be considered for each sum. Take, for example, WINDOW 3. The salaries\u000d\u000aused for the sum for that window are 800, 1600, and 1250, which total 3650. If you\u000d\u000alook at the final result set in the \u201cProblem\u201d section, you\u2019ll see the SPENDING_PAT\u2010\u000d\u000aTERN for February 22, 2011 (WINDOW 3) is 3650. As proof, to verify that the previ\u2010\u000d\u000aous self-join includes the correct salaries for the windows defined, simply sum the\u000d\u000avalues in SALS_USED_FOR_SUM and group by CURRENT_DATE. The result\u000d\u000ashould be the same as the result set shown in the \u201cProblem\u201d section (with the dupli\u2010\u000d\u000acate row for December 3, 2011, filtered out):\u000d\u000aselect current_hiredate,\u000d\u000a sum(sals_used_for_sum) spending_pattern\u000d\u000a from (\u000d\u000aselect distinct\u000d\u000a dense_rank()over(order by e.hiredate) window,\u000d\u000a e.hiredate current_hiredate,\u000d\u000a d.hiredate hiredate_within_90_days,\u000d\u000a d.sal sals_used_for_sum\u000d\u000a from emp e,\u000d\u000a emp d\u000d\u000a where d.hiredate between e.hiredate-90 and e.hiredate\u000d\u000a ) x\u000d\u000a group by current_hiredate\u000d\u000aCURRENT_HIREDATE SPENDING_PATTERN\u000d\u000a---------------- ----------------\u000d\u000a17-DEC-2010 800\u000d\u000a20-FEB-2011 2400\u000d\u000a22-FEB-2011 3650\u000d\u000a12.19 Performing Aggregations over a Moving Range of Values | 425","02-APR-2011 5825\u000d\u000a01-MAY-2011 8675\u000d\u000a09-JUN-2011 8275\u000d\u000a08-SEP-2011 1500\u000d\u000a28-SEP-2011 2750\u000d\u000a17-NOV-2011 7750\u000d\u000a03-DEC-2011 11700\u000d\u000a23-JAN-2012 10250\u000d\u000a09-DEC-2012 3000\u000d\u000a12-JAN-2013 4100\u000d\u000aPostgreSQL and SQL Server\u000d\u000aThe key to this solution is to use a scalar subquery (a self-join will work as well) while\u000d\u000ausing the aggregate function SUM to compute a sum for every 90 days based on HIR\u2010\u000d\u000aEDATE. If you are having trouble seeing how this works, simply convert the solution\u000d\u000ato a self-join and examine which rows are included in the computations. Consider the\u000d\u000afollowing result set, which returns the same result set as that in the solution:\u000d\u000aselect e.hiredate,\u000d\u000a e.sal,\u000d\u000a sum(d.sal) as spending_pattern\u000d\u000a from emp e, emp d\u000d\u000a where d.hiredate\u000d\u000a between e.hiredate-90 and e.hiredate\u000d\u000a group by e.hiredate,e.sal\u000d\u000a order by 1\\\u000d\u000aHIREDATE SAL SPENDING_PATTERN\u000d\u000a----------- ----- ----------------\u000d\u000a17-DEC-2010 800 800\u000d\u000a20-FEB-2011 1600 2400\u000d\u000a22-FEB-2011 1250 3650\u000d\u000a02-APR-2011 2975 5825\u000d\u000a01-MAY-2011 2850 8675\u000d\u000a09-JUN-2011 2450 8275\u000d\u000a08-SEP-2011 1500 1500\u000d\u000a28-SEP-2011 1250 2750\u000d\u000a17-NOV-2011 5000 7750\u000d\u000a03-DEC-2011 950 11700\u000d\u000a03-DEC-2011 3000 11700\u000d\u000a23-JAN-2012 1300 10250\u000d\u000a09-DEC-2012 3000 3000\u000d\u000a12-JAN-2013 1100 4100\u000d\u000aIf it is still unclear, simply remove the aggregation and start with the Cartesian prod\u2010\u000d\u000auct. The first step is to generate a Cartesian product using table EMP so that each\u000d\u000aHIREDATE can be compared with all the other HIREDATEs. (Only a snippet of the\u000d\u000aresult set is shown here because there are 196 rows (14 \u00d7 14) returned by a Cartesian\u000d\u000aof EMP):\u000d\u000a426 | Chapter 12: Reporting and Reshaping","select e.hiredate,\u000d\u000a e.sal,\u000d\u000a d.sal,\u000d\u000a d.hiredate\u000d\u000a from emp e, emp d\u000d\u000aHIREDATE SAL SAL HIREDATE\u000d\u000a----------- ----- ----- -----------\u000d\u000a17-DEC-2010 800 800 17-DEC-2010\u000d\u000a17-DEC-2010 800 1600 20-FEB-2011\u000d\u000a17-DEC-2010 800 1250 22-FEB-2011\u000d\u000a17-DEC-2010 800 2975 02-APR-2011\u000d\u000a17-DEC-2010 800 1250 28-SEP-2011\u000d\u000a17-DEC-2010 800 2850 01-MAY-2011\u000d\u000a17-DEC-2010 800 2450 09-JUN-2011\u000d\u000a17-DEC-2010 800 3000 09-DEC-2012\u000d\u000a17-DEC-2010 800 5000 17-NOV-2011\u000d\u000a17-DEC-2010 800 1500 08-SEP-2011\u000d\u000a17-DEC-2010 800 1100 12-JAN-2013\u000d\u000a17-DEC-2010 800 950 03-DEC-2011\u000d\u000a17-DEC-2010 800 3000 03-DEC-2011\u000d\u000a17-DEC-2010 800 1300 23-JAN-2012\u000d\u000a20-FEB-2011 1600 800 17-DEC-2010\u000d\u000a20-FEB-2011 1600 1600 20-FEB-2011\u000d\u000a20-FEB-2011 1600 1250 22-FEB-2011\u000d\u000a20-FEB-2011 1600 2975 02-APR-2011\u000d\u000a20-FEB-2011 1600 1250 28-SEP-2011\u000d\u000a20-FEB-2011 1600 2850 01-MAY-2011\u000d\u000a20-FEB-2011 1600 2450 09-JUN-2011\u000d\u000a20-FEB-2011 1600 3000 09-DEC-2012\u000d\u000a20-FEB-2011 1600 5000 17-NOV-2011\u000d\u000a20-FEB-2011 1600 1500 08-SEP-2011\u000d\u000a20-FEB-2011 1600 1100 12-JAN-2013\u000d\u000a20-FEB-2011 1600 950 03-DEC-2011\u000d\u000a20-FEB-2011 1600 3000 03-DEC-2011\u000d\u000a20-FEB-2011 1600 1300 23-JAN-2012\u000d\u000aIf you examine the previous result set, you\u2019ll notice that there is no HIREDATE 90\u000d\u000adays earlier or equal to December 17, except for December 17. So, the sum for that\u000d\u000arow should be only 800. If you examine the next HIREDATE, February 20, you\u2019ll\u000d\u000anotice that there is one HIREDATE that falls within the 90-day window (within 90\u000d\u000adays prior), and that is December 17. If you sum the SAL from December 17 with the\u000d\u000aSAL from February 20 (because we are looking for HIREDATEs equal to each HIRE\u2010\u000d\u000aDATE or within 90 days earlier), you get 2400, which happens to be the final result\u000d\u000afor that HIREDATE.\u000d\u000aNow that you know how it works, use a filter in the WHERE clause to return for each\u000d\u000aHIREDATE and HIREDATE that is equal to it or is no more than 90 days earlier:\u000d\u000a12.19 Performing Aggregations over a Moving Range of Values | 427","select e.hiredate,\u000d\u000a e.sal,\u000d\u000a d.sal sal_to_sum,\u000d\u000a d.hiredate within_90_days\u000d\u000a from emp e, emp d\u000d\u000a where d.hiredate\u000d\u000a between e.hiredate-90 and e.hiredate\u000d\u000a order by 1\u000d\u000aHIREDATE SAL SAL_TO_SUM WITHIN_90_DAYS\u000d\u000a----------- ----- ---------- --------------\u000d\u000a17-DEC-2010 800 800 17-DEC-2010\u000d\u000a20-FEB-2011 1600 800 17-DEC-2010\u000d\u000a20-FEB-2011 1600 1600 20-FEB-2011\u000d\u000a22-FEB-2011 1250 800 17-DEC-2010\u000d\u000a22-FEB-2011 1250 1600 20-FEB-2011\u000d\u000a22-FEB-2011 1250 1250 22-FEB-2011\u000d\u000a02-APR-2011 2975 1600 20-FEB-2011\u000d\u000a02-APR-2011 2975 1250 22-FEB-2011\u000d\u000a02-APR-2011 2975 2975 02-APR-2011\u000d\u000a01-MAY-2011 2850 1600 20-FEB-2011\u000d\u000a01-MAY-2011 2850 1250 22-FEB-2011\u000d\u000a01-MAY-2011 2850 2975 02-APR-2011\u000d\u000a01-MAY-2011 2850 2850 01-MAY-2011\u000d\u000a09-JUN-2011 2450 2975 02-APR-2011\u000d\u000a09-JUN-2011 2450 2850 01-MAY-2011\u000d\u000a09-JUN-2011 2450 2450 09-JUN-2011\u000d\u000a08-SEP-2011 1500 1500 08-SEP-2011\u000d\u000a28-SEP-2011 1250 1500 08-SEP-2011\u000d\u000a28-SEP-2011 1250 1250 28-SEP-2011\u000d\u000a17-NOV-2011 5000 1500 08-SEP-2011\u000d\u000a17-NOV-2011 5000 1250 28-SEP-2011\u000d\u000a17-NOV-2011 5000 5000 17-NOV-2011\u000d\u000a03-DEC-2011 950 1500 08-SEP-2011\u000d\u000a03-DEC-2011 950 1250 28-SEP-2011\u000d\u000a03-DEC-2011 950 5000 17-NOV-2011\u000d\u000a03-DEC-2011 950 950 03-DEC-2011\u000d\u000a03-DEC-2011 950 3000 03-DEC-2011\u000d\u000a03-DEC-2011 3000 1500 08-SEP-2011\u000d\u000a03-DEC-2011 3000 1250 28-SEP-2011\u000d\u000a03-DEC-2011 3000 5000 17-NOV-2011\u000d\u000a03-DEC-2011 3000 950 03-DEC-2011\u000d\u000a03-DEC-2011 3000 3000 03-DEC-2011\u000d\u000a23-JAN-2012 1300 5000 17-NOV-2011\u000d\u000a23-JAN-2012 1300 950 03-DEC-2011\u000d\u000a23-JAN-2012 1300 3000 03-DEC-2011\u000d\u000a23-JAN-2012 1300 1300 23-JAN-2012\u000d\u000a09-DEC-2012 3000 3000 09-DEC-2012\u000d\u000a12-JAN-2013 1100 3000 09-DEC-2012\u000d\u000a12-JAN-2013 1100 1100 12-JAN-2013\u000d\u000aNow that you know which SALs are to be included in the moving window of summa\u2010\u000d\u000ation, simply use the aggregate function SUM to produce a more expressive result set:\u000d\u000a428 | Chapter 12: Reporting and Reshaping","select e.hiredate,\u000d\u000a e.sal,\u000d\u000a sum(d.sal) as spending_pattern\u000d\u000a from emp e, emp d\u000d\u000a where d.hiredate\u000d\u000a between e.hiredate-90 and e.hiredate\u000d\u000a group by e.hiredate,e.sal\u000d\u000a order by 1\u000d\u000aIf you compare the result set for the previous query and the result set for the query\u000d\u000ashown here (which is the original solution presented), you will see they are the same:\u000d\u000aselect e.hiredate,\u000d\u000a e.sal,\u000d\u000a (select sum(sal) from emp d\u000d\u000a where d.hiredate between e.hiredate-90\u000d\u000a and e.hiredate) as spending_pattern\u000d\u000a from emp e\u000d\u000a order by 1\u000d\u000aHIREDATE SAL SPENDING_PATTERN\u000d\u000a----------- ----- ----------------\u000d\u000a17-DEC-2010 800 800\u000d\u000a20-FEB-2011 1600 2400\u000d\u000a22-FEB-2011 1250 3650\u000d\u000a02-APR-2011 2975 5825\u000d\u000a01-MAY-2011 2850 8675\u000d\u000a09-JUN-2011 2450 8275\u000d\u000a08-SEP-2011 1500 1500\u000d\u000a28-SEP-2011 1250 2750\u000d\u000a17-NOV-2011 5000 7750\u000d\u000a03-DEC-2011 950 11700\u000d\u000a03-DEC-2011 3000 11700\u000d\u000a23-JAN-2012 1300 10250\u000d\u000a09-DEC-2012 3000 3000\u000d\u000a12-JAN-2013 1100 4100\u000d\u000a12.20 Pivoting a Result Set with Subtotals\u000d\u000aProblem\u000d\u000aYou want to create a report containing subtotals and then transpose the results to\u000d\u000aprovide a more readable report. For example, you\u2019ve been asked to create a report\u000d\u000athat displays for each department, the managers in the department, and a sum of the\u000d\u000asalaries of the employees who work for those managers. Additionally, you want to\u000d\u000areturn two subtotals: the sum of all salaries in each department for those employees\u000d\u000awho have managers, and a sum of all salaries in the result set (the sum of the depart\u2010\u000d\u000ament subtotals). You currently have the following report:\u000d\u000a12.20 Pivoting a Result Set with Subtotals | 429","DEPTNO MGR SAL\u000d\u000a------ ---------- ----------\u000d\u000a 10 7782 1300\u000d\u000a 10 7839 2450\u000d\u000a 10 3750\u000d\u000a 20 7566 6000\u000d\u000a 20 7788 1100\u000d\u000a 20 7839 2975\u000d\u000a 20 7902 800\u000d\u000a 20 10875\u000d\u000a 30 7698 6550\u000d\u000a 30 7839 2850\u000d\u000a 30 9400\u000d\u000a 24025\u000d\u000aYou want to provide a more readable report and want to transform the previous\u000d\u000aresult set to the following, which makes the meaning of the report much clearer:\u000d\u000aMGR DEPT10 DEPT20 DEPT30 TOTAL\u000d\u000a---- ---------- ---------- ---------- ----------\u000d\u000a7566 0 6000 0\u000d\u000a7698 0 0 6550\u000d\u000a7782 1300 0 0\u000d\u000a7788 0 1100 0\u000d\u000a7839 2450 2975 2850\u000d\u000a7902 0 800 0\u000d\u000a 3750 10875 9400 24025\u000d\u000aSolution\u000d\u000aThe first step is to generate subtotals using the ROLLUP extension to GROUP BY.\u000d\u000aThe next step is to perform a classic pivot (aggregate and CASE expression) to create\u000d\u000athe desired columns for your report. The GROUPING function allows you to easily\u000d\u000adetermine which values are subtotals (that is, exist because of ROLLUP and otherwise\u000d\u000awould not normally be there). Depending on how your RDBMS sorts NULL values,\u000d\u000ayou may need to add an ORDER BY to the solution to allow it to look like the previ\u2010\u000d\u000aous target result set.\u000d\u000aDB2 and Oracle\u000d\u000aUse the ROLLUP extension to GROUP BY and then use a CASE expression to format\u000d\u000athe data into a more readable report:\u000d\u000a 1 select mgr,\u000d\u000a 2 sum(case deptno when 10 then sal else 0 end) dept10,\u000d\u000a 3 sum(case deptno when 20 then sal else 0 end) dept20,\u000d\u000a 4 sum(case deptno when 30 then sal else 0 end) dept30,\u000d\u000a 5 sum(case flag when '11' then sal else null end) total\u000d\u000a 6 from (\u000d\u000a 7 select deptno,mgr,sum(sal) sal,\u000d\u000a 8 cast(grouping(deptno) as char(1))||\u000d\u000a430 | Chapter 12: Reporting and Reshaping"," 9 cast(grouping(mgr) as char(1)) flag\u000d\u000a10 from emp\u000d\u000a11 where mgr is not null\u000d\u000a12 group by rollup(deptno,mgr)\u000d\u000a13 ) x\u000d\u000a14 group by mgr\u000d\u000aSQL Server\u000d\u000aUse the ROLLUP extension to GROUP BY and then use a CASE expression to format\u000d\u000athe data into a more readable report:\u000d\u000a 1 select mgr,\u000d\u000a 2 sum(case deptno when 10 then sal else 0 end) dept10,\u000d\u000a 3 sum(case deptno when 20 then sal else 0 end) dept20,\u000d\u000a 4 sum(case deptno when 30 then sal else 0 end) dept30,\u000d\u000a 5 sum(case flag when '11' then sal else null end) total\u000d\u000a 6 from (\u000d\u000a 7 select deptno,mgr,sum(sal) sal,\u000d\u000a 8 cast(grouping(deptno) as char(1))+\u000d\u000a 9 cast(grouping(mgr) as char(1)) flag\u000d\u000a10 from emp\u000d\u000a11 where mgr is not null\u000d\u000a12 group by deptno,mgr with rollup\u000d\u000a13 ) x\u000d\u000a14 group by mgr\u000d\u000aPostgreSQL\u000d\u000aUse the ROLLUP extension to GROUP BY and then use a CASE expression to format\u000d\u000athe data into a more readable report:\u000d\u000a 1 select mgr,\u000d\u000a 2 sum(case deptno when 10 then sal else 0 end) dept10,\u000d\u000a 3 sum(case deptno when 20 then sal else 0 end) dept20,\u000d\u000a 4 sum(case deptno when 30 then sal else 0 end) dept30,\u000d\u000a 5 sum(case flag when '11' then sal else null end) total\u000d\u000a 6 from (\u000d\u000a 7 select deptno,mgr,sum(sal) sal,\u000d\u000a 8 concat(cast (grouping(deptno) as char(1)),\u000d\u000a 9 cast(grouping(mgr) as char(1))) flag\u000d\u000a 10 from emp\u000d\u000a 11 where mgr is not null\u000d\u000a 12 group by rollup (deptno,mgr)\u000d\u000a 13 ) x\u000d\u000a 14 group by mgr\u000d\u000aMySQL\u000d\u000aUse the ROLLUP extension to GROUP BY and then use a CASE expression to format\u000d\u000athe data into a more readable report:\u000d\u000a12.20 Pivoting a Result Set with Subtotals | 431","1 select mgr,\u000d\u000a2 sum(case deptno when 10 then sal else 0 end) dept10,\u000d\u000a3 sum(case deptno when 20 then sal else 0 end) dept20,\u000d\u000a4 sum(case deptno when 30 then sal else 0 end) dept30,\u000d\u000a5 sum(case flag when '11' then sal else null end) total\u000d\u000a6 from (\u000d\u000a7 select deptno,mgr,sum(sal) sal,\u000d\u000a8 concat( cast(grouping(deptno) as char(1)) ,\u000d\u000a9 cast(grouping(mgr) as char(1))) flag\u000d\u000a10 from emp\u000d\u000a11 where mgr is not null\u000d\u000a12 group by deptno,mgr with rollup\u000d\u000a13 ) x\u000d\u000a14 group by mgr;\u000d\u000aDiscussion\u000d\u000aThe solutions provided here are identical except for the string concatenation and how\u000d\u000aGROUPING is specified. Because the solutions are so similar, the following discus\u2010\u000d\u000asion will refer to the SQL Server solution to highlight the intermediate result sets (the\u000d\u000adiscussion is relevant to DB2 and Oracle as well).\u000d\u000aThe first step is to generate a result set that sums the SAL for the employees in each\u000d\u000aDEPTNO per MGR. The idea is to show how much the employees make under a par\u2010\u000d\u000aticular manager in a particular department. For example, the following query will\u000d\u000aallow you to compare the salaries of employees who work for KING in DEPTNO 10\u000d\u000acompared with those who work for KING in DEPTNO 30:\u000d\u000aselect deptno,mgr,sum(sal) sal\u000d\u000a from emp\u000d\u000a where mgr is not null\u000d\u000a group by mgr,deptno\u000d\u000a order by 1,2\u000d\u000aDEPTNO MGR SAL\u000d\u000a------ ---------- ----------\u000d\u000a 10 7782 1300\u000d\u000a 10 7839 2450\u000d\u000a 20 7566 6000\u000d\u000a 20 7788 1100\u000d\u000a 20 7839 2975\u000d\u000a 20 7902 800\u000d\u000a 30 7698 6550\u000d\u000a 30 7839 2850\u000d\u000aThe next step is to use the ROLLUP extension to GROUP BY to create subtotals for\u000d\u000aeach DEPTNO and across all employees (who have a manager):\u000d\u000aselect deptno,mgr,sum(sal) sal\u000d\u000a from emp\u000d\u000a where mgr is not null\u000d\u000a432 | Chapter 12: Reporting and Reshaping"," group by deptno,mgr with rollup\u000d\u000aDEPTNO MGR SAL\u000d\u000a------ ---------- ----------\u000d\u000a 10 7782 1300\u000d\u000a 10 7839 2450\u000d\u000a 10 3750\u000d\u000a 20 7566 6000\u000d\u000a 20 7788 1100\u000d\u000a 20 7839 2975\u000d\u000a 20 7902 800\u000d\u000a 20 10875\u000d\u000a 30 7698 6550\u000d\u000a 30 7839 2850\u000d\u000a 30 9400\u000d\u000a 24025\u000d\u000aWith the subtotals created, you need a way to determine which values are in fact sub\u2010\u000d\u000atotals (created by ROLLUP) and which are results of the regular GROUP BY. Use the\u000d\u000aGROUPING function to create bitmaps to help identify the subtotal values from the\u000d\u000aregular aggregate values:\u000d\u000aselect deptno,mgr,sum(sal) sal,\u000d\u000a cast(grouping(deptno) as char(1))+\u000d\u000a cast(grouping(mgr) as char(1)) flag\u000d\u000a from emp\u000d\u000a where mgr is not null\u000d\u000a group by deptno,mgr with rollup\u000d\u000aDEPTNO MGR SAL FLAG\u000d\u000a------ ---------- ---------- ----\u000d\u000a 10 7782 1300 00\u000d\u000a 10 7839 2450 00\u000d\u000a 10 3750 01\u000d\u000a 20 7566 6000 00\u000d\u000a 20 7788 1100 00\u000d\u000a 20 7839 2975 00\u000d\u000a 20 7902 800 00\u000d\u000a 20 10875 01\u000d\u000a 30 7698 6550 00\u000d\u000a 30 7839 2850 00\u000d\u000a 30 9400 01\u000d\u000a 24025 11\u000d\u000aIf it isn\u2019t immediately obvious, the rows with a value of 00 for FLAG are the results of\u000d\u000aregular aggregation. The rows with a value of 01 for FLAG are the results of ROLLUP\u000d\u000aaggregating SAL by DEPTNO (since DEPTNO is listed first in the ROLLUP; if you\u000d\u000aswitch the order, for example, GROUP BY MGR, DEPTNO WITH ROLLUP, you\u2019d\u000d\u000asee quite different results). The row with a value of 11 for FLAG is the result of\u000d\u000aROLLUP aggregating SAL over all rows.\u000d\u000a12.20 Pivoting a Result Set with Subtotals | 433","At this point you have everything you need to create a beautified report by simply\u000d\u000ausing CASE expressions. The goal is to provide a report that shows employee salaries\u000d\u000afor each manager across departments. If a manager does not have any subordinates in\u000d\u000aa particular department, a zero should be returned; otherwise, you want to return the\u000d\u000asum of all salaries for that manager\u2019s subordinates in that department. Additionally,\u000d\u000ayou want to add a final column, TOTAL, representing a sum of all the salaries in the\u000d\u000areport. The solution satisfying all these requirements is shown here:\u000d\u000aselect mgr,\u000d\u000a sum(case deptno when 10 then sal else 0 end) dept10,\u000d\u000a sum(case deptno when 20 then sal else 0 end) dept20,\u000d\u000a sum(case deptno when 30 then sal else 0 end) dept30,\u000d\u000a sum(case flag when '11' then sal else null end) total\u000d\u000a from (\u000d\u000aselect deptno,mgr,sum(sal) sal,\u000d\u000a cast(grouping(deptno) as char(1))+\u000d\u000a cast(grouping(mgr) as char(1)) flag\u000d\u000a from emp\u000d\u000a where mgr is not null\u000d\u000a group by deptno,mgr with rollup\u000d\u000a ) x\u000d\u000a group by mgr\u000d\u000a order by coalesce(mgr,9999)\u000d\u000aMGR DEPT10 DEPT20 DEPT30 TOTAL\u000d\u000a---- ---------- ---------- ---------- ----------\u000d\u000a7566 0 6000 0\u000d\u000a7698 0 0 6550\u000d\u000a7782 1300 0 0\u000d\u000a7788 0 1100 0\u000d\u000a7839 2450 2975 2850\u000d\u000a7902 0 800 0\u000d\u000a 3750 10875 9400 24025\u000d\u000a12.21 Summing Up\u000d\u000aDatabases are for storing data, but eventually someone needs to retrieve the data and\u000d\u000apresent it somewhere. The recipes in this chapter show a variety of important ways\u000d\u000athat data can be re-shaped or formatted to meet the needs of users. Apart from their\u000d\u000ageneral usefulness in giving users data in the form they need, these techniques play an\u000d\u000aimportant role in giving a database owner the ability to create a datawarehouse.\u000d\u000aAs you gain more experience in supporting users in the business, you will become\u000d\u000amore adept and extend the ideas here into more elaborate presentations.\u000d\u000a434 | Chapter 12: Reporting and Reshaping","CHAPTER 13\u000d\u000aHierarchical Queries\u000d\u000aThis chapter introduces recipes for expressing hierarchical relationships that you may\u000d\u000ahave in your data. It is typical when working with hierarchical data to have more dif\u2010\u000d\u000aficulty retrieving and displaying the data (as a hierarchy) than storing it.\u000d\u000aAlthough it\u2019s only been a couple of years since MySQL added recursive CTEs, now\u000d\u000athat they are available it means that recursive CTEs are available in virtually every\u000d\u000aRDBMS. As a result, they are the gold standard for dealing with hierarchical queries,\u000d\u000aand this chapter will make liberal use of this capability to provide recipes to help you\u000d\u000aunravel the hierarchical structure of your data.\u000d\u000aBefore starting, examine table EMP and the hierarchical relationship between\u000d\u000aEMPNO and MGR:\u000d\u000aselect empno,mgr\u000d\u000a from emp\u000d\u000aorder by 2\u000d\u000a EMPNO MGR\u000d\u000a---------- ----------\u000d\u000a 7788 7566\u000d\u000a 7902 7566\u000d\u000a 7499 7698\u000d\u000a 7521 7698\u000d\u000a 7900 7698\u000d\u000a 7844 7698\u000d\u000a 7654 7698\u000d\u000a 7934 7782\u000d\u000a 7876 7788\u000d\u000a 7566 7839\u000d\u000a 7782 7839\u000d\u000a 7698 7839\u000d\u000a 7369 7902\u000d\u000a 7839\u000d\u000a435","If you look carefully, you will see that each value for MGR is also an EMPNO, mean\u2010\u000d\u000aing the manager of each employee in table EMP is also an employee in table EMP and\u000d\u000anot stored somewhere else. The relationship between MGR and EMPNO is a parentchild relationship in that the value for MGR is the most immediate parent for a given\u000d\u000aEMPNO (it is also possible that the manager for a specific employee can have a man\u2010\u000d\u000aager as well, and those managers can in turn have managers, and so on, creating an ntier hierarchy). If an employee has no manager, then MGR is NULL.\u000d\u000a13.1 Expressing a Parent-Child Relationship\u000d\u000aProblem\u000d\u000aYou want to include parent information along with data from child records. For\u000d\u000aexample, you want to display each employee\u2019s name along with the name of their\u000d\u000amanager. You want to return the following result set:\u000d\u000aEMPS_AND_MGRS\u000d\u000a------------------------------\u000d\u000aFORD works for JONES\u000d\u000aSCOTT works for JONES\u000d\u000aJAMES works for BLAKE\u000d\u000aTURNER works for BLAKE\u000d\u000aMARTIN works for BLAKE\u000d\u000aWARD works for BLAKE\u000d\u000aALLEN works for BLAKE\u000d\u000aMILLER works for CLARK\u000d\u000aADAMS works for SCOTT\u000d\u000aCLARK works for KING\u000d\u000aBLAKE works for KING\u000d\u000aJONES works for KING\u000d\u000aSMITH works for FORD\u000d\u000aSolution\u000d\u000aSelf-join EMP on MGR and EMPNO to find the name of each employee\u2019s manager.\u000d\u000aThen use your RDBMS\u2019s supplied function(s) for string concatenation to generate the\u000d\u000astrings in the desired result set.\u000d\u000aDB2, Oracle, and PostgreSQL\u000d\u000aSelf-join on EMP. Then use the double vertical-bar (||) concatenation operator:\u000d\u000a1 select a.ename || ' works for ' || b.ename as emps_and_mgrs\u000d\u000a2 from emp a, emp b\u000d\u000a3 where a.mgr = b.empno\u000d\u000a436 | Chapter 13: Hierarchical Queries","MySQL\u000d\u000aSelf-join on EMP. Then use the concatenation function CONCAT:\u000d\u000a1 select concat(a.ename, ' works for ',b.ename) as emps_and_mgrs\u000d\u000a2 from emp a, emp b\u000d\u000a3 where a.mgr = b.empno\u000d\u000aSQL Server\u000d\u000aSelf-join on EMP. Then use the plus sign (+) as the concatenation operator:\u000d\u000a1 select a.ename + ' works for ' + b.ename as emps_and_mgrs\u000d\u000a2 from emp a, emp b\u000d\u000a3 where a.mgr = b.empno\u000d\u000aDiscussion\u000d\u000aThe implementation is essentially the same for all the solutions. The difference lies\u000d\u000aonly in the method of string concatenation, and thus one discussion will cover all of\u000d\u000athe solutions.\u000d\u000aThe key is the join between MGR and EMPNO. The first step is to build a Cartesian\u000d\u000aproduct by joining EMP to itself (only a portion of the rows returned by the Carte\u2010\u000d\u000asian product is shown here):\u000d\u000aselect a.empno, b.empno\u000d\u000a from emp a, emp b\u000d\u000aEMPNO MGR\u000d\u000a----- ----------\u000d\u000a 7369 7369\u000d\u000a 7369 7499\u000d\u000a 7369 7521\u000d\u000a 7369 7566\u000d\u000a 7369 7654\u000d\u000a 7369 7698\u000d\u000a 7369 7782\u000d\u000a 7369 7788\u000d\u000a 7369 7839\u000d\u000a 7369 7844\u000d\u000a 7369 7876\u000d\u000a 7369 7900\u000d\u000a 7369 7902\u000d\u000a 7369 7934\u000d\u000a 7499 7369\u000d\u000a 7499 7499\u000d\u000a 7499 7521\u000d\u000a 7499 7566\u000d\u000a 7499 7654\u000d\u000a 7499 7698\u000d\u000a 7499 7782\u000d\u000a13.1 Expressing a Parent-Child Relationship | 437"," 7499 7788\u000d\u000a 7499 7839\u000d\u000a 7499 7844\u000d\u000a 7499 7876\u000d\u000a 7499 7900\u000d\u000a 7499 7902\u000d\u000a 7499 7934\u000d\u000aAs you can see, by using a Cartesian product you are returning every possible\u000d\u000aEMPNO/EMPNO combination (such that it looks like the manager for EMPNO 7369\u000d\u000ais all the other employees in the table, including EMPNO 7369).\u000d\u000aThe next step is to filter the results such that you return only each employee and their\u000d\u000amanager\u2019s EMPNO. Accomplish this by joining on MGR and EMPNO:\u000d\u000a1 select a.empno, b.empno mgr\u000d\u000a2 from emp a, emp b\u000d\u000a3 where a.mgr = b.empno\u000d\u000a EMPNO MGR\u000d\u000a---------- ----------\u000d\u000a 7902 7566\u000d\u000a 7788 7566\u000d\u000a 7900 7698\u000d\u000a 7844 7698\u000d\u000a 7654 7698\u000d\u000a 7521 7698\u000d\u000a 7499 7698\u000d\u000a 7934 7782\u000d\u000a 7876 7788\u000d\u000a 7782 7839\u000d\u000a 7698 7839\u000d\u000a 7566 7839\u000d\u000a 7369 7902\u000d\u000aNow that you have each employee and the EMPNO of their manager, you can return\u000d\u000athe name of each manager by simply selecting B.ENAME rather than B.EMPNO. If\u000d\u000aafter some practice you have difficulty grasping how this works, you can use a scalar\u000d\u000asubquery rather than a self-join to get the answer:\u000d\u000aselect a.ename,\u000d\u000a (select b.ename\u000d\u000a from emp b\u000d\u000a where b.empno = a.mgr) as mgr\u000d\u000a from emp a\u000d\u000aENAME MGR\u000d\u000a---------- ----------\u000d\u000aSMITH FORD\u000d\u000aALLEN BLAKE\u000d\u000aWARD BLAKE\u000d\u000aJONES KING\u000d\u000a438 | Chapter 13: Hierarchical Queries","MARTIN BLAKE\u000d\u000aBLAKE KING\u000d\u000aCLARK KING\u000d\u000aSCOTT JONES\u000d\u000aKING\u000d\u000aTURNER BLAKE\u000d\u000aADAMS SCOTT\u000d\u000aJAMES BLAKE\u000d\u000aFORD JONES\u000d\u000aMILLER CLARK\u000d\u000aThe scalar subquery version is equivalent to the self-join, except for one row:\u000d\u000aemployee KING is in the result set, but that is not the case with the self-join. \u201cWhy\u000d\u000anot?\u201d you might ask. Remember, NULL is never equal to anything, not even itself. In\u000d\u000athe self-join solution, you use an equi-join between EMPNO and MGR, thus filtering\u000d\u000aout any employees who have NULL for MGR. To see employee KING when using the\u000d\u000aself-join method, you must outer join as shown in the following two queries. The first\u000d\u000asolution uses the ANSI outer join, while the second uses the Oracle outer-join syntax.\u000d\u000aThe output is the same for both and is shown following the second query:\u000d\u000a/* ANSI */\u000d\u000aselect a.ename, b.ename mgr\u000d\u000a from emp a left join emp b\u000d\u000a on (a.mgr = b.empno)\u000d\u000a/* Oracle */\u000d\u000aselect a.ename, b.ename mgr\u000d\u000a from emp a, emp b\u000d\u000a where a.mgr = b.empno (+)\u000d\u000aENAME MGR\u000d\u000a---------- ----------\u000d\u000aFORD JONES\u000d\u000aSCOTT JONES\u000d\u000aJAMES BLAKE\u000d\u000aTURNER BLAKE\u000d\u000aMARTIN BLAKE\u000d\u000aWARD BLAKE\u000d\u000aALLEN BLAKE\u000d\u000aMILLER CLARK\u000d\u000aADAMS SCOTT\u000d\u000aCLARK KING\u000d\u000aBLAKE KING\u000d\u000aJONES KING\u000d\u000aSMITH FORD\u000d\u000aKING\u000d\u000a13.1 Expressing a Parent-Child Relationship | 439","13.2 Expressing a Child-Parent-Grandparent Relationship\u000d\u000aProblem\u000d\u000aEmployee CLARK works for KING, and to express that relationship you can use the\u000d\u000afirst recipe in this chapter. What if employee CLARK was in turn a manager for\u000d\u000aanother employee? Consider the following query:\u000d\u000aselect ename,empno,mgr\u000d\u000a from emp\u000d\u000a where ename in ('KING','CLARK','MILLER')\u000d\u000aENAME EMPNO MGR\u000d\u000a--------- -------- -------\u000d\u000aCLARK 7782 7839\u000d\u000aKING 7839\u000d\u000aMILLER 7934 7782\u000d\u000aAs you can see, employee MILLER works for CLARK who in turn works for KING.\u000d\u000aYou want to express the full hierarchy from MILLER to KING. You want to return the\u000d\u000afollowing result set:\u000d\u000aLEAF___BRANCH___ROOT\u000d\u000a---------------------\u000d\u000aMILLER-->CLARK-->KING\u000d\u000aHowever, the single self-join approach from the previous recipe will not suffice to\u000d\u000ashow the entire relationship from top to bottom. You could write a query that does\u000d\u000atwo self-joins, but what you really need is a general approach for traversing such\u000d\u000ahierarchies.\u000d\u000aSolution\u000d\u000aThis recipe differs from the first recipe because there is now a three-tier relationship,\u000d\u000aas the title suggests. If your RDBMS does not supply functionality for traversing treestructured data, as is the case for Oracle, then you can solve this problem using the\u000d\u000aCTEs.\u000d\u000aDB2, PostgreSQL, and SQL Server\u000d\u000aUse the recursive WITH clause to find MILLER\u2019s manager, CLARK, and then\u000d\u000aCLARK\u2019s manager, KING. The SQL Server string concatenation operator + is used in\u000d\u000athis solution:\u000d\u000a1 with x (tree,mgr,depth)\u000d\u000a2 as (\u000d\u000a3 select cast(ename as varchar(100)),\u000d\u000a4 mgr, 0\u000d\u000a5 from emp\u000d\u000a440 | Chapter 13: Hierarchical Queries","6 where ename = 'MILLER'\u000d\u000a7 union all\u000d\u000a8 select cast(x.tree+'-->'+e.ename as varchar(100)),\u000d\u000a9 e.mgr, x.depth+1\u000d\u000a10 from emp e, x\u000d\u000a11 where x.mgr = e.empno\u000d\u000a12 )\u000d\u000a13 select tree leaf___branch___root\u000d\u000a14 from x\u000d\u000a15 where depth = 2\u000d\u000aThis solution can work on other databases if the concatenation operator is changed.\u000d\u000aHence, change to || for DB2 or CONCAT for PostgreSQL.\u000d\u000aMySQL\u000d\u000aThis is similar to the previous solution, but also needs the RECURSIVE keyword:\u000d\u000a1 with recursive x (tree,mgr,depth)\u000d\u000a2 as (\u000d\u000a3 select cast(ename as varchar(100)),\u000d\u000a4 mgr, 0\u000d\u000a5 from emp\u000d\u000a6 where ename = 'MILLER'\u000d\u000a7 union all\u000d\u000a8 select cast(concat(x.tree,'-->',emp.ename) as char(100)),\u000d\u000a9 e.mgr, x.depth+1\u000d\u000a10 from emp e, x\u000d\u000a11 where x.mgr = e.empno\u000d\u000a12 )\u000d\u000a13 select tree leaf___branch___root\u000d\u000a14 from x\u000d\u000a15 where depth = 2\u000d\u000aOracle\u000d\u000aUse the function SYS_CONNECT_BY_PATH to return MILLER; MILLER\u2019s manager,\u000d\u000aCLARK; and then CLARK\u2019s manager, KING. Use the CONNECT BY clause to walk\u000d\u000athe tree:\u000d\u000a1 select ltrim(\u000d\u000a2 sys_connect_by_path(ename,'-->'),\u000d\u000a3 '-->') leaf___branch___root\u000d\u000a4 from emp\u000d\u000a5 where level = 3\u000d\u000a6 start with ename = 'MILLER'\u000d\u000a7 connect by prior mgr = empno\u000d\u000a13.2 Expressing a Child-Parent-Grandparent Relationship | 441","Discussion\u000d\u000aDB2, SQL Server, PostgreSQL, and MySQL\u000d\u000aThe approach here is to start at the leaf node and walk your way up to the root (as\u000d\u000auseful practice, try walking in the other direction). The upper part of the UNION\u000d\u000aALL simply finds the row for employee MILLER (the leaf node). The lower part of\u000d\u000athe UNION ALL finds the employee who is MILLER\u2019s manager and then finds that\u000d\u000aperson\u2019s manager, and this process of finding the \u201cmanager\u2019s manager\u201d repeats until\u000d\u000aprocessing stops at the highest-level manager (the root node). The value for DEPTH\u000d\u000astarts at 0 and increments automatically by 1 each time a manager is found. DEPTH\u000d\u000ais a value that DB2 maintains for you when you execute a recursive query.\u000d\u000aFor an interesting and in-depth introduction to the WITH clause\u000d\u000awith a focus on its use recursively, see Jonathan Gennick\u2019s article\u000d\u000a\u201cUnderstanding the WITH Clause\u201d.\u000d\u000aNext, the second query of the UNION ALL joins the recursive view X to table EMP,\u000d\u000ato define the parent-child relationship. The query at this point, using SQL Server\u2019s\u000d\u000aconcatenation operator, is as follows:\u000d\u000a with x (tree,mgr,depth)\u000d\u000a as (\u000d\u000aselect cast(ename as varchar(100)),\u000d\u000a mgr, 0\u000d\u000a from emp\u000d\u000a where ename = 'MILLER'\u000d\u000a union all\u000d\u000aselect cast(x.tree+'-->'+e.ename as varchar(100)),\u000d\u000a e.mgr, x.depth+1\u000d\u000a from emp e, x\u000d\u000a where x.mgr = e.empno\u000d\u000a)\u000d\u000aselect tree leaf___branch___root\u000d\u000a from x\u000d\u000aTREE DEPTH\u000d\u000a---------- ----------\u000d\u000aMILLER 0\u000d\u000aCLARK 1\u000d\u000aKING 2\u000d\u000aAt this point, the heart of the problem has been solved; starting from MILLER, return\u000d\u000athe full hierarchical relationship from bottom to top. What\u2019s left then is merely for\u2010\u000d\u000amatting. Since the tree traversal is recursive, simply concatenate the current ENAME\u000d\u000afrom EMP to the one before it, which gives you the following result set:\u000d\u000a442 | Chapter 13: Hierarchical Queries"," with x (tree,mgr,depth)\u000d\u000a as (\u000d\u000aselect cast(ename as varchar(100)),\u000d\u000a mgr, 0\u000d\u000a from emp\u000d\u000a where ename = 'MILLER'\u000d\u000a union all\u000d\u000aselect cast(x.tree+'-->'+e.ename as varchar(100)),\u000d\u000a e.mgr, x.depth+1\u000d\u000a from emp e, x\u000d\u000a where x.mgr = e.empno\u000d\u000a)\u000d\u000aselect depth, tree\u000d\u000a from x\u000d\u000aDEPTH TREE\u000d\u000a----- ---------------------------\u000d\u000a 0 MILLER\u000d\u000a 1 MILLER-->CLARK\u000d\u000a 2 MILLER-->CLARK-->KING\u000d\u000aThe final step is to keep only the last row in the hierarchy. There are several ways to\u000d\u000ado this, but the solution uses DEPTH to determine when the root is reached (obvi\u2010\u000d\u000aously, if CLARK has a manager other than KING, the filter on DEPTH would have to\u000d\u000achange; for a more generic solution that requires no such filter, see the next recipe).\u000d\u000aOracle\u000d\u000aThe CONNECT BY clause does all the work in the Oracle solution. Starting with\u000d\u000aMILLER, you walk all the way to KING without the need for any joins. The expres\u2010\u000d\u000asion in the CONNECT BY clause defines the relationship of the data and how the tree\u000d\u000awill be walked:\u000d\u000a select ename\u000d\u000a from emp\u000d\u000a start with ename = 'MILLER'\u000d\u000aconnect by prior mgr = empno\u000d\u000aENAME\u000d\u000a--------\u000d\u000aMILLER\u000d\u000aCLARK\u000d\u000aKING\u000d\u000aThe keyword PRIOR lets you access values from the previous record in the hierarchy.\u000d\u000aThus, for any given EMPNO, you can use PRIOR MGR to access that employee\u2019s\u000d\u000amanager number. When you see a clause such as CONNECT BY PRIOR MGR =\u000d\u000aEMPNO, think of that clause as expressing a join between, in this case, parent and\u000d\u000achild.\u000d\u000a13.2 Expressing a Child-Parent-Grandparent Relationship | 443","For more on CONNECT BY and its use in hierarchical queries,\u000d\u000a\u201cHierarchical Queries in Oracle\u201d is a good overview.\u000d\u000aAt this point, you have successfully displayed the full hierarchy starting from\u000d\u000aMILLER and ending at KING. The problem is for the most part solved. All that\u000d\u000aremains is the formatting. Use the function SYS_CONNECT_BY_PATH to append\u000d\u000aeach ENAME to the one before it:\u000d\u000a select sys_connect_by_path(ename,'-->') tree\u000d\u000a from emp\u000d\u000a start with ename = 'MILLER'\u000d\u000aconnect by prior mgr = empno\u000d\u000aTREE\u000d\u000a---------------------------\u000d\u000a-->MILLER\u000d\u000a-->MILLER-->CLARK\u000d\u000a-->MILLER-->CLARK-->KING\u000d\u000aBecause you are interested in only the complete hierarchy, you can filter on the\u000d\u000apseudo-column LEVEL (a more generic approach is shown in the next recipe):\u000d\u000a select sys_connect_by_path(ename,'-->') tree\u000d\u000a from emp\u000d\u000a where level = 3\u000d\u000a start with ename = 'MILLER'\u000d\u000aconnect by prior mgr = empno\u000d\u000aTREE\u000d\u000a---------------------------\u000d\u000a-->MILLER-->CLARK-->KING\u000d\u000aThe final step is to use the LTRIM function to remove the leading --> from the result\u000d\u000aset.\u000d\u000a13.3 Creating a Hierarchical View of a Table\u000d\u000aProblem\u000d\u000aYou want to return a result set that describes the hierarchy of an entire table. In the\u000d\u000acase of the EMP table, employee KING has no manager, so KING is the root node.\u000d\u000aYou want to display, starting from KING, all employees under KING and all employ\u2010\u000d\u000aees (if any) under KING\u2019s subordinates. Ultimately, you want to return the following\u000d\u000aresult set:\u000d\u000a444 | Chapter 13: Hierarchical Queries","EMP_TREE\u000d\u000a------------------------------\u000d\u000aKING\u000d\u000aKING - BLAKE\u000d\u000aKING - BLAKE - ALLEN\u000d\u000aKING - BLAKE - JAMES\u000d\u000aKING - BLAKE - MARTIN\u000d\u000aKING - BLAKE - TURNER\u000d\u000aKING - BLAKE - WARD\u000d\u000aKING - CLARK\u000d\u000aKING - CLARK - MILLER\u000d\u000aKING - JONES\u000d\u000aKING - JONES - FORD\u000d\u000aKING - JONES - FORD - SMITH\u000d\u000aKING - JONES - SCOTT\u000d\u000aKING - JONES - SCOTT - ADAMS\u000d\u000aSolution\u000d\u000aDB2, PostgreSQL, and SQL Server\u000d\u000aUse the recursive WITH clause to start building the hierarchy at KING and then ulti\u2010\u000d\u000amately display all the employees. The solution following uses the DB2 concatenation\u000d\u000aoperator (||). SQL Server users use the concatenation operator (+), and MySQL uses\u000d\u000athe CONCAT function. Other than the concatenation operators, the solution will\u000d\u000awork as-is on both RDBMSs:\u000d\u000a 1 with x (ename,empno)\u000d\u000a 2 as (\u000d\u000a 3 select cast(ename as varchar(100)),empno\u000d\u000a 4 from emp\u000d\u000a 5 where mgr is null\u000d\u000a 6 union all\u000d\u000a 7 select cast(x.ename||' - '||e.ename as varchar(100)),\u000d\u000a 8 e.empno\u000d\u000a 9 from emp e, x\u000d\u000a10 where e.mgr = x.empno\u000d\u000a11 )\u000d\u000a12 select ename as emp_tree\u000d\u000a13 from x\u000d\u000a14 order by 1\u000d\u000aMySQL\u000d\u000aMySQL also needs the RECURSIVE keyword:\u000d\u000a 1 with recursive x (ename,empno)\u000d\u000a 2 as (\u000d\u000a 3 select cast(ename as varchar(100)),empno\u000d\u000a 4 from emp\u000d\u000a 5 where mgr is null\u000d\u000a13.3 Creating a Hierarchical View of a Table | 445"," 6 union all\u000d\u000a 7 select cast(concat(x.ename,' - ',e.ename) as varchar(100)),\u000d\u000a 8 e.empno\u000d\u000a 9 from emp e, x\u000d\u000a10 where e.mgr = x.empno\u000d\u000a11 )\u000d\u000a12 select ename as emp_tree\u000d\u000a13 from x\u000d\u000a14 order by 1\u000d\u000aOracle\u000d\u000aUse the CONNECT BY function to define the hierarchy. Use the SYS_CON\u2010\u000d\u000aNECT_BY_PATH function to format the output accordingly:\u000d\u000a1 select ltrim(\u000d\u000a2 sys_connect_by_path(ename,' - '),\u000d\u000a3 ' - ') emp_tree\u000d\u000a4 from emp\u000d\u000a5 start with mgr is null\u000d\u000a6 connect by prior empno=mgr\u000d\u000a7 order by 1\u000d\u000aThis solution differs from the previous recipe in that it includes no filter on the\u000d\u000aLEVEL pseudo-column. Without the filter, all possible trees (where PRIOR\u000d\u000aEMPNO=MGR) are displayed.\u000d\u000aDiscussion\u000d\u000aDB2, MySQL, PostgreSQL, and SQL Server\u000d\u000aThe first step is to identify the root row (employee KING) in the upper part of the\u000d\u000aUNION ALL in the recursive view X. The next step is to find KING\u2019s subordinates,\u000d\u000aand their subordinates if there are any, by joining recursive view X to table EMP.\u000d\u000aRecursion will continue until you\u2019ve returned all employees. Without the formatting\u000d\u000ayou see in the final result set, the result set returned by the recursive view X is shown\u000d\u000ahere:\u000d\u000awith x (ename,empno)\u000d\u000a as (\u000d\u000aselect cast(ename as varchar(100)),empno\u000d\u000a from emp\u000d\u000a where mgr is null\u000d\u000a union all\u000d\u000aselect cast(e.ename as varchar(100)),e.empno\u000d\u000a from emp e, x\u000d\u000a where e.mgr = x.empno\u000d\u000a )\u000d\u000a select ename emp_tree\u000d\u000a from x\u000d\u000a446 | Chapter 13: Hierarchical Queries"," EMP_TREE\u000d\u000a ----------------\u000d\u000a KING\u000d\u000a JONES\u000d\u000a SCOTT\u000d\u000a ADAMS\u000d\u000a FORD\u000d\u000a SMITH\u000d\u000a BLAKE\u000d\u000a ALLEN\u000d\u000a WARD\u000d\u000a MARTIN\u000d\u000a TURNER\u000d\u000a JAMES\u000d\u000a CLARK\u000d\u000a MILLER\u000d\u000aAll the rows in the hierarchy are returned (which can be useful), but without the for\u2010\u000d\u000amatting you cannot tell who the managers are. By concatenating each employee to\u000d\u000aher manager, you return more meaningful output. Produce the desired output simply\u000d\u000aby using the following:\u000d\u000acast(x.ename+','+e.ename as varchar(100))\u000d\u000ain the SELECT clause of the lower portion of the UNION ALL in recursive view X.\u000d\u000aThe WITH clause is extremely useful in solving this type of problem, because the\u000d\u000ahierarchy can change (for example, leaf nodes become branch nodes) without any\u000d\u000aneed to modify the query.\u000d\u000aOracle\u000d\u000aThe CONNECT BY clause returns the rows in the hierarchy. The START WITH\u000d\u000aclause defines the root row. If you run the solution without SYS_CON\u2010\u000d\u000aNECT_BY_PATH, you can see that the correct rows are returned (which can be use\u2010\u000d\u000aful), but not formatted to express the relationship of the rows:\u000d\u000aselect ename emp_tree\u000d\u000a from emp\u000d\u000a start with mgr is null\u000d\u000aconnect by prior empno = mgr\u000d\u000aEMP_TREE\u000d\u000a-----------------\u000d\u000aKING\u000d\u000aJONES\u000d\u000aSCOTT\u000d\u000aADAMS\u000d\u000aFORD\u000d\u000aSMITH\u000d\u000aBLAKE\u000d\u000aALLEN\u000d\u000a13.3 Creating a Hierarchical View of a Table | 447","WARD\u000d\u000aMARTIN\u000d\u000aTURNER\u000d\u000aJAMES\u000d\u000aCLARK\u000d\u000aMILLER\u000d\u000aBy using the pseudo-column LEVEL and the function LPAD, you can see the hierar\u2010\u000d\u000achy more clearly, and you can ultimately see why SYS_CONNECT_BY_PATH\u000d\u000areturns the results that you see in the desired output shown earlier:\u000d\u000aselect lpad('.',2*level,'.')||ename emp_tree\u000d\u000a from emp\u000d\u000a start with mgr is null\u000d\u000aconnect by prior empno = mgr\u000d\u000aEMP_TREE\u000d\u000a-----------------\u000d\u000a..KING\u000d\u000a....JONES\u000d\u000a......SCOTT\u000d\u000a........ADAMS\u000d\u000a......FORD\u000d\u000a........SMITH\u000d\u000a....BLAKE\u000d\u000a......ALLEN\u000d\u000a......WARD\u000d\u000a......MARTIN\u000d\u000a......TURNER\u000d\u000a......JAMES\u000d\u000a....CLARK\u000d\u000a......MILLER\u000d\u000aThe indentation in this output indicates who the managers are by nesting subordi\u2010\u000d\u000anates under their superiors. For example, KING works for no one. JONES works for\u000d\u000aKING. SCOTT works for JONES. ADAMS works for SCOTT.\u000d\u000aIf you look at the corresponding rows from the solution when using SYS_CON\u2010\u000d\u000aNECT_BY_PATH, you will see that SYS_CONNECT_BY_PATH rolls up the hierar\u2010\u000d\u000achy for you. When you get to a new node, you see all the prior nodes as well:\u000d\u000aKING\u000d\u000aKING - JONES\u000d\u000aKING - JONES - SCOTT\u000d\u000aKING - JONES - SCOTT - ADAMS\u000d\u000a448 | Chapter 13: Hierarchical Queries","13.4 Finding All Child Rows for a Given Parent Row\u000d\u000aProblem\u000d\u000aYou want to find all the employees who work for JONES, either directly or indirectly\u000d\u000a(i.e., they work for someone who works for JONES). The list of employees under\u000d\u000aJONES is shown here (JONES is included in the result set):\u000d\u000aENAME\u000d\u000a----------\u000d\u000aJONES\u000d\u000aSCOTT\u000d\u000aADAMS\u000d\u000aFORD\u000d\u000aSMITH\u000d\u000aSolution\u000d\u000aBeing able to move to the absolute top or bottom of a tree is extremely useful. For this\u000d\u000asolution, there is no special formatting necessary. The goal is to simply return all\u000d\u000aemployees who work under employee JONES, including JONES himself. This type of\u000d\u000aquery really shows the usefulness of recursive SQL extensions like Oracle\u2019s CON\u2010\u000d\u000aNECT BY and SQL Server\u2019s/DB2\u2019s WITH clause.\u000d\u000aDB2, PostgreSQL, and SQL Server\u000d\u000aUse the recursive WITH clause to find all employees under JONES. Begin with\u000d\u000aJONES by specifying WHERE ENAME = JONES in the first of the two union queries:\u000d\u000a 1 with x (ename,empno)\u000d\u000a 2 as (\u000d\u000a 3 select ename,empno\u000d\u000a 4 from emp\u000d\u000a 5 where ename = 'JONES'\u000d\u000a 6 union all\u000d\u000a 7 select e.ename, e.empno\u000d\u000a 8 from emp e, x\u000d\u000a 9 where x.empno = e.mgr\u000d\u000a10 )\u000d\u000a11 select ename\u000d\u000a12 from x\u000d\u000aOracle\u000d\u000aUse the CONNECT BY clause and specify START WITH ENAME = JONES to find\u000d\u000aall the employees under JONES:\u000d\u000a1 select ename\u000d\u000a2 from emp\u000d\u000a13.4 Finding All Child Rows for a Given Parent Row | 449","3 start with ename = 'JONES'\u000d\u000a4 connect by prior empno = mgr\u000d\u000aDiscussion\u000d\u000aDB2, MySQL, PostgreSQL, and SQL Server\u000d\u000aThe recursive WITH clause makes this a relatively easy problem to solve. The first\u000d\u000apart of the WITH clause, the upper part of the UNION ALL, returns the row for\u000d\u000aemployee JONES. You need to return ENAME to see the name and EMPNO so you\u000d\u000acan use it to join on. The lower part of the UNION ALL recursively joins EMP.MGR\u000d\u000ato X.EMPNO. The join condition will be applied until the result set is exhausted.\u000d\u000aOracle\u000d\u000aThe START WTH clause tells the query to make JONES the root node. The condition\u000d\u000ain the CONNECT BY clause drives the tree walk and will run until the condition is\u000d\u000ano longer true.\u000d\u000a13.5 Determining Which Rows Are Leaf, Branch, or\u000d\u000aRoot Nodes\u000d\u000aProblem\u000d\u000aYou want to determine what type of node a given row is: a leaf, branch, or root. For\u000d\u000athis example, a leaf node is an employee who is not a manager. A branch node is an\u000d\u000aemployee who is both a manager and also has a manager. A root node is an employee\u000d\u000awithout a manager. You want to return 1 (TRUE) or 0 (FALSE) to reflect the status of\u000d\u000aeach row in the hierarchy. You want to return the following result set:\u000d\u000aENAME IS_LEAF IS_BRANCH IS_ROOT\u000d\u000a---------- ---------- ---------- ----------\u000d\u000aKING 0 0 1\u000d\u000aJONES 0 1 0\u000d\u000aSCOTT 0 1 0\u000d\u000aFORD 0 1 0\u000d\u000aCLARK 0 1 0\u000d\u000aBLAKE 0 1 0\u000d\u000aADAMS 1 0 0\u000d\u000aMILLER 1 0 0\u000d\u000aJAMES 1 0 0\u000d\u000aTURNER 1 0 0\u000d\u000aALLEN 1 0 0\u000d\u000aWARD 1 0 0\u000d\u000aMARTIN 1 0 0\u000d\u000aSMITH 1 0 0\u000d\u000a450 | Chapter 13: Hierarchical Queries","Solution\u000d\u000aIt is important to realize that the EMP table is modeled in a tree hierarchy, not a\u000d\u000arecursive hierarchy, and the value for MGR for root nodes is NULL. If EMP were\u000d\u000amodeled to use a recursive hierarchy, root nodes would be self-referencing (i.e., the\u000d\u000avalue for MGR for employee KING would be KING\u2019s EMPNO). We find selfreferencing to be counterintuitive and thus are using NULL values for root nodes\u2019\u000d\u000aMGR. For Oracle users using CONNECT BY and DB2/SQL Server users using\u000d\u000aWITH, you\u2019ll find tree hierarchies easier to work with and potentially more efficient\u000d\u000athan recursive hierarchies. If you are in a situation where you have a recursive hierar\u2010\u000d\u000achy and are using CONNECT BY or WITH, watch out: you can end up with a loop in\u000d\u000ayour SQL. You need to code around such loops if you are stuck with recursive\u000d\u000ahierarchies.\u000d\u000aDB2, PostgreSQL, MySQL, and SQL Server\u000d\u000aUse three scalar subqueries to determine the correct \u201cBoolean\u201d value (either a 1 or a\u000d\u000a0) to return for each node type:\u000d\u000a 1 select e.ename,\u000d\u000a 2 (select sign(count(*)) from emp d\u000d\u000a 3 where 0 =\u000d\u000a 4 (select count(*) from emp f\u000d\u000a 5 where f.mgr = e.empno)) as is_leaf,\u000d\u000a 6 (select sign(count(*)) from emp d\u000d\u000a 7 where d.mgr = e.empno\u000d\u000a 8 and e.mgr is not null) as is_branch,\u000d\u000a 9 (select sign(count(*)) from emp d\u000d\u000a10 where d.empno = e.empno\u000d\u000a11 and d.mgr is null) as is_root\u000d\u000a12 from emp e\u000d\u000a13 order by 4 desc,3 desc\u000d\u000aOracle\u000d\u000aThe scalar subquery solution will work for Oracle as well and should be used if you\u000d\u000aare on a version of Oracle prior to Oracle Database 10g. The following solution high\u2010\u000d\u000alights built-in functions provided by Oracle (that were introduced in Oracle Database\u000d\u000a10g) to identify root and leaf rows. The functions are CONNECT_BY_ROOT and\u000d\u000aCONNECT_BY_ISLEAF, respectively:\u000d\u000a 1 select ename,\u000d\u000a 2 connect_by_isleaf is_leaf,\u000d\u000a 3 (select count(*) from emp e\u000d\u000a 4 where e.mgr = emp.empno\u000d\u000a 5 and emp.mgr is not null\u000d\u000a 6 and rownum = 1) is_branch,\u000d\u000a 7 decode(ename,connect_by_root(ename),1,0) is_root\u000d\u000a 8 from emp\u000d\u000a13.5 Determining Which Rows Are Leaf, Branch, or Root Nodes | 451"," 9 start with mgr is null\u000d\u000a10 connect by prior empno = mgr\u000d\u000a11 order by 4 desc, 3 desc\u000d\u000aDiscussion\u000d\u000aDB2, PostgreSQL, MySQL, and SQL Server\u000d\u000aThis solution simply applies the rules defined in the \u201cProblem\u201d section to determine\u000d\u000aleaves, branches, and roots. The first step is to determine whether an employee is a\u000d\u000aleaf node. If the employee is not a manager (no one works under them), then she is a\u000d\u000aleaf node. The first scalar subquery, IS_LEAF, is shown here:\u000d\u000aselect e.ename,\u000d\u000a (select sign(count(*)) from emp d\u000d\u000a where 0 =\u000d\u000a (select count(*) from emp f\u000d\u000a where f.mgr = e.empno)) as is_leaf\u000d\u000a from emp e\u000d\u000aorder by 2 desc\u000d\u000aENAME IS_LEAF\u000d\u000a----------- --------\u000d\u000aSMITH 1\u000d\u000aALLEN 1\u000d\u000aWARD 1\u000d\u000aADAMS 1\u000d\u000aTURNER 1\u000d\u000aMARTIN 1\u000d\u000aJAMES 1\u000d\u000aMILLER 1\u000d\u000aJONES 0\u000d\u000aBLAKE 0\u000d\u000aCLARK 0\u000d\u000aFORD 0\u000d\u000aSCOTT 0\u000d\u000aKING 0\u000d\u000aBecause the output for IS_LEAF should be a 0 or 1, it is necessary to take the SIGN of\u000d\u000athe COUNT(*) operation. Otherwise, you would get 14 instead of 1 for leaf rows. As\u000d\u000aan alternative, you can use a table with only one row to count against, because you\u000d\u000aonly want to return 0 or 1. For example:\u000d\u000aselect e.ename,\u000d\u000a (select count(*) from t1 d\u000d\u000a where not exists\u000d\u000a (select null from emp f\u000d\u000a where f.mgr = e.empno)) as is_leaf\u000d\u000a from emp e\u000d\u000aorder by 2 desc\u000d\u000a452 | Chapter 13: Hierarchical Queries","ENAME IS_LEAF\u000d\u000a---------- ----------\u000d\u000aSMITH 1\u000d\u000aALLEN 1\u000d\u000aWARD 1\u000d\u000aADAMS 1\u000d\u000aTURNER 1\u000d\u000aMARTIN 1\u000d\u000aJAMES 1\u000d\u000aMILLER 1\u000d\u000aJONES 0\u000d\u000aBLAKE 0\u000d\u000aCLARK 0\u000d\u000aFORD 0\u000d\u000aSCOTT 0\u000d\u000aKING 0\u000d\u000aThe next step is to find branch nodes. If an employee is a manager (someone works\u000d\u000afor them) and they also happen to work for someone else, then the employee is a\u000d\u000abranch node. The results of the scalar subquery IS_BRANCH are shown here:\u000d\u000aselect e.ename,\u000d\u000a (select sign(count(*)) from emp d\u000d\u000a where d.mgr = e.empno\u000d\u000a and e.mgr is not null) as is_branch\u000d\u000a from emp e\u000d\u000aorder by 2 desc\u000d\u000aENAME IS_BRANCH\u000d\u000a----------- ---------\u000d\u000aJONES 1\u000d\u000aBLAKE 1\u000d\u000aSCOTT 1\u000d\u000aCLARK 1\u000d\u000aFORD 1\u000d\u000aSMITH 0\u000d\u000aTURNER 0\u000d\u000aMILLER 0\u000d\u000aJAMES 0\u000d\u000aADAMS 0\u000d\u000aKING 0\u000d\u000aALLEN 0\u000d\u000aMARTIN 0\u000d\u000aWARD 0\u000d\u000aAgain, it is necessary to take the SIGN of the COUNT(*) operation. Otherwise, you\u000d\u000awill get (potentially) values greater than 1 when a node is a branch. Like scalar sub\u2010\u000d\u000aquery IS_LEAF, you can use a table with one row to avoid using SIGN. The following\u000d\u000asolution uses the T1 table:\u000d\u000a13.5 Determining Which Rows Are Leaf, Branch, or Root Nodes | 453","select e.ename,\u000d\u000a (select count(*) from t1 t\u000d\u000a where exists (\u000d\u000a select null from emp f\u000d\u000a where f.mgr = e.empno\u000d\u000a and e.mgr is not null)) as is_branch\u000d\u000a from emp e\u000d\u000aorder by 2 desc\u000d\u000aENAME IS_BRANCH\u000d\u000a--------------- ----------\u000d\u000aJONES 1\u000d\u000aBLAKE 1\u000d\u000aSCOTT 1\u000d\u000aCLARK 1\u000d\u000aFORD 1\u000d\u000aSMITH 0\u000d\u000aTURNER 0\u000d\u000aMILLER 0\u000d\u000aJAMES 0\u000d\u000aADAMS 0\u000d\u000aKING 0\u000d\u000aALLEN 0\u000d\u000aMARTIN 0\u000d\u000aWARD 0\u000d\u000aThe last step is to find the root nodes. A root node is defined as an employee who is a\u000d\u000amanager but who does not work for anyone else. In table EMP, only KING is a root\u000d\u000anode. Scalar subquery IS_ROOT is shown here:\u000d\u000aselect e.ename,\u000d\u000a (select sign(count(*)) from emp d\u000d\u000a where d.empno = e.empno\u000d\u000a and d.mgr is null) as is_root\u000d\u000a from emp e\u000d\u000aorder by 2 desc\u000d\u000aENAME IS_ROOT\u000d\u000a---------- ---------\u000d\u000aKING 1\u000d\u000aSMITH 0\u000d\u000aALLEN 0\u000d\u000aWARD 0\u000d\u000aJONES 0\u000d\u000aTURNER 0\u000d\u000aJAMES 0\u000d\u000aMILLER 0\u000d\u000aFORD 0\u000d\u000aADAMS 0\u000d\u000aMARTIN 0\u000d\u000a454 | Chapter 13: Hierarchical Queries","BLAKE 0\u000d\u000aCLARK 0\u000d\u000aSCOTT 0\u000d\u000aBecause EMP is a small 14-row table, it is easy to see that employee KING is the only\u000d\u000aroot node, so in this case taking the SIGN of the COUNT(*) operation is not strictly\u000d\u000anecessary. If there can be multiple root nodes, then you can use SIGN, or you can use\u000d\u000aa one-row table in the scalar subquery as is shown earlier for IS_BRANCH and\u000d\u000aIS_LEAF.\u000d\u000aOracle\u000d\u000aFor those of you on versions of Oracle prior to Oracle Database 10g, you can follow\u000d\u000athe discussion for the other RDBMSs, as that solution will work (without modifica\u2010\u000d\u000ations) in Oracle. If you are on Oracle Database 10g or later, you may want to take\u000d\u000aadvantage of two functions to make identifying root and leaf nodes a simple task:\u000d\u000athey are CONNECT_BY_ROOT and CONNECT_BY_ISLEAF, respectively. As of the\u000d\u000atime of this writing, it is necessary to use CONNECT BY in your SQL statement in\u000d\u000aorder for you to be able to use CONNECT_BY_ROOT and CONNECT_BY_ISLEAF.\u000d\u000aThe first step is to find the leaf nodes by using CONNECT_BY_ISLEAF as follows:\u000d\u000aselect ename,\u000d\u000a connect_by_isleaf is_leaf\u000d\u000a from emp\u000d\u000a start with mgr is null\u000d\u000aconnect by prior empno = mgr\u000d\u000aorder by 2 desc\u000d\u000aENAME IS_LEAF\u000d\u000a---------- ----------\u000d\u000aADAMS 1\u000d\u000aSMITH 1\u000d\u000aALLEN 1\u000d\u000aTURNER 1\u000d\u000aMARTIN 1\u000d\u000aWARD 1\u000d\u000aJAMES 1\u000d\u000aMILLER 1\u000d\u000aKING 0\u000d\u000aJONES 0\u000d\u000aBLAKE 0\u000d\u000aCLARK 0\u000d\u000aFORD 0\u000d\u000aSCOTT 0\u000d\u000aThe next step is to use a scalar subquery to find the branch nodes. Branch nodes are\u000d\u000aemployees who are managers but who also work for someone else:\u000d\u000a13.5 Determining Which Rows Are Leaf, Branch, or Root Nodes | 455","select ename,\u000d\u000a (select count(*) from emp e\u000d\u000a where e.mgr = emp.empno\u000d\u000a and emp.mgr is not null\u000d\u000a and rownum = 1) is_branch\u000d\u000a from emp\u000d\u000a start with mgr is null\u000d\u000aconnect by prior empno = mgr\u000d\u000aorder by 2 desc\u000d\u000aENAME IS_BRANCH\u000d\u000a---------- ----------\u000d\u000aJONES 1\u000d\u000aSCOTT 1\u000d\u000aBLAKE 1\u000d\u000aFORD 1\u000d\u000aCLARK 1\u000d\u000aKING 0\u000d\u000aMARTIN 0\u000d\u000aMILLER 0\u000d\u000aJAMES 0\u000d\u000aTURNER 0\u000d\u000aWARD 0\u000d\u000aADAMS 0\u000d\u000aALLEN 0\u000d\u000aSMITH 0\u000d\u000aThe filter on ROWNUM is necessary to ensure that you return a count of 1 or 0, and\u000d\u000anothing else.\u000d\u000aThe last step is to identify the root nodes by using the function CON\u2010\u000d\u000aNECT_BY_ROOT. The solution finds the ENAME for the root node and compares it\u000d\u000awith all the rows returned by the query. If there is a match, that row is the root node:\u000d\u000aselect ename,\u000d\u000a decode(ename,connect_by_root(ename),1,0) is_root\u000d\u000a from emp\u000d\u000a start with mgr is null\u000d\u000aconnect by prior empno = mgr\u000d\u000aorder by 2 desc\u000d\u000aENAME IS_ROOT\u000d\u000a---------- ----------\u000d\u000aKING 1\u000d\u000aJONES 0\u000d\u000aSCOTT 0\u000d\u000aADAMS 0\u000d\u000aFORD 0\u000d\u000aSMITH 0\u000d\u000aBLAKE 0\u000d\u000aALLEN 0\u000d\u000aWARD 0\u000d\u000a456 | Chapter 13: Hierarchical Queries","MARTIN 0\u000d\u000aTURNER 0\u000d\u000aJAMES 0\u000d\u000aCLARK 0\u000d\u000aMILLER 0\u000d\u000aThe SYS_CONNECT_BY_PATH function rolls up a hierarchy starting from the root\u000d\u000avalue, as shown here:\u000d\u000aselect ename,\u000d\u000a ltrim(sys_connect_by_path(ename,','),',') path\u000d\u000a from emp\u000d\u000astart with mgr is null\u000d\u000aconnect by prior empno=mgr\u000d\u000aENAME PATH\u000d\u000a---------- ----------------------------\u000d\u000aKING KING\u000d\u000aJONES KING,JONES\u000d\u000aSCOTT KING,JONES,SCOTT\u000d\u000aADAMS KING,JONES,SCOTT,ADAMS\u000d\u000aFORD KING,JONES,FORD\u000d\u000aSMITH KING,JONES,FORD,SMITH\u000d\u000aBLAKE KING,BLAKE\u000d\u000aALLEN KING,BLAKE,ALLEN\u000d\u000aWARD KING,BLAKE,WARD\u000d\u000aMARTIN KING,BLAKE,MARTIN\u000d\u000aTURNER KING,BLAKE,TURNER\u000d\u000aJAMES KING,BLAKE,JAMES\u000d\u000aCLARK KING,CLARK\u000d\u000aMILLER KING,CLARK,MILLER\u000d\u000aTo get the root row, simply substring out the first ENAME in PATH:\u000d\u000aselect ename,\u000d\u000a substr(root,1,instr(root,',')-1) root\u000d\u000a from (\u000d\u000aselect ename,\u000d\u000a ltrim(sys_connect_by_path(ename,','),',') root\u000d\u000a from emp\u000d\u000astart with mgr is null\u000d\u000aconnect by prior empno=mgr\u000d\u000a )\u000d\u000aENAME ROOT\u000d\u000a---------- ----------\u000d\u000aKING\u000d\u000aJONES KING\u000d\u000aSCOTT KING\u000d\u000aADAMS KING\u000d\u000aFORD KING\u000d\u000aSMITH KING\u000d\u000aBLAKE KING\u000d\u000a13.5 Determining Which Rows Are Leaf, Branch, or Root Nodes | 457","ALLEN KING\u000d\u000aWARD KING\u000d\u000aMARTIN KING\u000d\u000aTURNER KING\u000d\u000aJAMES KING\u000d\u000aCLARK KING\u000d\u000aMILLER KING\u000d\u000aThe last step is to flag the result from the ROOT column; if it is NULL, that is your\u000d\u000aroot row.\u000d\u000a13.6 Summing Up\u000d\u000aThe spread of CTEs across all vendors has made standardized approaches to hier\u2010\u000d\u000aarchical queries far more achievable. This a great step forward as hierarchical rela\u2010\u000d\u000ationships appear in many kinds of data, even data where the relationship isn\u2019t neces\u2010\u000d\u000asarily planned for, so queries need to account for it.\u000d\u000a458 | Chapter 13: Hierarchical Queries","CHAPTER 14\u000d\u000aOdds \u2019n\u2019 Ends\u000d\u000aThis chapter contains queries that didn\u2019t fit in any other chapter, either because the\u000d\u000achapter they would belong to is already long enough, or because the problems they\u000d\u000asolve are more fun than realistic. This chapter is meant to be a \u201cfun\u201d chapter, in that\u000d\u000athe recipes here may or may not be recipes that you would actually use; nevertheless,\u000d\u000athe queries are interesting, and we wanted to include them in this book.\u000d\u000a14.1 Creating Cross-Tab Reports Using SQL Server\u2019s PIVOT\u000d\u000aOperator\u000d\u000aProblem\u000d\u000aYou want to create a cross-tab report to transform your result set\u2019s rows into columns.\u000d\u000aYou are aware of traditional methods of pivoting but would like to try something dif\u2010\u000d\u000aferent. In particular, you want to return the following result set without using CASE\u000d\u000aexpressions or joins:\u000d\u000aDEPT_10 DEPT_20 DEPT_30 DEPT_40\u000d\u000a------- ----------- ----------- ----------\u000d\u000a 3 5 6 0\u000d\u000aSolution\u000d\u000aUse the PIVOT operator to create the required result set without CASE expressions\u000d\u000aor additional joins:\u000d\u000a1 select [10] as dept_10,\u000d\u000a2 [20] as dept_20,\u000d\u000a3 [30] as dept_30,\u000d\u000a4 [40] as dept_40\u000d\u000a5 from (select deptno, empno from emp) driver\u000d\u000a459","6 pivot (\u000d\u000a7 count(driver.empno)\u000d\u000a8 for driver.deptno in ( [10],[20],[30],[40] )\u000d\u000a9 ) as empPivot\u000d\u000aDiscussion\u000d\u000aThe PIVOT operator may seem strange at first, but the operation it performs in the\u000d\u000asolution is technically the same as the more familiar transposition query shown here:\u000d\u000aselect sum(case deptno when 10 then 1 else 0 end) as dept_10,\u000d\u000a sum(case deptno when 20 then 1 else 0 end) as dept_20,\u000d\u000a sum(case deptno when 30 then 1 else 0 end) as dept_30,\u000d\u000a sum(case deptno when 40 then 1 else 0 end) as dept_40\u000d\u000a from emp\u000d\u000aDEPT_10 DEPT_20 DEPT_30 DEPT_40\u000d\u000a------- ---------- ---------- ----------\u000d\u000a 3 5 6 0\u000d\u000aNow that you know what is essentially happening, let\u2019s break down what the PIVOT\u000d\u000aoperator is doing. Line 5 of the solution shows an inline view named DRIVER:\u000d\u000afrom (select deptno, empno from emp) driver\u000d\u000aWe\u2019ve used the alias DRIVER because the rows from this inline view (or table expres\u2010\u000d\u000asion) feed directly into the PIVOT operation. The PIVOT operator rotates the rows to\u000d\u000acolumns by evaluating the items listed on line 8 in the FOR list (shown here):\u000d\u000afor driver.deptno in ( [10],[20],[30],[40] )\u000d\u000aThe evaluation goes something like this:\u000d\u000a1. If there are any DEPTNOs with a value of 10, perform the aggregate operation\u000d\u000adefined (COUNT(DRIVER.EMPNO)) for those rows.\u000d\u000a2. Repeat for DEPTNOs 20, 30, and 40.\u000d\u000aThe items listed in the brackets on line 8 serve not only to define values for which\u000d\u000aaggregation is performed; the items also become the column names in the result set\u000d\u000a(without the square brackets). In the SELECT clause of the solution, the items in the\u000d\u000aFOR list are referenced and aliased. If you do not alias the items in the FOR list, the\u000d\u000acolumn names become the items in the FOR list sans brackets.\u000d\u000aInterestingly enough, since inline view DRIVER is just that\u2014an inline view\u2014you\u000d\u000amay put more complex SQL in there. For example, consider the situation where you\u000d\u000awant to modify the result set such that the actual department name is the name of the\u000d\u000acolumn. Listed here are the rows in table DEPT:\u000d\u000a460 | Chapter 14: Odds \u2019n\u2019 Ends","select * from dept\u000d\u000aDEPTNO DNAME LOC\u000d\u000a------ -------------- -------------\u000d\u000a 10 ACCOUNTING NEW YORK\u000d\u000a 20 RESEARCH DALLAS\u000d\u000a 30 SALES CHICAGO\u000d\u000a 40 OPERATIONS BOSTON\u000d\u000aYou want to use PIVOT to return the following result set:\u000d\u000aACCOUNTING RESEARCH SALES OPERATIONS\u000d\u000a---------- ---------- ---------- ----------\u000d\u000a 3 5 6 0\u000d\u000aBecause inline view DRIVER can be practically any valid table expression, you can\u000d\u000aperform the join from table EMP to table DEPT and then have PIVOT evaluate those\u000d\u000arows. The following query will return the desired result set:\u000d\u000aselect [ACCOUNTING] as ACCOUNTING,\u000d\u000a [SALES] as SALES,\u000d\u000a [RESEARCH] as RESEARCH,\u000d\u000a [OPERATIONS] as OPERATIONS\u000d\u000a from (\u000d\u000a select d.dname, e.empno\u000d\u000a from emp e,dept d\u000d\u000a where e.deptno=d.deptno\u000d\u000a ) driver\u000d\u000a pivot (\u000d\u000a count(driver.empno)\u000d\u000a for driver.dname in ([ACCOUNTING],[SALES],[RESEARCH],[OPERATIONS])\u000d\u000a ) as empPivot\u000d\u000aAs you can see, PIVOT provides an interesting spin on pivoting result sets. Regard\u2010\u000d\u000aless of whether you prefer using it to the traditional methods of pivoting, it\u2019s nice to\u000d\u000ahave another tool in your toolbox.\u000d\u000a14.2 Unpivoting a Cross-Tab Report Using SQL Server\u2019s\u000d\u000aUNPIVOT Operator\u000d\u000aProblem\u000d\u000aYou have a pivoted result set (or simply a fact table), and you want to unpivot the\u000d\u000aresult set. For example, instead of having a result set with one row and four columns,\u000d\u000ayou want to return a result set with two columns and four rows. Using the result set\u000d\u000afrom the previous recipe, you want to convert it from this:\u000d\u000a14.2 Unpivoting a Cross-Tab Report Using SQL Server\u2019s UNPIVOT Operator | 461","ACCOUNTING RESEARCH SALES OPERATIONS\u000d\u000a---------- ---------- ---------- ----------\u000d\u000a 3 5 6 0\u000d\u000ato this:\u000d\u000aDNAME CNT\u000d\u000a-------------- ----------\u000d\u000aACCOUNTING 3\u000d\u000aRESEARCH 5\u000d\u000aSALES 6\u000d\u000aOPERATIONS 0\u000d\u000aSolution\u000d\u000aYou didn\u2019t think SQL Server would give you the ability to PIVOT without being able\u000d\u000ato UNPIVOT, did you? To unpivot the result set, just use it as the driver and let the\u000d\u000aUNPIVOT operator do all the work. All you need to do is specify the column names:\u000d\u000a 1 select DNAME, CNT\u000d\u000a 2 from (\u000d\u000a 3 select [ACCOUNTING] as ACCOUNTING,\u000d\u000a 4 [SALES] as SALES,\u000d\u000a 5 [RESEARCH] as RESEARCH,\u000d\u000a 6 [OPERATIONS] as OPERATIONS\u000d\u000a 7 from (\u000d\u000a 8 select d.dname, e.empno\u000d\u000a 9 from emp e,dept d\u000d\u000a10 where e.deptno=d.deptno\u000d\u000a11\u000d\u000a12 ) driver\u000d\u000a13 pivot (\u000d\u000a14 count(driver.empno)\u000d\u000a15 for driver.dname in ([ACCOUNTING],[SALES],[RESEARCH],[OPERATIONS])\u000d\u000a16 ) as empPivot\u000d\u000a17 ) new_driver\u000d\u000a18 unpivot (cnt for dname in (ACCOUNTING,SALES,RESEARCH,OPERATIONS)\u000d\u000a19 ) as un_pivot\u000d\u000aIdeally, before reading this recipe you\u2019ve read the one prior to it, because the inline\u000d\u000aview NEW_DRIVER is simply the code from the previous recipe (if you don\u2019t under\u2010\u000d\u000astand it, please refer to the previous recipe before looking at this one). Since lines 3\u2013\u000d\u000a16 consist of code you\u2019ve already seen, the only new syntax is on line 18, where you\u000d\u000ause UNPIVOT.\u000d\u000aThe UNPIVOT command simply looks at the result set from NEW_DRIVER and\u000d\u000aevaluates each column and row. For example, the UNPIVOT operator evaluates the\u000d\u000acolumn names from NEW_DRIVER. When it encounters ACCOUNTING, it trans\u2010\u000d\u000aforms the column name ACCOUNTING into a row value (under the column\u000d\u000aDNAME). It also takes the value for ACCOUNTING from NEW_DRIVER (which is\u000d\u000a3) and returns that as part of the ACCOUNTING row as well (under the column\u000d\u000a462 | Chapter 14: Odds \u2019n\u2019 Ends","CNT). UNPIVOT does this for each of the items specified in the FOR list and simply\u000d\u000areturns each one as a row.\u000d\u000aThe new result set is now skinny and has two columns, DNAME and CNT, with four\u000d\u000arows:\u000d\u000aselect DNAME, CNT\u000d\u000a from (\u000d\u000a select [ACCOUNTING] as ACCOUNTING,\u000d\u000a [SALES] as SALES,\u000d\u000a [RESEARCH] as RESEARCH,\u000d\u000a [OPERATIONS] as OPERATIONS\u000d\u000a from (\u000d\u000a select d.dname, e.empno\u000d\u000a from emp e,dept d\u000d\u000a where e.deptno=d.deptno\u000d\u000a ) driver\u000d\u000a pivot (\u000d\u000a count(driver.empno)\u000d\u000a for driver.dname in ( [ACCOUNTING],[SALES],[RESEARCH],[OPERATIONS] )\u000d\u000a ) as empPivot\u000d\u000a) new_driver\u000d\u000aunpivot (cnt for dname in (ACCOUNTING,SALES,RESEARCH,OPERATIONS)\u000d\u000a) as un_pivot\u000d\u000aDNAME CNT\u000d\u000a-------------- ----------\u000d\u000aACCOUNTING 3\u000d\u000aRESEARCH 5\u000d\u000aSALES 6\u000d\u000aOPERATIONS 0\u000d\u000a14.3 Transposing a Result Set Using Oracle\u2019s MODEL\u000d\u000aClause\u000d\u000aProblem\u000d\u000aLike the first recipe in this chapter, you want to find an alternative to the traditional\u000d\u000apivoting techniques you\u2019ve seen already. You want to try your hand at Oracle\u2019s\u000d\u000aMODEL clause. Unlike SQL Server\u2019s PIVOT operator, Oracle\u2019s MODEL clause does\u000d\u000anot exist to transpose result sets; as a matter of fact, it would be quite accurate to say\u000d\u000athe application of the MODEL clause for pivoting would be a misuse and clearly not\u000d\u000awhat the MODEL clause was intended for. Nevertheless, the MODEL clause provides\u000d\u000afor an interesting approach to a common problem. For this particular problem, you\u000d\u000awant to transform the following result set from this:\u000d\u000a14.3 Transposing a Result Set Using Oracle\u2019s MODEL Clause | 463","select deptno, count(*) cnt\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000aDEPTNO CNT\u000d\u000a------ ----------\u000d\u000a 10 3\u000d\u000a 20 5\u000d\u000a 30 6\u000d\u000ato this:\u000d\u000a D10 D20 D30\u000d\u000a---------- ---------- ----------\u000d\u000a 3 5 6\u000d\u000aSolution\u000d\u000aUse aggregation and CASE expressions in the MODEL clause just as you would use\u000d\u000athem if pivoting with traditional techniques. The main difference in this case is that\u000d\u000ayou use arrays to store the values of the aggregation and return the arrays in the result\u000d\u000aset:\u000d\u000aselect max(d10) d10,\u000d\u000a max(d20) d20,\u000d\u000a max(d30) d30\u000d\u000a from (\u000d\u000aselect d10,d20,d30\u000d\u000a from ( select deptno, count(*) cnt from emp group by deptno )\u000d\u000a model\u000d\u000a dimension by(deptno d)\u000d\u000a measures(deptno, cnt d10, cnt d20, cnt d30)\u000d\u000a rules(\u000d\u000a d10[any] = case when deptno[cv()]=10 then d10[cv()] else 0 end,\u000d\u000a d20[any] = case when deptno[cv()]=20 then d20[cv()] else 0 end,\u000d\u000a d30[any] = case when deptno[cv()]=30 then d30[cv()] else 0 end\u000d\u000a )\u000d\u000a )\u000d\u000aDiscussion\u000d\u000aThe MODEL clause is a powerful addition to the Oracle SQL toolbox. Once you\u000d\u000abegin working with MODEL, you\u2019ll notice helpful features such as iteration, array\u000d\u000aaccess to row values, the ability to \u201cupsert\u201d rows into a result set, and the ability to\u000d\u000abuild reference models. You\u2019ll quickly see that this recipe doesn\u2019t take advantage of\u000d\u000aany of the cool features the MODEL clause offers, but it\u2019s nice to be able to look at a\u000d\u000aproblem from multiple angles and use different features in unexpected ways (if for no\u000d\u000aother reason than to learn where certain features are more useful than others).\u000d\u000a464 | Chapter 14: Odds \u2019n\u2019 Ends","The first step to understanding the solution is to examine the inline view in the\u000d\u000aFROM clause. The inline view simply counts the number of employees in each\u000d\u000aDEPTNO in table EMP. The results are shown here:\u000d\u000aselect deptno, count(*) cnt\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000aDEPTNO CNT\u000d\u000a------ ----------\u000d\u000a 10 3\u000d\u000a 20 5\u000d\u000a 30 6\u000d\u000aThis result set is what is given to MODEL to work with. Examining the MODEL\u000d\u000aclause, you see three subclauses that stand out: DIMENSION BY, MEASURES, and\u000d\u000aRULES. Let\u2019s start with MEASURES.\u000d\u000aThe items in the MEASURES list are simply the arrays you are declaring for this\u000d\u000aquery. The query uses four arrays: DEPTNO, D10, D20, and D30. Like columns in a\u000d\u000aSELECT list, arrays in the MEASURES list can have aliases. As you can see, three of\u000d\u000athe four arrays are actually CNT from the inline view.\u000d\u000aIf the MEASURES list contains our arrays, then the items in the DIMENSION BY\u000d\u000asubclause are the array indices. Consider this: array D10 is simply an alias for CNT. If\u000d\u000ayou look at the result set for the previous inline view, you\u2019ll see that CNT has three\u000d\u000avalues: 3, 5, and 6. When you create an array of CNT, you are creating an array with\u000d\u000athree elements, namely, the three integers: 3, 5, and 6. Now, how do you access these\u000d\u000avalues from the array individually? You use the array index. The index, defined in the\u000d\u000aDIMENSION BY subclause, has the values of 10, 20, and 30 (from the result set\u000d\u000aabove). So, for example, the following expression:\u000d\u000ad10[10]\u000d\u000awould evaluate to 3, as you are accessing the value for CNT in array D10 for\u000d\u000aDEPTNO 10 (which is 3).\u000d\u000aBecause all three arrays (D10, D20, D30) contain the values from CNT, all three of\u000d\u000athem have the same results. How then do we get the proper count into the correct\u000d\u000aarray? Enter the RULES subclause. If you look at the result set for the inline view\u000d\u000ashown earlier, you\u2019ll see that the values for DEPTNO are 10, 20, and 30. The expres\u2010\u000d\u000asions involving CASE in the RULES clause simply evaluate each value in the\u000d\u000aDEPTNO array:\u000d\u000a\u2022 If the value is 10, store the CNT for DEPTNO 10 in D10[10] or else store 0.\u000d\u000a\u2022 If the value is 20, store the CNT for DEPTNO 20 in D20[20] or else store 0.\u000d\u000a\u2022 If the value is 30, store the CNT for DEPTNO 30 in D30[30] or else store 0.\u000d\u000a14.3 Transposing a Result Set Using Oracle\u2019s MODEL Clause | 465","If you find yourself feeling a bit like Alice tumbling down the rabbit hole, don\u2019t\u000d\u000aworry; just stop and execute what\u2019s been discussed thus far. The following result set\u000d\u000arepresents what has been discussed. Sometimes it\u2019s easier to read a bit, look at the\u000d\u000acode that actually performs what you just read, and then go back and read it again.\u000d\u000aThe following is quite simple once you see it in action:\u000d\u000aselect deptno, d10,d20,d30\u000d\u000a from ( select deptno, count(*) cnt from emp group by deptno )\u000d\u000a model\u000d\u000a dimension by(deptno d)\u000d\u000a measures(deptno, cnt d10, cnt d20, cnt d30)\u000d\u000a rules(\u000d\u000a d10[any] = case when deptno[cv()]=10 then d10[cv()] else 0 end,\u000d\u000a d20[any] = case when deptno[cv()]=20 then d20[cv()] else 0 end,\u000d\u000a d30[any] = case when deptno[cv()]=30 then d30[cv()] else 0 end\u000d\u000a )\u000d\u000a DEPTNO D10 D20 D30\u000d\u000a ------ ---------- ---------- ----------\u000d\u000a 10 3 0 0\u000d\u000a 20 0 5 0\u000d\u000a 30 0 0 6\u000d\u000aAs you can see, the RULES subclause is what changed the values in each array. If you\u000d\u000aare still not catching on, simply execute the same query but comment out the expres\u2010\u000d\u000asions in the RULES subclass:\u000d\u000aselect deptno, d10,d20,d30\u000d\u000a from ( select deptno, count(*) cnt from emp group by deptno )\u000d\u000a model\u000d\u000a dimension by(deptno d)\u000d\u000a measures(deptno, cnt d10, cnt d20, cnt d30)\u000d\u000a rules(\u000d\u000a /*\u000d\u000a d10[any] = case when deptno[cv()]=10 then d10[cv()] else 0 end,\u000d\u000a d20[any] = case when deptno[cv()]=20 then d20[cv()] else 0 end,\u000d\u000a d30[any] = case when deptno[cv()]=30 then d30[cv()] else 0 end\u000d\u000a */\u000d\u000a )\u000d\u000a DEPTNO D10 D20 D30\u000d\u000a ------ ---------- ---------- ----------\u000d\u000a 10 3 3 3\u000d\u000a 20 5 5 5\u000d\u000a 30 6 6 6\u000d\u000aIt should be clear now that the result set from the MODEL clause is the same as the\u000d\u000ainline view, except that the COUNT operation is aliased D10, D20, and D30. The fol\u2010\u000d\u000alowing query proves this:\u000d\u000a466 | Chapter 14: Odds \u2019n\u2019 Ends","select deptno, count(*) d10, count(*) d20, count(*) d30\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000a DEPTNO D10 D20 D30\u000d\u000a ------ ---------- ---------- ----------\u000d\u000a 10 3 3 3\u000d\u000a 20 5 5 5\u000d\u000a 30 6 6 6\u000d\u000aSo, all the MODEL clause did was to take the values for DEPTNO and CNT, put them\u000d\u000ainto arrays, and then make sure that each array represents a single DEPTNO. At this\u000d\u000apoint, arrays D10, D20, and D30 each have a single nonzero value representing the\u000d\u000aCNT for a given DEPTNO. The result set is already transposed, and all that is left is\u000d\u000ato use the aggregate function MAX (you could have used MIN or SUM; it would\u000d\u000amake no difference in this case) to return only one row:\u000d\u000aselect max(d10) d10,\u000d\u000a max(d20) d20,\u000d\u000a max(d30) d30\u000d\u000a from (\u000d\u000aselect d10,d20,d30\u000d\u000a from ( select deptno, count(*) cnt from emp group by deptno )\u000d\u000a model\u000d\u000a dimension by(deptno d)\u000d\u000a measures(deptno, cnt d10, cnt d20, cnt d30)\u000d\u000a rules(\u000d\u000a d10[any] = case when deptno[cv()]=10 then d10[cv()] else 0 end,\u000d\u000a d20[any] = case when deptno[cv()]=20 then d20[cv()] else 0 end,\u000d\u000a d30[any] = case when deptno[cv()]=30 then d30[cv()] else 0 end\u000d\u000a )\u000d\u000a )\u000d\u000a D10 D20 D30\u000d\u000a ---------- ---------- ----------\u000d\u000a 3 5 6\u000d\u000a14.4 Extracting Elements of a String from Unfixed\u000d\u000aLocations\u000d\u000aProblem\u000d\u000aYou have a string field that contains serialized log data. You want to parse through the\u000d\u000astring and extract the relevant information. Unfortunately, the relevant information is\u000d\u000anot at fixed points in the string. Instead, you must use the fact that certain characters\u000d\u000aexist around the information you need, to extract said information. For example,\u000d\u000aconsider the following strings:\u000d\u000a14.4 Extracting Elements of a String from Unfixed Locations | 467","xxxxxabc[867]xxx[-]xxxx[5309]xxxxx\u000d\u000axxxxxtime:[11271978]favnum:[4]id:[Joe]xxxxx\u000d\u000acall:[F_GET_ROWS()]b1:[ROSEWOOD\u2026SIR]b2:[44400002]77.90xxxxx\u000d\u000afilm:[non_marked]qq:[unit]tailpipe:[withabanana?]80sxxxxx\u000d\u000aYou want to extract the values between the square brackets, returning the following\u000d\u000aresult set:\u000d\u000aFIRST_VAL SECOND_VAL LAST_VAL\u000d\u000a--------------- ------------------- ---------------\u000d\u000a867 - 5309\u000d\u000a11271978 4 Joe\u000d\u000aF_GET_ROWS() ROSEWOOD\u2026SIR 44400002\u000d\u000anon_marked unit withabanana?\u000d\u000aSolution\u000d\u000aDespite not knowing the exact locations within the string of the interesting values,\u000d\u000ayou do know that they are located between square brackets [], and you know there\u000d\u000aare three of them. Use Oracle\u2019s built-in function INSTR to find the locations of the\u000d\u000abrackets. Use the built-in function SUBSTR to extract the values from the string.\u000d\u000aView V will contain the strings to parse and is defined as follows (its use is strictly for\u000d\u000areadability):\u000d\u000acreate view V\u000d\u000aas\u000d\u000aselect 'xxxxxabc[867]xxx[-]xxxx[5309]xxxxx' msg\u000d\u000a from dual\u000d\u000a union all\u000d\u000a select 'xxxxxtime:[11271978]favnum:[4]id:[Joe]xxxxx' msg\u000d\u000a from dual\u000d\u000a union all\u000d\u000a select 'call:[F_GET_ROWS()]b1:[ROSEWOOD\u2026SIR]b2:[44400002]77.90xxxxx' msg\u000d\u000a from dual\u000d\u000a union all\u000d\u000a select 'film:[non_marked]qq:[unit]tailpipe:[withabanana?]80sxxxxx' msg\u000d\u000a from dual\u000d\u000a 1 select substr(msg,\u000d\u000a 2 instr(msg,'[',1,1)+1,\u000d\u000a 3 instr(msg,']',1,1)-instr(msg,'[',1,1)-1) first_val,\u000d\u000a 4 substr(msg,\u000d\u000a 5 instr(msg,'[',1,2)+1,\u000d\u000a 6 instr(msg,']',1,2)-instr(msg,'[',1,2)-1) second_val,\u000d\u000a 7 substr(msg,\u000d\u000a 8 instr(msg,'[',-1,1)+1,\u000d\u000a 9 instr(msg,']',-1,1)-instr(msg,'[',-1,1)-1) last_val\u000d\u000a10 from V\u000d\u000a468 | Chapter 14: Odds \u2019n\u2019 Ends","Discussion\u000d\u000aUsing Oracle\u2019s built-in function INSTR makes this problem fairly simple to solve.\u000d\u000aSince you know the values you are after are enclosed in [], and that there are three\u000d\u000asets of [], the first step to this solution is to simply use INSTR to find the numeric\u000d\u000apositions of [] in each string. The following example returns the numeric position of\u000d\u000athe opening and closing brackets in each row:\u000d\u000aselect instr(msg,'[',1,1) \"1st_[\",\u000d\u000a instr(msg,']',1,1) \"]_1st\",\u000d\u000a instr(msg,'[',1,2) \"2nd_[\",\u000d\u000a instr(msg,']',1,2) \"]_2nd\",\u000d\u000a instr(msg,'[',-1,1) \"3rd_[\",\u000d\u000a instr(msg,']',-1,1) \"]_3rd\"\u000d\u000a from V\u000d\u000a 1st_[ ]_1st 2nd_[ ]_2nd 3rd_[ ]_3rd\u000d\u000a ------ ----- ---------- ----- ---------- -----\u000d\u000a 9 13 17 19 24 29\u000d\u000a 11 20 28 30 34 38\u000d\u000a 6 19 23 38 42 51\u000d\u000a 6 17 21 26 36 49\u000d\u000aAt this point, the hard work is done. All that is left is to plug the numeric positions\u000d\u000ainto SUBSTR to parse MSG at those locations. You\u2019ll notice that in the complete solu\u2010\u000d\u000ation there\u2019s some simple arithmetic on the values returned by INSTR, particularly, +1\u000d\u000aand \u20131; this is necessary to ensure the opening square bracket, [, is not returned in\u000d\u000athe final result set. Listed here is the solution less addition and subtraction of 1 on the\u000d\u000areturn values from INSTR; notice how each value has a leading square bracket:\u000d\u000aselect substr(msg,\u000d\u000a instr(msg,'[',1,1),\u000d\u000a instr(msg,']',1,1)-instr(msg,'[',1,1)) first_val,\u000d\u000a substr(msg,\u000d\u000a instr(msg,'[',1,2),\u000d\u000a instr(msg,']',1,2)-instr(msg,'[',1,2)) second_val,\u000d\u000a substr(msg,\u000d\u000a instr(msg,'[',-1,1),\u000d\u000a instr(msg,']',-1,1)-instr(msg,'[',-1,1)) last_val\u000d\u000a from V\u000d\u000aFIRST_VAL SECOND_VAL LAST_VAL\u000d\u000a--------------- -------------------- -------\u000d\u000a[867 [- [5309\u000d\u000a[11271978 [4 [Joe\u000d\u000a[F_GET_ROWS() [ROSEWOOD\u2026SIR [44400002\u000d\u000a[non_marked [unit [withabanana?\u000d\u000aFrom the previous result set, you can see that the open bracket is there. You may be\u000d\u000athinking: \u201cOK, put the addition of 1 to INSTR back and the leading square bracket\u000d\u000agoes away. Why do we need to subtract 1?\u201d The reason is this: if you put the addition\u000d\u000a14.4 Extracting Elements of a String from Unfixed Locations | 469","back but leave out the subtraction, you end up including the closing square bracket,\u000d\u000aas shown here:\u000d\u000aselect substr(msg,\u000d\u000a instr(msg,'[',1,1)+1,\u000d\u000a instr(msg,']',1,1)-instr(msg,'[',1,1)) first_val,\u000d\u000a substr(msg,\u000d\u000a instr(msg,'[',1,2)+1,\u000d\u000a instr(msg,']',1,2)-instr(msg,'[',1,2)) second_val,\u000d\u000a substr(msg,\u000d\u000a instr(msg,'[',-1,1)+1,\u000d\u000a instr(msg,']',-1,1)-instr(msg,'[',-1,1)) last_val\u000d\u000a from V\u000d\u000aFIRST_VAL SECOND_VAL LAST_VAL\u000d\u000a--------------- --------------- -------------\u000d\u000a867] -] 5309]\u000d\u000a11271978] 4] Joe]\u000d\u000aF_GET_ROWS()] ROSEWOOD\u2026SIR] 44400002]\u000d\u000anon_marked] unit] withabanana?]\u000d\u000aAt this point it should be clear: to ensure you include neither of the square brackets,\u000d\u000ayou must add one to the beginning index and subtract one from the ending index.\u000d\u000a14.5 Finding the Number of Days in a Year (an Alternate\u000d\u000aSolution for Oracle)\u000d\u000aProblem\u000d\u000aYou want to find the number of days in a year.\u000d\u000aThis recipe presents an alternative solution to \u201cDetermining the\u000d\u000aNumber of Days in a Year\u201d from Chapter 9. This solution is specific\u000d\u000ato Oracle.\u000d\u000aSolution\u000d\u000aUse the TO_CHAR function to format the last date of the year into a three-digit dayof-the-year number:\u000d\u000a1 select 'Days in 2021: '||\u000d\u000a2 to_char(add_months(trunc(sysdate,'y'),12)-1,'DDD')\u000d\u000a3 as report\u000d\u000a4 from dual\u000d\u000a5 union all\u000d\u000a6 select 'Days in 2020: '||\u000d\u000a7 to_char(add_months(trunc(\u000d\u000a470 | Chapter 14: Odds \u2019n\u2019 Ends","8 to_date('01-SEP-2020'),'y'),12)-1,'DDD')\u000d\u000a9 from dual\u000d\u000aREPORT\u000d\u000a-----------------\u000d\u000aDays in 2021: 365\u000d\u000aDays in 2020: 366\u000d\u000aDiscussion\u000d\u000aBegin by using the TRUNC function to return the first day of the year for the given\u000d\u000adate, as follows:\u000d\u000aselect trunc(to_date('01-SEP-2020'),'y')\u000d\u000a from dual\u000d\u000aTRUNC(TO_DA\u000d\u000a-----------\u000d\u000a01-JAN-2020\u000d\u000aNext, use ADD_MONTHS to add one year (12 months) to the truncated date. Then\u000d\u000asubtract one day, bringing you to the end of the year in which your original date falls:\u000d\u000aselect add_months(\u000d\u000a trunc(to_date('01-SEP-2020'),'y'),\u000d\u000a 12) before_subtraction,\u000d\u000a add_months(\u000d\u000a trunc(to_date('01-SEP-2020'),'y'),\u000d\u000a 12)-1 after_subtraction\u000d\u000a from dual\u000d\u000aBEFORE_SUBT AFTER_SUBTR\u000d\u000a----------- -----------\u000d\u000a01-JAN-2021 31-DEC-2020\u000d\u000aNow that you have found the last day in the year you are working with, simply use\u000d\u000aTO_CHAR to return a three-digit number representing on which day (1st, 50th, etc.)\u000d\u000aof the year the last day is:\u000d\u000aselect to_char(\u000d\u000a add_months(\u000d\u000a trunc(to_date('01-SEP-2020'),'y'),\u000d\u000a 12)-1,'DDD') num_days_in_2020\u000d\u000a from dual\u000d\u000aNUM\u000d\u000a---\u000d\u000a366\u000d\u000a14.5 Finding the Number of Days in a Year (an Alternate Solution for Oracle) | 471","14.6 Searching for Mixed Alphanumeric Strings\u000d\u000aProblem\u000d\u000aYou have a column with mixed alphanumeric data. You want to return those rows\u000d\u000athat have both alphabetical and numeric characters; in other words, if a string has\u000d\u000aonly number or only letters, do not return it. The return values should have a mix of\u000d\u000aboth letters and numbers. Consider the following data:\u000d\u000aSTRINGS\u000d\u000a------------\u000d\u000a1010 switch\u000d\u000a333\u000d\u000a3453430278\u000d\u000aClassSummary\u000d\u000afindRow 55\u000d\u000athrees\u000d\u000aThe final result set should contain only those rows that have both letters and\u000d\u000anumbers:\u000d\u000aSTRINGS\u000d\u000a------------\u000d\u000a1010 switch\u000d\u000afindRow 55\u000d\u000aSolution\u000d\u000aUse the built-in function TRANSLATE to convert each occurrence of a letter or digit\u000d\u000ainto a specific character. Then keep only those strings that have at least one occur\u2010\u000d\u000arence of both. The solution uses Oracle syntax, but both DB2 and PostgreSQL sup\u2010\u000d\u000aport TRANSLATE, so modifying the solution to work on those platforms should be\u000d\u000atrivial:\u000d\u000a with v as (\u000d\u000a select 'ClassSummary' strings from dual union\u000d\u000a select '3453430278' from dual union\u000d\u000a select 'findRow 55' from dual union\u000d\u000a select '1010 switch' from dual union\u000d\u000a select '333' from dual union\u000d\u000a select 'threes' from dual\u000d\u000a )\u000d\u000a select strings\u000d\u000a from (\u000d\u000a select strings,\u000d\u000a translate(\u000d\u000a strings,\u000d\u000a 'abcdefghijklmnopqrstuvwxyz0123456789',\u000d\u000a rpad('#',26,'#')||rpad('*',10,'*')) translated\u000d\u000a from v\u000d\u000a472 | Chapter 14: Odds \u2019n\u2019 Ends",") x\u000d\u000awhereinstr(translated,'#') > 0\u000d\u000aand instr(translated,'*') > 0\u000d\u000aAs an alternative to the WITH clause, you may use an inline view\u000d\u000aor simply create a view.\u000d\u000aDiscussion\u000d\u000aThe TRANSLATE function makes this problem extremely easy to solve. The first step\u000d\u000ais to use TRANSLATE to identify all letters and all digits by pound (#) and asterisk\u000d\u000a(*) characters, respectively. The intermediate results (from inline view X) are as\u000d\u000afollows:\u000d\u000awith v as (\u000d\u000aselect 'ClassSummary' strings from dual union\u000d\u000aselect '3453430278' from dual union\u000d\u000aselect 'findRow 55' from dual union\u000d\u000aselect '1010 switch' from dual union\u000d\u000aselect '333' from dual union\u000d\u000aselect 'threes' from dual\u000d\u000a)\u000d\u000aselect strings,\u000d\u000a translate(\u000d\u000a strings,\u000d\u000a 'abcdefghijklmnopqrstuvwxyz0123456789',\u000d\u000a rpad('#',26,'#')||rpad('*',10,'*')) translated\u000d\u000a from v\u000d\u000aSTRINGS TRANSLATED\u000d\u000a------------- ------------\u000d\u000a1010 switch **** ######\u000d\u000a333 ***\u000d\u000a3453430278 **********\u000d\u000aClassSummary C####S######\u000d\u000afindRow 55 ####R## **\u000d\u000athrees ######\u000d\u000aAt this point, it is only a matter of keeping those rows that have at least one instance\u000d\u000aeach of # and *. Use the function INSTR to determine whether # and * are in a string.\u000d\u000aIf those two characters are, in fact, present, then the value returned will be greater\u000d\u000athan zero. The final strings to return, along with their translated values, are shown\u000d\u000anext for clarity:\u000d\u000awith v as (\u000d\u000aselect 'ClassSummary' strings from dual union\u000d\u000aselect '3453430278' from dual union\u000d\u000aselect 'findRow 55' from dual union\u000d\u000a14.6 Searching for Mixed Alphanumeric Strings | 473","select '1010 switch' from dual union\u000d\u000aselect '333' from dual union\u000d\u000aselect 'threes' from dual\u000d\u000a)\u000d\u000aselect strings, translated\u000d\u000a from (\u000d\u000aselect strings,\u000d\u000a translate(\u000d\u000a strings,\u000d\u000a 'abcdefghijklmnopqrstuvwxyz0123456789',\u000d\u000a rpad('#',26,'#')||rpad('*',10,'*')) translated\u000d\u000a from v\u000d\u000a )\u000d\u000a where instr(translated,'#') > 0\u000d\u000a and instr(translated,'*') > 0\u000d\u000aSTRINGS TRANSLATED\u000d\u000a------------ ------------\u000d\u000a1010 switch **** ######\u000d\u000afindRow 55 ####R## **\u000d\u000a14.7 Converting Whole Numbers to Binary Using Oracle\u000d\u000aProblem\u000d\u000aYou want to convert a whole number to its binary representation on an Oracle sys\u2010\u000d\u000atem. For example, you would like to return all the salaries in table EMP in binary as\u000d\u000apart of the following result set:\u000d\u000aENAME SAL SAL_BINARY\u000d\u000a---------- ----- --------------------\u000d\u000aSMITH 800 1100100000\u000d\u000aALLEN 1600 11001000000\u000d\u000aWARD 1250 10011100010\u000d\u000aJONES 2975 101110011111\u000d\u000aMARTIN 1250 10011100010\u000d\u000aBLAKE 2850 101100100010\u000d\u000aCLARK 2450 100110010010\u000d\u000aSCOTT 3000 101110111000\u000d\u000aKING 5000 1001110001000\u000d\u000aTURNER 1500 10111011100\u000d\u000aADAMS 1100 10001001100\u000d\u000aJAMES 950 1110110110\u000d\u000aFORD 3000 101110111000\u000d\u000aMILLER 1300 10100010100\u000d\u000aSolution\u000d\u000aBecause of MODEL\u2019s ability to iterate and provide array access to row values, it is a\u000d\u000anatural choice for this operation (assuming you are forced to solve the problem in\u000d\u000a474 | Chapter 14: Odds \u2019n\u2019 Ends","SQL, as a stored function is more appropriate here). Like the rest of the solutions in\u000d\u000athis book, even if you don\u2019t find a practical application for this code, focus on the\u000d\u000atechnique. It is useful to know that the MODEL clause can perform procedural tasks\u000d\u000awhile still keeping SQL\u2019s set-based nature and power. So, even if you find yourself say\u2010\u000d\u000aing, \u201cI\u2019d never do this in SQL,\u201d that\u2019s fine. We\u2019re in no way suggesting you should or\u000d\u000ashouldn\u2019t. We remind you to focus on the technique, so you can apply it to whatever\u000d\u000ayou consider a more \u201cpractical\u201d application.\u000d\u000aThe following solution returns all ENAME and SAL from table EMP, while calling the\u000d\u000aMODEL clause in a scalar subquery (this way it serves as sort of a standalone func\u2010\u000d\u000ation from table EMP that simply receives an input, processes it, and returns a value,\u000d\u000amuch like a function would):\u000d\u000a 1 select ename,\u000d\u000a 2 sal,\u000d\u000a 3 (\u000d\u000a 4 select bin\u000d\u000a 5 from dual\u000d\u000a 6 model\u000d\u000a 7 dimension by ( 0 attr )\u000d\u000a 8 measures ( sal num,\u000d\u000a 9 cast(null as varchar2(30)) bin,\u000d\u000a10 '0123456789ABCDEF' hex\u000d\u000a11 )\u000d\u000a12 rules iterate (10000) until (num[0] <= 0) (\u000d\u000a13 bin[0] = substr(hex[cv()],mod(num[cv()],2)+1,1)||bin[cv()],\u000d\u000a14 num[0] = trunc(num[cv()]/2)\u000d\u000a15 )\u000d\u000a16 ) sal_binary\u000d\u000a17 from emp\u000d\u000aDiscussion\u000d\u000aWe mentioned in the \u201cSolution\u201d section that this problem is most likely better solved\u000d\u000avia a stored function. Indeed, the idea for this recipe came from a function. As a mat\u2010\u000d\u000ater of fact, this recipe is an adaptation of a function called TO_BASE, written by Tom\u000d\u000aKyte of Oracle Corporation. Like other recipes in this book that you may decide not\u000d\u000ato use, even if you do not use this recipe, it does a nice job of showing of some of the\u000d\u000afeatures of the MODEL clause such as iteration and array access of rows.\u000d\u000aTo make the explanation easier, we focus on a slight variation of the subquery con\u2010\u000d\u000ataining the MODEL clause. The code that follows is essentially the subquery from the\u000d\u000asolution, except that it\u2019s been hardwired to return the value 2 in binary:\u000d\u000aselect bin\u000d\u000a from dual\u000d\u000a model\u000d\u000a dimension by ( 0 attr )\u000d\u000a measures ( 2 num,\u000d\u000a14.7 Converting Whole Numbers to Binary Using Oracle | 475"," cast(null as varchar2(30)) bin,\u000d\u000a '0123456789ABCDEF' hex\u000d\u000a )\u000d\u000a rules iterate (10000) until (num[0] <= 0) (\u000d\u000a bin[0] = substr (hex[cv()],mod(num[cv()],2)+1,1)||bin[cv()],\u000d\u000a num[0] = trunc(num[cv()]/2)\u000d\u000a )\u000d\u000aBIN\u000d\u000a----------\u000d\u000a10\u000d\u000aThe following query outputs the values returned from one iteration of the RULES\u000d\u000adefined in the previous query:\u000d\u000aselect 2 start_val,\u000d\u000a '0123456789ABCDEF' hex,\u000d\u000a substr('0123456789ABCDEF',mod(2,2)+1,1) ||\u000d\u000a cast(null as varchar2(30)) bin,\u000d\u000a trunc(2/2) num\u000d\u000a from dual\u000d\u000aSTART_VAL HEX BIN NUM\u000d\u000a--------- ---------------- ---------- ---\u000d\u000a 2 0123456789ABCDEF 0 1\u000d\u000aSTART_VAL represents the number you want to convert to binary, which in this case\u000d\u000ais 2. The value for BIN is the result of a substring operation on 0123456789ABCDEF\u000d\u000a(HEX, in the original solution). The value for NUM is the test that will determine\u000d\u000awhen you exit the loop.\u000d\u000aAs you can see from the preceding result set, the first time through the loop BIN is 0\u000d\u000aand NUM is 1. Because NUM is not less than or equal to 0, another loop iteration\u000d\u000aoccurs. The following SQL statement shows the results of the next iteration:\u000d\u000aselect num start_val,\u000d\u000a substr('0123456789ABCDEF',mod(1,2)+1,1) || bin bin,\u000d\u000a trunc(1/2) num\u000d\u000a from (\u000d\u000aselect 2 start_val,\u000d\u000a '0123456789ABCDEF' hex,\u000d\u000a substr('0123456789ABCDEF',mod(2,2)+1,1) ||\u000d\u000a cast(null as varchar2(30)) bin,\u000d\u000a trunc(2/2) num\u000d\u000a from dual\u000d\u000a )\u000d\u000aSTART_VAL BIN NUM\u000d\u000a--------- ---------- ---\u000d\u000a 1 10 0\u000d\u000a476 | Chapter 14: Odds \u2019n\u2019 Ends","The next time through the loop, the result of the substring operation on HEX returns\u000d\u000a1, and the prior value of BIN, 0, is appended to it. The test, NUM, is now 0; thus, this\u000d\u000ais the last iteration, and the return value \u201c10\u201d is the binary representation of the num\u2010\u000d\u000aber 2. Once you\u2019re comfortable with what\u2019s going on, you can remove the iteration\u000d\u000afrom the MODEL clause and step through it row by row to follow how the rules are\u000d\u000aapplied to come to the final result set, as is shown here:\u000d\u000aselect 2 orig_val, num, bin\u000d\u000a from dual\u000d\u000a model\u000d\u000a dimension by ( 0 attr )\u000d\u000a measures ( 2 num,\u000d\u000a cast(null as varchar2(30)) bin,\u000d\u000a '0123456789ABCDEF' hex\u000d\u000a )\u000d\u000a rules (\u000d\u000a bin[0] = substr (hex[cv()],mod(num[cv()],2)+1,1)||bin[cv()],\u000d\u000a num[0] = trunc(num[cv()]/2),\u000d\u000a bin[1] = substr (hex[0],mod(num[0],2)+1,1)||bin[0],\u000d\u000a num[1] = trunc(num[0]/2)\u000d\u000a )\u000d\u000aORIG_VAL NUM BIN\u000d\u000a-------- --- ---------\u000d\u000a 2 1 0\u000d\u000a 2 0 10\u000d\u000a14.8 Pivoting a Ranked Result Set\u000d\u000aProblem\u000d\u000aYou want to rank the values in a table and then pivot the result set into three col\u2010\u000d\u000aumns. The idea is to show the top three, the next three, and then all the rest. For\u000d\u000aexample, you want to rank the employees in table EMP by SAL and then pivot the\u000d\u000aresults into three columns. The desired result set is as follows:\u000d\u000aTOP_3 NEXT_3 REST\u000d\u000a--------------- --------------- --------------\u000d\u000aKING (5000) BLAKE (2850) TURNER (1500)\u000d\u000aFORD (3000) CLARK (2450) MILLER (1300)\u000d\u000aSCOTT (3000) ALLEN (1600) MARTIN (1250)\u000d\u000aJONES (2975) WARD (1250)\u000d\u000a ADAMS (1100)\u000d\u000a JAMES (950)\u000d\u000a SMITH (800)\u000d\u000a14.8 Pivoting a Ranked Result Set | 477","Solution\u000d\u000aThe key to this solution is to first use the window function DENSE_RANK OVER to\u000d\u000arank the employees by SAL while allowing for ties. By using DENSE_RANK OVER,\u000d\u000ayou can easily see the top three salaries, the next three salaries, and then all the rest.\u000d\u000aNext, use the window function ROW_NUMBER OVER to rank each employee\u000d\u000awithin their group (the top three, next three, or last group). From there, simply per\u2010\u000d\u000aform a classic transpose, while using the built-in string functions available on your\u000d\u000aplatform to beautify the results. The following solution uses Oracle syntax. Since all\u000d\u000avendors now support window functions, converting the solution to work for other\u000d\u000aplatforms is trivial:\u000d\u000a 1 select max(case grp when 1 then rpad(ename,6) ||\u000d\u000a 2 ' ('|| sal ||')' end) top_3,\u000d\u000a 3 max(case grp when 2 then rpad(ename,6) ||\u000d\u000a 4 ' ('|| sal ||')' end) next_3,\u000d\u000a 5 max(case grp when 3 then rpad(ename,6) ||\u000d\u000a 6 ' ('|| sal ||')' end) rest\u000d\u000a 7 from (\u000d\u000a 8 select ename,\u000d\u000a 9 sal,\u000d\u000a10 rnk,\u000d\u000a11 case when rnk <= 3 then 1\u000d\u000a12 when rnk <= 6 then 2\u000d\u000a13 else 3\u000d\u000a14 end grp,\u000d\u000a15 row_number()over (\u000d\u000a16 partition by case when rnk <= 3 then 1\u000d\u000a17 when rnk <= 6 then 2\u000d\u000a18 else 3\u000d\u000a19 end\u000d\u000a20 order by sal desc, ename\u000d\u000a21 ) grp_rnk\u000d\u000a22 from (\u000d\u000a23 select ename,\u000d\u000a24 sal,\u000d\u000a25 dense_rank()over(order by sal desc) rnk\u000d\u000a26 from emp\u000d\u000a27 ) x\u000d\u000a28 ) y\u000d\u000a29 group by grp_rnk\u000d\u000aDiscussion\u000d\u000aThis recipe is a perfect example of how much you can accomplish with so little, with\u000d\u000athe help of window functions. The solution may look involved, but as you break it\u000d\u000adown from inside out, you will be surprised how simple it is. Let\u2019s begin by executing\u000d\u000ainline view X first:\u000d\u000a478 | Chapter 14: Odds \u2019n\u2019 Ends","select ename,\u000d\u000a sal,\u000d\u000a dense_rank()over(order by sal desc) rnk\u000d\u000a from emp\u000d\u000aENAME SAL RNK\u000d\u000a---------- ----- ----------\u000d\u000aKING 5000 1\u000d\u000aSCOTT 3000 2\u000d\u000aFORD 3000 2\u000d\u000aJONES 2975 3\u000d\u000aBLAKE 2850 4\u000d\u000aCLARK 2450 5\u000d\u000aALLEN 1600 6\u000d\u000aTURNER 1500 7\u000d\u000aMILLER 1300 8\u000d\u000aWARD 1250 9\u000d\u000aMARTIN 1250 9\u000d\u000aADAMS 1100 10\u000d\u000aJAMES 950 11\u000d\u000aSMITH 800 12\u000d\u000aAs you can see from the previous result set, inline view X simply ranks the employees\u000d\u000aby SAL, while allowing for ties (because the solution uses DENSE_RANK instead of\u000d\u000aRANK, there are ties without gaps). The next step is to take the rows from inline view\u000d\u000aX and create groups by using a CASE expression to evaluate the ranking from\u000d\u000aDENSE_RANK. Additionally, use the window function ROW_NUMBER OVER to\u000d\u000arank the employees by SAL within their group (within the group you are creating\u000d\u000awith the CASE expression). All of this happens in inline view Y and is shown here:\u000d\u000aselect ename,\u000d\u000a sal,\u000d\u000a rnk,\u000d\u000a case when rnk <= 3 then 1\u000d\u000a when rnk <= 6 then 2\u000d\u000a else 3\u000d\u000a end grp,\u000d\u000a row_number()over (\u000d\u000a partition by case when rnk <= 3 then 1\u000d\u000a when rnk <= 6 then 2\u000d\u000a else 3\u000d\u000a end\u000d\u000a order by sal desc, ename\u000d\u000a ) grp_rnk\u000d\u000a from (\u000d\u000aselect ename,\u000d\u000a sal,\u000d\u000a dense_rank()over(order by sal desc) rnk\u000d\u000a from emp\u000d\u000a ) x\u000d\u000a14.8 Pivoting a Ranked Result Set | 479","ENAME SAL RNK GRP GRP_RNK\u000d\u000a---------- ----- ---- ---- -------\u000d\u000aKING 5000 1 1 1\u000d\u000aFORD 3000 2 1 2\u000d\u000aSCOTT 3000 2 1 3\u000d\u000aJONES 2975 3 1 4\u000d\u000aBLAKE 2850 4 2 1\u000d\u000aCLARK 2450 5 2 2\u000d\u000aALLEN 1600 6 2 3\u000d\u000aTURNER 1500 7 3 1\u000d\u000aMILLER 1300 8 3 2\u000d\u000aMARTIN 1250 9 3 3\u000d\u000aWARD 1250 9 3 4\u000d\u000aADAMS 1100 10 3 5\u000d\u000aJAMES 950 11 3 6\u000d\u000aSMITH 800 12 3 7\u000d\u000aNow the query is starting to take shape, and if you followed it from the beginning\u000d\u000a(from inline view X), you can see that it\u2019s not that complicated. The query so far\u000d\u000areturns each employee; their SAL; their RNK, which represents where their SAL\u000d\u000aranks among all employees; their GRP, which indicates the group each employee is in\u000d\u000a(based on SAL); and finally GRP_RANK, which is a ranking (based on SAL) within\u000d\u000atheir GRP.\u000d\u000aAt this point, perform a traditional pivot on ENAME while using the Oracle concate\u2010\u000d\u000anation operator || to append the SAL. The function RPAD ensures that the numeric\u000d\u000avalues in parentheses line up nicely. Finally, use GROUP BY on GRP_RNK to ensure\u000d\u000ayou show each employee in the result set. The final result set is shown here:\u000d\u000aselect max(case grp when 1 then rpad(ename,6) ||\u000d\u000a ' ('|| sal ||')' end) top_3,\u000d\u000a max(case grp when 2 then rpad(ename,6) ||\u000d\u000a ' ('|| sal ||')' end) next_3,\u000d\u000a max(case grp when 3 then rpad(ename,6) ||\u000d\u000a ' ('|| sal ||')' end) rest\u000d\u000a from (\u000d\u000aselect ename,\u000d\u000a sal,\u000d\u000a rnk,\u000d\u000a case when rnk <= 3 then 1\u000d\u000a when rnk <= 6 then 2\u000d\u000a else 3\u000d\u000a end grp,\u000d\u000a row_number()over (\u000d\u000a partition by case when rnk <= 3 then 1\u000d\u000a when rnk <= 6 then 2\u000d\u000a else 3\u000d\u000a end\u000d\u000a Order by sal desc, ename\u000d\u000a ) grp_rnk\u000d\u000a from (\u000d\u000a480 | Chapter 14: Odds \u2019n\u2019 Ends","select ename,\u000d\u000a sal,\u000d\u000a dense_rank()over(order by sal desc) rnk\u000d\u000a from emp\u000d\u000a ) x\u000d\u000a ) y\u000d\u000agroup by grp_rnk\u000d\u000aTOP_3 NEXT_3 REST\u000d\u000a--------------- --------------- -------------\u000d\u000aKING (5000) BLAKE (2850) TURNER (1500)\u000d\u000aFORD (3000) CLARK (2450) MILLER (1300)\u000d\u000aSCOTT (3000) ALLEN (1600) MARTIN (1250)\u000d\u000aJONES (2975) WARD (1250)\u000d\u000aADAMS (1100)\u000d\u000a JAMES (950)\u000d\u000a SMITH (800)\u000d\u000aIf you examine the queries in all of the steps, you\u2019ll notice that table EMP is accessed\u000d\u000aexactly once. One of the remarkable things about window functions is how much\u000d\u000awork you can do in just one pass through your data. There\u2019s no need for self-joins or\u000d\u000atemp tables; just get the rows you need and then let the window functions do the rest.\u000d\u000aOnly in inline view X do you need to access EMP. From there, it\u2019s simply a matter of\u000d\u000amassaging the result set to look the way you want. Consider what all this means for\u000d\u000aperformance if you can create this type of report with a single table access. Pretty\u000d\u000acool.\u000d\u000a14.9 Adding a Column Header into a Double Pivoted\u000d\u000aResult Set\u000d\u000aProblem\u000d\u000aYou want to stack two result sets and then pivot them into two columns. Additionally,\u000d\u000ayou want to add a \u201cheader\u201d for each group of rows in each column. For example, you\u000d\u000ahave two tables containing information about employees working in different areas of\u000d\u000adevelopment in your company (say, in research and applications):\u000d\u000aselect * from it_research\u000d\u000aDEPTNO ENAME\u000d\u000a------ --------------------\u000d\u000a 100 HOPKINS\u000d\u000a 100 JONES\u000d\u000a 100 TONEY\u000d\u000a 200 MORALES\u000d\u000a 200 P.WHITAKER\u000d\u000a 200 MARCIANO\u000d\u000a 200 ROBINSON\u000d\u000a14.9 Adding a Column Header into a Double Pivoted Result Set | 481"," 300 LACY\u000d\u000a 300 WRIGHT\u000d\u000a 300 J.TAYLOR\u000d\u000aselect * from it_apps\u000d\u000aDEPTNO ENAME\u000d\u000a------ -----------------\u000d\u000a 400 CORRALES\u000d\u000a 400 MAYWEATHER\u000d\u000a 400 CASTILLO\u000d\u000a 400 MARQUEZ\u000d\u000a 400 MOSLEY\u000d\u000a 500 GATTI\u000d\u000a 500 CALZAGHE\u000d\u000a 600 LAMOTTA\u000d\u000a 600 HAGLER\u000d\u000a 600 HEARNS\u000d\u000a 600 FRAZIER\u000d\u000a 700 GUINN\u000d\u000a 700 JUDAH\u000d\u000a 700 MARGARITO\u000d\u000aYou would like to create a report listing the employees from each table in two col\u2010\u000d\u000aumns. You want to return the DEPTNO followed by ENAME for each. Ultimately,\u000d\u000ayou want to return the following result set:\u000d\u000aRESEARCH APPS\u000d\u000a-------------------- ---------------\u000d\u000a100 400\u000d\u000a JONES MAYWEATHER\u000d\u000a TONEY CASTILLO\u000d\u000a HOPKINS MARQUEZ\u000d\u000a200 MOSLEY\u000d\u000a P.WHITAKER CORRALES\u000d\u000a MARCIANO 500\u000d\u000a ROBINSON CALZAGHE\u000d\u000a MORALES GATTI\u000d\u000a300 600\u000d\u000a WRIGHT HAGLER\u000d\u000a J.TAYLOR HEARNS\u000d\u000a LACY FRAZIER\u000d\u000a LAMOTTA\u000d\u000a 700\u000d\u000a JUDAH\u000d\u000a MARGARITO\u000d\u000a GUINN\u000d\u000a482 | Chapter 14: Odds \u2019n\u2019 Ends","Solution\u000d\u000aFor the most part, this solution requires nothing more than a simple stack \u2019n\u2019 pivot\u000d\u000a(union then pivot) with an added twist: the DEPTNO must precede the ENAME for\u000d\u000aeach employee returned. The technique here uses a Cartesian product to generate an\u000d\u000aextra row for each DEPTNO, so you have the required rows necessary to show all\u000d\u000aemployees, plus room for the DEPTNO. The solution uses Oracle syntax, but since\u000d\u000aDB2 supports window functions that can compute moving windows (the framing\u000d\u000aclause), converting this solution to work for DB2 is trivial. Because the IT_\u000d\u000aRESEARCH and IT_APPS tables exist only for this recipe, their table creation state\u2010\u000d\u000aments are shown along with this solution:\u000d\u000acreate table IT_research (deptno number, ename varchar2(20))\u000d\u000ainsert into IT_research values (100,'HOPKINS')\u000d\u000ainsert into IT_research values (100,'JONES')\u000d\u000ainsert into IT_research values (100,'TONEY')\u000d\u000ainsert into IT_research values (200,'MORALES')\u000d\u000ainsert into IT_research values (200,'P.WHITAKER')\u000d\u000ainsert into IT_research values (200,'MARCIANO')\u000d\u000ainsert into IT_research values (200,'ROBINSON')\u000d\u000ainsert into IT_research values (300,'LACY')\u000d\u000ainsert into IT_research values (300,'WRIGHT')\u000d\u000ainsert into IT_research values (300,'J.TAYLOR')\u000d\u000acreate table IT_apps (deptno number, ename varchar2(20))\u000d\u000ainsert into IT_apps values (400,'CORRALES')\u000d\u000ainsert into IT_apps values (400,'MAYWEATHER')\u000d\u000ainsert into IT_apps values (400,'CASTILLO')\u000d\u000ainsert into IT_apps values (400,'MARQUEZ')\u000d\u000ainsert into IT_apps values (400,'MOSLEY')\u000d\u000ainsert into IT_apps values (500,'GATTI')\u000d\u000ainsert into IT_apps values (500,'CALZAGHE')\u000d\u000ainsert into IT_apps values (600,'LAMOTTA')\u000d\u000ainsert into IT_apps values (600,'HAGLER')\u000d\u000ainsert into IT_apps values (600,'HEARNS')\u000d\u000ainsert into IT_apps values (600,'FRAZIER')\u000d\u000ainsert into IT_apps values (700,'GUINN')\u000d\u000ainsert into IT_apps values (700,'JUDAH')\u000d\u000ainsert into IT_apps values (700,'MARGARITO')\u000d\u000a 1 select max(decode(flag2,0,it_dept)) research,\u000d\u000a 2 max(decode(flag2,1,it_dept)) apps\u000d\u000a 3 from (\u000d\u000a 4 select sum(flag1)over(partition by flag2\u000d\u000a 5 order by flag1,rownum) flag,\u000d\u000a 6 it_dept, flag2\u000d\u000a 7 from (\u000d\u000a14.9 Adding a Column Header into a Double Pivoted Result Set | 483"," 8 select 1 flag1, 0 flag2,\u000d\u000a 9 decode(rn,1,to_char(deptno),' '||ename) it_dept\u000d\u000a10 from (\u000d\u000a11 select x.*, y.id,\u000d\u000a12 row_number()over(partition by x.deptno order by y.id) rn\u000d\u000a13 from (\u000d\u000a14 select deptno,\u000d\u000a15 ename,\u000d\u000a16 count(*)over(partition by deptno) cnt\u000d\u000a17 from it_research\u000d\u000a18 ) x,\u000d\u000a19 (select level id from dual connect by level <= 2) y\u000d\u000a20 )\u000d\u000a21 where rn <= cnt+1\u000d\u000a22 union all\u000d\u000a23 select 1 flag1, 1 flag2,\u000d\u000a24 decode(rn,1,to_char(deptno),' '||ename) it_dept\u000d\u000a25 from (\u000d\u000a26 select x.*, y.id,\u000d\u000a27 row_number()over(partition by x.deptno order by y.id) rn\u000d\u000a28 from (\u000d\u000a29 select deptno,\u000d\u000a30 ename,\u000d\u000a31 count(*)over(partition by deptno) cnt\u000d\u000a32 from it_apps\u000d\u000a33 ) x,\u000d\u000a34 (select level id from dual connect by level <= 2) y\u000d\u000a35 )\u000d\u000a36 where rn <= cnt+1\u000d\u000a37 ) tmp1\u000d\u000a38 ) tmp2\u000d\u000a39 group by flag\u000d\u000aDiscussion\u000d\u000aLike many of the other warehousing/report type queries, the solution presented looks\u000d\u000aquite convoluted, but once broken down, you\u2019ll seen it\u2019s nothing more than a stack \u2019n\u2019\u000d\u000apivot with a Cartesian twist (on the rocks, with a little umbrella). The way to break\u000d\u000adown this query is to work on each part of the UNION ALL first and then bring it\u000d\u000atogether for the pivot. Let\u2019s start with the lower portion of the UNION ALL:\u000d\u000aselect 1 flag1, 1 flag2,\u000d\u000a decode(rn,1,to_char(deptno),' '||ename) it_dept\u000d\u000a from (\u000d\u000aselect x.*, y.id,\u000d\u000a row_number()over(partition by x.deptno order by y.id) rn\u000d\u000a from (\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a count(*)over(partition by deptno) cnt\u000d\u000a from it_apps\u000d\u000a484 | Chapter 14: Odds \u2019n\u2019 Ends"," ) x,\u000d\u000a (select level id from dual connect by level <= 2) y\u000d\u000a ) z\u000d\u000a where rn <= cnt+1\u000d\u000aFLAG1 FLAG2 IT_DEPT\u000d\u000a----- ---------- --------------------------\u000d\u000a 1 1 400\u000d\u000a 1 1 MAYWEATHER\u000d\u000a 1 1 CASTILLO\u000d\u000a 1 1 MARQUEZ\u000d\u000a 1 1 MOSLEY\u000d\u000a 1 1 CORRALES\u000d\u000a 1 1 500\u000d\u000a 1 1 CALZAGHE\u000d\u000a 1 1 GATTI\u000d\u000a 1 1 600\u000d\u000a 1 1 HAGLER\u000d\u000a 1 1 HEARNS\u000d\u000a 1 1 FRAZIER\u000d\u000a 1 1 LAMOTTA\u000d\u000a 1 1 700\u000d\u000a 1 1 JUDAH\u000d\u000a 1 1 MARGARITO\u000d\u000a 1 1 GUINN\u000d\u000aLet\u2019s examine exactly how that result set is put together. Breaking down the previous\u000d\u000aquery to its simplest components, you have inline view X, which simply returns each\u000d\u000aENAME and DEPTNO and the number of employees in each DEPTNO from table\u000d\u000aIT_APPS. The results are as follows:\u000d\u000aselect deptno deptno,\u000d\u000a ename,\u000d\u000a count(*)over(partition by deptno) cnt\u000d\u000a from it_apps\u000d\u000aDEPTNO ENAME CNT\u000d\u000a------ -------------------- ----------\u000d\u000a 400 CORRALES 5\u000d\u000a 400 MAYWEATHER 5\u000d\u000a 400 CASTILLO 5\u000d\u000a 400 MARQUEZ 5\u000d\u000a 400 MOSLEY 5\u000d\u000a 500 GATTI 2\u000d\u000a 500 CALZAGHE 2\u000d\u000a 600 LAMOTTA 4\u000d\u000a 600 HAGLER 4\u000d\u000a 600 HEARNS 4\u000d\u000a 600 FRAZIER 4\u000d\u000a 700 GUINN 3\u000d\u000a 700 JUDAH 3\u000d\u000a 700 MARGARITO 3\u000d\u000a14.9 Adding a Column Header into a Double Pivoted Result Set | 485","The next step is to create a Cartesian product between the rows returned from inline\u000d\u000aview X and two rows generated from DUAL using CONNECT BY. The results of this\u000d\u000aoperation are as follows:\u000d\u000aselect *\u000d\u000a from (\u000d\u000aselect deptno deptno,\u000d\u000a ename,\u000d\u000a count(*)over(partition by deptno) cnt\u000d\u000a from it_apps\u000d\u000a ) x,\u000d\u000a (select level id from dual connect by level <= 2) y\u000d\u000a order by 2\u000d\u000aDEPTNO ENAME CNT ID\u000d\u000a------ ---------- --- ---\u000d\u000a 500 CALZAGHE 2 1\u000d\u000a 500 CALZAGHE 2 2\u000d\u000a 400 CASTILLO 5 1\u000d\u000a 400 CASTILLO 5 2\u000d\u000a 400 CORRALES 5 1\u000d\u000a 400 CORRALES 5 2\u000d\u000a 600 FRAZIER 4 1\u000d\u000a 600 FRAZIER 4 2\u000d\u000a 500 GATTI 2 1\u000d\u000a 500 GATTI 2 2\u000d\u000a 700 GUINN 3 1\u000d\u000a 700 GUINN 3 2\u000d\u000a 600 HAGLER 4 1\u000d\u000a 600 HAGLER 4 2\u000d\u000a 600 HEARNS 4 1\u000d\u000a 600 HEARNS 4 2\u000d\u000a 700 JUDAH 3 1\u000d\u000a 700 JUDAH 3 2\u000d\u000a 600 LAMOTTA 4 1\u000d\u000a 600 LAMOTTA 4 2\u000d\u000a 700 MARGARITO 3 1\u000d\u000a 700 MARGARITO 3 2\u000d\u000a 400 MARQUEZ 5 1\u000d\u000a 400 MARQUEZ 5 2\u000d\u000a 400 MAYWEATHER 5 1\u000d\u000a 400 MAYWEATHER 5 2\u000d\u000a 400 MOSLEY 5 1\u000d\u000a 400 MOSLEY 5 2\u000d\u000aAs you can see from these results, each row from inline view X is now returned twice\u000d\u000adue to the Cartesian product with inline view Y. The reason a Cartesian is needed will\u000d\u000abecome clear shortly. The next step is to take the current result set and rank each\u000d\u000aemployee within his DEPTNO by ID (ID has a value of 1 or 2 as was returned by the\u000d\u000aCartesian product). The result of this ranking is shown in the output from the follow\u2010\u000d\u000aing query:\u000d\u000a486 | Chapter 14: Odds \u2019n\u2019 Ends","select x.*, y.id,\u000d\u000a row_number()over(partition by x.deptno order by y.id) rn\u000d\u000a from (\u000d\u000aselect deptno deptno,\u000d\u000a ename,\u000d\u000a count(*)over(partition by deptno) cnt\u000d\u000a from it_apps\u000d\u000a ) x,\u000d\u000a (select level id from dual connect by level <= 2) y\u000d\u000aDEPTNO ENAME CNT ID RN\u000d\u000a------ ---------- --- --- ----------\u000d\u000a 400 CORRALES 5 1 1\u000d\u000a 400 MAYWEATHER 5 1 2\u000d\u000a 400 CASTILLO 5 1 3\u000d\u000a 400 MARQUEZ 5 1 4\u000d\u000a 400 MOSLEY 5 1 5\u000d\u000a 400 CORRALES 5 2 6\u000d\u000a 400 MOSLEY 5 2 7\u000d\u000a 400 MAYWEATHER 5 2 8\u000d\u000a 400 CASTILLO 5 2 9\u000d\u000a 400 MARQUEZ 5 2 10\u000d\u000a 500 GATTI 2 1 1\u000d\u000a 500 CALZAGHE 2 1 2\u000d\u000a 500 GATTI 2 2 3\u000d\u000a 500 CALZAGHE 2 2 4\u000d\u000a 600 LAMOTTA 4 1 1\u000d\u000a 600 HAGLER 4 1 2\u000d\u000a 600 HEARNS 4 1 3\u000d\u000a 600 FRAZIER 4 1 4\u000d\u000a 600 LAMOTTA 4 2 5\u000d\u000a 600 HAGLER 4 2 6\u000d\u000a 600 FRAZIER 4 2 7\u000d\u000a 600 HEARNS 4 2 8\u000d\u000a 700 GUINN 3 1 1\u000d\u000a 700 JUDAH 3 1 2\u000d\u000a 700 MARGARITO 3 1 3\u000d\u000a 700 GUINN 3 2 4\u000d\u000a 700 JUDAH 3 2 5\u000d\u000a 700 MARGARITO 3 2 6\u000d\u000aEach employee is ranked; then his duplicate is ranked. The result set contains dupli\u2010\u000d\u000acates for all employees in table IT_APP, along with their ranking within their\u000d\u000aDEPTNO. The reason you need to generate these extra rows is because you need a\u000d\u000aslot in the result set to slip in the DEPTNO in the ENAME column. If you Cartesianjoin IT_APPS with a one-row table, you get no extra rows (because cardinality of any\u000d\u000atable \u00d7 1 = cardinality of that table).\u000d\u000aThe next step is to take the results returned thus far and pivot the result set such that\u000d\u000aall the ENAMEs are returned in one column but are preceded by the DEPTNO they\u000d\u000aare in. The following query shows how this happens:\u000d\u000a14.9 Adding a Column Header into a Double Pivoted Result Set | 487","select 1 flag1, 1 flag2,\u000d\u000a decode(rn,1,to_char(deptno),' '||ename) it_dept\u000d\u000a from (\u000d\u000aselect x.*, y.id,\u000d\u000a row_number()over(partition by x.deptno order by y.id) rn\u000d\u000a from (\u000d\u000aselect deptno deptno,\u000d\u000a ename,\u000d\u000a count(*)over(partition by deptno) cnt\u000d\u000a from it_apps\u000d\u000a ) x,\u000d\u000a (select level id from dual connect by level <= 2) y\u000d\u000a ) z\u000d\u000a where rn <= cnt+1\u000d\u000aFLAG1 FLAG2 IT_DEPT\u000d\u000a----- ---------- -------------------------\u000d\u000a 1 1 400\u000d\u000a 1 1 MAYWEATHER\u000d\u000a 1 1 CASTILLO\u000d\u000a 1 1 MARQUEZ\u000d\u000a 1 1 MOSLEY\u000d\u000a 1 1 CORRALES\u000d\u000a 1 1 500\u000d\u000a 1 1 CALZAGHE\u000d\u000a 1 1 GATTI\u000d\u000a 1 1 600\u000d\u000a 1 1 HAGLER\u000d\u000a 1 1 HEARNS\u000d\u000a 1 1 FRAZIER\u000d\u000a 1 1 LAMOTTA\u000d\u000a 1 1 700\u000d\u000a 1 1 JUDAH\u000d\u000a 1 1 MARGARITO\u000d\u000a 1 1 GUINN\u000d\u000aFLAG1 and FLAG2 come into play later and can be ignored for the moment. Focus\u000d\u000ayour attention on the rows in IT_DEPT. The number of rows returned for each\u000d\u000aDEPTNO is CNT*2, but all that is needed is CNT+1, which is the filter in the\u000d\u000aWHERE clause. RN is the ranking for each employee. The rows kept are all those\u000d\u000aranked less than or equal to CNT+1; i.e., all employees in each DEPTNO plus one\u000d\u000amore (this extra employee is the employee who is ranked first in their DEPTNO).\u000d\u000aThis extra row is where the DEPTNO will slide in. By using DECODE (an older Ora\u2010\u000d\u000acle function that gives more or less the equivalent of a CASE expression) to evaluate\u000d\u000athe value of RN, you can slide the value of DEPTNO into the result set. The employee\u000d\u000awho was at position one (based on the value of RN) is still shown in the result set, but\u000d\u000ais now last in each DEPTNO (because the order is irrelevant, this is not a problem).\u000d\u000aThat pretty much covers the lower part of the UNION ALL.\u000d\u000a488 | Chapter 14: Odds \u2019n\u2019 Ends","The upper part of the UNION ALL is processed in the same way as the lower part, so\u000d\u000athere\u2019s no need to explain how that works. Instead, let\u2019s examine the result set\u000d\u000areturned when stacking the queries:\u000d\u000aselect 1 flag1, 0 flag2,\u000d\u000a decode(rn,1,to_char(deptno),' '||ename) it_dept\u000d\u000a from (\u000d\u000aselect x.*, y.id,\u000d\u000a row_number()over(partition by x.deptno order by y.id) rn\u000d\u000a from (\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a count(*)over(partition by deptno) cnt\u000d\u000a from it_research\u000d\u000a ) x,\u000d\u000a (select level id from dual connect by level <= 2) y\u000d\u000a )\u000d\u000a where rn <= cnt+1\u000d\u000aunion all\u000d\u000aselect 1 flag1, 1 flag2,\u000d\u000a decode(rn,1,to_char(deptno),' '||ename) it_dept\u000d\u000a from (\u000d\u000aselect x.*, y.id,\u000d\u000a row_number()over(partition by x.deptno order by y.id) rn\u000d\u000a from (\u000d\u000aselect deptno deptno,\u000d\u000a ename,\u000d\u000a count(*)over(partition by deptno) cnt\u000d\u000a from it_apps\u000d\u000a ) x,\u000d\u000a (select level id from dual connect by level <= 2) y\u000d\u000a )\u000d\u000a where rn <= cnt+1\u000d\u000aFLAG1 FLAG2 IT_DEPT\u000d\u000a----- ---------- -----------------------\u000d\u000a 1 0 100\u000d\u000a 1 0 JONES\u000d\u000a 1 0 TONEY\u000d\u000a 1 0 HOPKINS\u000d\u000a 1 0 200\u000d\u000a 1 0 P.WHITAKER\u000d\u000a 1 0 MARCIANO\u000d\u000a 1 0 ROBINSON\u000d\u000a 1 0 MORALES\u000d\u000a 1 0 300\u000d\u000a 1 0 WRIGHT\u000d\u000a 1 0 J.TAYLOR\u000d\u000a 1 0 LACY\u000d\u000a 1 1 400\u000d\u000a 1 1 MAYWEATHER\u000d\u000a 1 1 CASTILLO\u000d\u000a14.9 Adding a Column Header into a Double Pivoted Result Set | 489"," 1 1 MARQUEZ\u000d\u000a 1 1 MOSLEY\u000d\u000a 1 1 CORRALES\u000d\u000a 1 1 500\u000d\u000a 1 1 CALZAGHE\u000d\u000a 1 1 GATTI\u000d\u000a 1 1 600\u000d\u000a 1 1 HAGLER\u000d\u000a 1 1 HEARNS\u000d\u000a 1 1 FRAZIER\u000d\u000a 1 1 LAMOTTA\u000d\u000a 1 1 700\u000d\u000a 1 1 JUDAH\u000d\u000a 1 1 MARGARITO\u000d\u000a 1 1 GUINN\u000d\u000aAt this point, it isn\u2019t clear what FLAG1\u2019s purpose is, but you can see that FLAG2 iden\u2010\u000d\u000atifies which rows come from which part of the UNION ALL (0 for the upper part, 1\u000d\u000afor the lower part).\u000d\u000aThe next step is to wrap the stacked result set in an inline view and create a running\u000d\u000atotal on FLAG1 (finally, its purpose is revealed!), which will act as a ranking for each\u000d\u000arow in each stack. The results of the ranking (running total) are shown here:\u000d\u000aselect sum(flag1)over(partition by flag2\u000d\u000a order by flag1,rownum) flag,\u000d\u000a it_dept, flag2\u000d\u000a from (\u000d\u000aselect 1 flag1, 0 flag2,\u000d\u000a decode(rn,1,to_char(deptno),' '||ename) it_dept\u000d\u000a from (\u000d\u000aselect x.*, y.id,\u000d\u000a row_number()over(partition by x.deptno order by y.id) rn\u000d\u000a from (\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a count(*)over(partition by deptno) cnt\u000d\u000a from it_research\u000d\u000a ) x,\u000d\u000a (select level id from dual connect by level <= 2) y\u000d\u000a )\u000d\u000a where rn <= cnt+1\u000d\u000aunion all\u000d\u000aselect 1 flag1, 1 flag2,\u000d\u000a decode(rn,1,to_char(deptno),' '||ename) it_dept\u000d\u000a from (\u000d\u000aselect x.*, y.id,\u000d\u000a row_number()over(partition by x.deptno order by y.id) rn\u000d\u000a from (\u000d\u000aselect deptno deptno,\u000d\u000a ename,\u000d\u000a count(*)over(partition by deptno) cnt\u000d\u000a490 | Chapter 14: Odds \u2019n\u2019 Ends"," from it_apps\u000d\u000a ) x,\u000d\u000a (select level id from dual connect by level <= 2) y\u000d\u000a )\u000d\u000a where rn <= cnt+1\u000d\u000a ) tmp1\u000d\u000aFLAG IT_DEPT FLAG2\u000d\u000a---- --------------- ----------\u000d\u000a 1 100 0\u000d\u000a 2 JONES 0\u000d\u000a 3 TONEY 0\u000d\u000a 4 HOPKINS 0\u000d\u000a 5 200 0\u000d\u000a 6 P.WHITAKER 0\u000d\u000a 7 MARCIANO 0\u000d\u000a 8 ROBINSON 0\u000d\u000a 9 MORALES 0\u000d\u000a 10 300 0\u000d\u000a 11 WRIGHT 0\u000d\u000a 12 J.TAYLOR 0\u000d\u000a 13 LACY 0\u000d\u000a 1 400 1\u000d\u000a 2 MAYWEATHER 1\u000d\u000a 3 CASTILLO 1\u000d\u000a 4 MARQUEZ 1\u000d\u000a 5 MOSLEY 1\u000d\u000a 6 CORRALES 1\u000d\u000a 7 500 1\u000d\u000a 8 CALZAGHEe 1\u000d\u000a 9 GATTI 1\u000d\u000a 10 600 1\u000d\u000a 11 HAGLER 1\u000d\u000a 12 HEARNS 1\u000d\u000a 13 FRAZIER 1\u000d\u000a 14 LAMOTTA 1\u000d\u000a 15 700 1\u000d\u000a 16 JUDAH 1\u000d\u000a 17 MARGARITO 1\u000d\u000a 18 GUINN 1\u000d\u000aThe last step (finally!) is to pivot the value returned by TMP1 on FLAG2 while group\u2010\u000d\u000aing by FLAG (the running total generated in TMP1). The results from TMP1 are\u000d\u000awrapped in an inline view and pivoted (wrapped in a final inline view called TMP2).\u000d\u000aThe ultimate solution and result set are shown here:\u000d\u000aselect max(decode(flag2,0,it_dept)) research,\u000d\u000a max(decode(flag2,1,it_dept)) apps\u000d\u000a from (\u000d\u000aselect sum(flag1)over(partition by flag2\u000d\u000a order by flag1,rownum) flag,\u000d\u000a14.9 Adding a Column Header into a Double Pivoted Result Set | 491"," it_dept, flag2\u000d\u000a from (\u000d\u000aselect 1 flag1, 0 flag2,\u000d\u000a decode(rn,1,to_char(deptno),' '||ename) it_dept\u000d\u000a from (\u000d\u000aselect x.*, y.id,\u000d\u000a row_number()over(partition by x.deptno order by y.id) rn\u000d\u000a from (\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a count(*)over(partition by deptno) cnt\u000d\u000a from it_research\u000d\u000a ) x,\u000d\u000a (select level id from dual connect by level <= 2) y\u000d\u000a )\u000d\u000a where rn <= cnt+1\u000d\u000aunion all\u000d\u000aselect 1 flag1, 1 flag2,\u000d\u000a decode(rn,1,to_char(deptno),' '||ename) it_dept\u000d\u000a from (\u000d\u000aselect x.*, y.id,\u000d\u000a row_number()over(partition by x.deptno order by y.id) rn\u000d\u000a from (\u000d\u000aselect deptno deptno,\u000d\u000a ename,\u000d\u000a count(*)over(partition by deptno) cnt\u000d\u000a from it_apps\u000d\u000a ) x,\u000d\u000a (select level id from dual connect by level <= 2) y\u000d\u000a )\u000d\u000a where rn <= cnt+1\u000d\u000a ) tmp1\u000d\u000a ) tmp2\u000d\u000a group by flag\u000d\u000aRESEARCH APPS\u000d\u000a-------------------- ---------------\u000d\u000a100 400\u000d\u000a JONES MAYWEATHER\u000d\u000a TONEY CASTILLO\u000d\u000a HOPKINS MARQUEZ\u000d\u000a200 MOSLEY\u000d\u000a P.WHITAKER CORRALES\u000d\u000a MARCIANO 500\u000d\u000a ROBINSON CALZAGHE\u000d\u000a MORALES GATTI\u000d\u000a300 600\u000d\u000a WRIGHT HAGLER\u000d\u000a J.TAYLOR HEARNS\u000d\u000a LACY FRAZIER\u000d\u000a LAMOTTA\u000d\u000a492 | Chapter 14: Odds \u2019n\u2019 Ends"," 700\u000d\u000a JUDAH\u000d\u000a MARGARITO\u000d\u000a GUINN\u000d\u000a14.10 Converting a Scalar Subquery to a Composite\u000d\u000aSubquery in Oracle\u000d\u000aProblem\u000d\u000aYou want to bypass the restriction of returning exactly one value from a scalar sub\u2010\u000d\u000aquery. For example, you attempt to execute the following query:\u000d\u000aselect e.deptno,\u000d\u000a e.ename,\u000d\u000a e.sal,\u000d\u000a (select d.dname,d.loc,sysdate today\u000d\u000a from dept d\u000d\u000a where e.deptno=d.deptno)\u000d\u000a from emp e\u000d\u000abut receive an error because subqueries in the SELECT list are allowed to return only\u000d\u000aa single value.\u000d\u000aSolution\u000d\u000aAdmittedly, this problem is quite unrealistic, because a simple join between tables\u000d\u000aEMP and DEPT would allow you to return as many values you want from DEPT.\u000d\u000aNevertheless, the key is to focus on the technique and understand how to apply it to a\u000d\u000ascenario that you find useful. The key to bypassing the requirement to return a single\u000d\u000avalue when placing a SELECT within SELECT (scalar subquery) is to take advantage\u000d\u000aof Oracle\u2019s object types. You can define an object to have several attributes, and then\u000d\u000ayou can work with it as a single entity or reference each element individually. In\u000d\u000aeffect, you don\u2019t really bypass the rule at all. You simply return one value\u2014an [.keeptogether]#object\u2014#that in turn contains many attributes.\u000d\u000aThis solution makes use of the following object type:\u000d\u000acreate type generic_obj\u000d\u000a as object (\u000d\u000a val1 varchar2(10),\u000d\u000a val2 varchar2(10),\u000d\u000a val3 date\u000d\u000a );\u000d\u000aWith this type in place, you can execute the following query:\u000d\u000a 1 select x.deptno,\u000d\u000a 2 x.ename,\u000d\u000a14.10 Converting a Scalar Subquery to a Composite Subquery in Oracle | 493"," 3 x.multival.val1 dname,\u000d\u000a 4 x.multival.val2 loc,\u000d\u000a 5 x.multival.val3 today\u000d\u000a 6 from (\u000d\u000a 7select e.deptno,\u000d\u000a 8 e.ename,\u000d\u000a 9 e.sal,\u000d\u000a10 (select generic_obj(d.dname,d.loc,sysdate+1)\u000d\u000a11 from dept d\u000d\u000a12 where e.deptno=d.deptno) multival\u000d\u000a13 from emp e\u000d\u000a14 ) x\u000d\u000aDEPTNO ENAME DNAME LOC TODAY\u000d\u000a------ ---------- ---------- ---------- -----------\u000d\u000a 20 SMITH RESEARCH DALLAS 12-SEP-2020\u000d\u000a 30 ALLEN SALES CHICAGO 12-SEP-2020\u000d\u000a 30 WARD SALES CHICAGO 12-SEP-2020\u000d\u000a 20 JONES RESEARCH DALLAS 12-SEP-2020\u000d\u000a 30 MARTIN SALES CHICAGO 12-SEP-2020\u000d\u000a 30 BLAKE SALES CHICAGO 12-SEP-2020\u000d\u000a 10 CLARK ACCOUNTING NEW YORK 12-SEP-2020\u000d\u000a 20 SCOTT RESEARCH DALLAS 12-SEP-2020\u000d\u000a 10 KING ACCOUNTING NEW YORK 12-SEP-2020\u000d\u000a 30 TURNER SALES CHICAGO 12-SEP-2020\u000d\u000a 20 ADAMS RESEARCH DALLAS 12-SEP-2020\u000d\u000a 30 JAMES SALES CHICAGO 12-SEP-2020\u000d\u000a 20 FORD RESEARCH DALLAS 12-SEP-2020\u000d\u000a 10 MILLER ACCOUNTING NEW YORK 12-SEP-2020\u000d\u000aDiscussion\u000d\u000aThe key to the solution is to use the object\u2019s constructor function (by default the con\u2010\u000d\u000astructor function has the same name as the object). Because the object itself is a single\u000d\u000ascalar value, it does not violate the scalar subquery rule, as you can see from the\u000d\u000afollowing:\u000d\u000aselect e.deptno,\u000d\u000a e.ename,\u000d\u000a e.sal,\u000d\u000a (select generic_obj(d.dname,d.loc,sysdate-1)\u000d\u000a from dept d\u000d\u000a where e.deptno=d.deptno) multival\u000d\u000afrom emp e\u000d\u000aDEPTNO ENAME SAL MULTIVAL(VAL1, VAL2, VAL3)\u000d\u000a------ ------ ----- -------------------------------------------------------\u000d\u000a 20 SMITH 800 GENERIC_OBJ('RESEARCH', 'DALLAS', '12-SEP-2020')\u000d\u000a 30 ALLEN 1600 GENERIC_OBJ('SALES', 'CHICAGO', '12-SEP-2020')\u000d\u000a 30 WARD 1250 GENERIC_OBJ('SALES', 'CHICAGO', '12-SEP-2020')\u000d\u000a 20 JONES 2975 GENERIC_OBJ('RESEARCH', 'DALLAS', '12-SEP-2020')\u000d\u000a 30 MARTIN 1250 GENERIC_OBJ('SALES', 'CHICAGO', '12-SEP-2020')\u000d\u000a494 | Chapter 14: Odds \u2019n\u2019 Ends"," 30 BLAKE 2850 GENERIC_OBJ('SALES', 'CHICAGO', '12-SEP-2020')\u000d\u000a 10 CLARK 2450 GENERIC_OBJ('ACCOUNTING', 'NEW YORK', '12-SEP-2020')\u000d\u000a 20 SCOTT 3000 GENERIC_OBJ('RESEARCH', 'DALLAS', '12-SEP-2020')\u000d\u000a 10 KING 5000 GENERIC_OBJ('ACCOUNTING', 'NEW YORK', '12-SEP-2020')\u000d\u000a 30 TURNER 1500 GENERIC_OBJ('SALES', 'CHICAGO', '12-SEP-2020')\u000d\u000a 20 ADAMS 1100 GENERIC_OBJ('RESEARCH', 'DALLAS', '12-SEP-2020')\u000d\u000a 30 JAMES 950 GENERIC_OBJ('SALES', 'CHICAGO', '12-SEP-2020')\u000d\u000a 20 FORD 3000 GENERIC_OBJ('RESEARCH', 'DALLAS', '12-SEP-2020')\u000d\u000a 10 MILLER 1300 GENERIC_OBJ('ACCOUNTING', 'NEW YORK', '12-SEP-2020')\u000d\u000aThe next step is to simply wrap the query in an inline view and extract the attributes.\u000d\u000aIn Oracle, unlike the case with other vendors, you do not generally\u000d\u000aneed to name your inline views. In this particular case, however,\u000d\u000ayou do need to name your inline view. Otherwise, you will not be\u000d\u000aable to reference the object\u2019s attributes.\u000d\u000a14.11 Parsing Serialized Data into Rows\u000d\u000aProblem\u000d\u000aYou have serialized data (stored in strings) that you want to parse and return as rows.\u000d\u000aFor example, you store the following data:\u000d\u000aSTRINGS\u000d\u000a-----------------------------------\u000d\u000aentry:stewiegriffin:lois:brian:\u000d\u000aentry:moe::sizlack:\u000d\u000aentry:petergriffin:meg:chris:\u000d\u000aentry:willie:\u000d\u000aentry:quagmire:mayorwest:cleveland:\u000d\u000aentry:::flanders:\u000d\u000aentry:robo:tchi:ken:\u000d\u000aYou want to convert these serialized strings into the following result set:\u000d\u000aVAL1 VAL2 VAL3\u000d\u000a--------------- --------------- ---------------\u000d\u000amoe sizlack\u000d\u000apetergriffin meg chris\u000d\u000aquagmire mayorwest cleveland\u000d\u000arobo tchi ken\u000d\u000astewiegriffin lois brian\u000d\u000awillie\u000d\u000a flanders\u000d\u000a14.11 Parsing Serialized Data into Rows | 495","Solution\u000d\u000aEach serialized string in this example can store up to three values. The values are\u000d\u000adelimited by colons, and a string may or may not have all three entries. If a string\u000d\u000adoes not have all three entries, you must be careful to place the entries that are avail\u2010\u000d\u000aable into the correct column in the result set. For example, consider the following\u000d\u000arow:\u000d\u000aentry:::flanders:\u000d\u000aThis row represents an entry with the first two values missing and only the third\u000d\u000avalue available. Hence, if you examine the target result set in the \u201cProblem\u201d section,\u000d\u000ayou will notice that for the row FLANDERS is in, both VAL1 and VAL2 are NULL.\u000d\u000aThe key to this solution is nothing more than a string walk with some string parsing,\u000d\u000afollowing by a simple pivot. This solution uses rows from view V, which is defined as\u000d\u000afollows. The example uses Oracle syntax, but since nothing more than string parsing\u000d\u000afunctions are needed for this recipe, converting to other platforms is simple:\u000d\u000acreate view V\u000d\u000a as\u000d\u000aselect 'entry:stewiegriffin:lois:brian:' strings\u000d\u000a from dual\u000d\u000a union all\u000d\u000aselect 'entry:moe::sizlack:'\u000d\u000a from dual\u000d\u000a union all\u000d\u000aselect 'entry:petergriffin:meg:chris:'\u000d\u000a from dual\u000d\u000a union all\u000d\u000aselect 'entry:willie:'\u000d\u000a from dual\u000d\u000a union all\u000d\u000aselect 'entry:quagmire:mayorwest:cleveland:'\u000d\u000a from dual\u000d\u000a union all\u000d\u000aselect 'entry:::flanders:'\u000d\u000a from dual\u000d\u000a union all\u000d\u000aselect 'entry:robo:tchi:ken:'\u000d\u000a from dual\u000d\u000aUsing view V to supply the example data to parse, the solution is as follows:\u000d\u000a 1 with cartesian as (\u000d\u000a 2 select level id\u000d\u000a 3 from dual\u000d\u000a 4 connect by level <= 100\u000d\u000a 5 )\u000d\u000a 6 select max(decode(id,1,substr(strings,p1+1,p2-1))) val1,\u000d\u000a 7 max(decode(id,2,substr(strings,p1+1,p2-1))) val2,\u000d\u000a 8 max(decode(id,3,substr(strings,p1+1,p2-1))) val3\u000d\u000a496 | Chapter 14: Odds \u2019n\u2019 Ends"," 9 from (\u000d\u000a10 select v.strings,\u000d\u000a11 c.id,\u000d\u000a12 instr(v.strings,':',1,c.id) p1,\u000d\u000a13 instr(v.strings,':',1,c.id+1)-instr(v.strings,':',1,c.id) p2\u000d\u000a14 from v, cartesian c\u000d\u000a15 where c.id <= (length(v.strings)-length(replace(v.strings,':')))-1\u000d\u000a16 )\u000d\u000a17 group by strings\u000d\u000a18 order by 1\u000d\u000aDiscussion\u000d\u000aThe first step is to walk the serialized strings:\u000d\u000awith cartesian as (\u000d\u000aselect level id\u000d\u000a from dual\u000d\u000a connect by level <= 100\u000d\u000a)\u000d\u000aselect v.strings,\u000d\u000a c.id\u000d\u000a from v,cartesian c\u000d\u000a where c.id <= (length(v.strings)-length(replace(v.strings,':')))-1\u000d\u000aSTRINGS ID\u000d\u000a----------------------------------- ---\u000d\u000aentry:::flanders: 1\u000d\u000aentry:::flanders: 2\u000d\u000aentry:::flanders: 3\u000d\u000aentry:moe::sizlack: 1\u000d\u000aentry:moe::sizlack: 2\u000d\u000aentry:moe::sizlack: 3\u000d\u000aentry:petergriffin:meg:chris: 1\u000d\u000aentry:petergriffin:meg:chris: 3\u000d\u000aentry:petergriffin:meg:chris: 2\u000d\u000aentry:quagmire:mayorwest:cleveland: 1\u000d\u000aentry:quagmire:mayorwest:cleveland: 3\u000d\u000aentry:quagmire:mayorwest:cleveland: 2\u000d\u000aentry:robo:tchi:ken: 1\u000d\u000aentry:robo:tchi:ken: 2\u000d\u000aentry:robo:tchi:ken: 3\u000d\u000aentry:stewiegriffin:lois:brian: 1\u000d\u000aentry:stewiegriffin:lois:brian: 3\u000d\u000aentry:stewiegriffin:lois:brian: 2\u000d\u000aentry:willie: 1\u000d\u000aThe next step is to use the function INSTR to find the numeric position of each colon\u000d\u000ain each string. Since each value you need to extract is enclosed by two colons, the\u000d\u000anumeric values are aliased P1 and P2, for \u201cposition one\u201d and \u201cposition two\u201d:\u000d\u000a14.11 Parsing Serialized Data into Rows | 497","with cartesian as (\u000d\u000aselect level id\u000d\u000a from dual\u000d\u000a connect by level <= 100\u000d\u000a)\u000d\u000aselect v.strings,\u000d\u000a c.id,\u000d\u000a instr(v.strings,':',1,c.id) p1,\u000d\u000a instr(v.strings,':',1,c.id+1)-instr(v.strings,':',1,c.id) p2\u000d\u000a from v,cartesian c\u000d\u000a where c.id <= (length(v.strings)-length(replace(v.strings,':')))-1\u000d\u000a order by 1\u000d\u000aSTRINGS ID P1 P2\u000d\u000a----------------------------------- --- ---------- ----------\u000d\u000aentry:::flanders: 1 6 1\u000d\u000aentry:::flanders: 2 7 1\u000d\u000aentry:::flanders: 3 8 9\u000d\u000aentry:moe::sizlack: 1 6 4\u000d\u000aentry:moe::sizlack: 2 10 1\u000d\u000aentry:moe::sizlack: 3 11 8\u000d\u000aentry:petergriffin:meg:chris: 1 6 13\u000d\u000aentry:petergriffin:meg:chris: 3 23 6\u000d\u000aentry:petergriffin:meg:chris: 2 19 4\u000d\u000aentry:quagmire:mayorwest:cleveland: 1 6 9\u000d\u000aentry:quagmire:mayorwest:cleveland: 3 25 10\u000d\u000aentry:quagmire:mayorwest:cleveland: 2 15 10\u000d\u000aentry:robo:tchi:ken: 1 6 5\u000d\u000aentry:robo:tchi:ken: 2 11 5\u000d\u000aentry:robo:tchi:ken: 3 16 4\u000d\u000aentry:stewiegriffin:lois:brian: 1 6 14\u000d\u000aentry:stewiegriffin:lois:brian: 3 25 6\u000d\u000aentry:stewiegriffin:lois:brian: 2 20 5\u000d\u000aentry:willie: 1 6 7\u000d\u000aNow that you know the numeric positions for each pair of colons in each string, sim\u2010\u000d\u000aply pass the information to the function SUBSTR to extract values. Since you want to\u000d\u000acreate a result set with three columns, use DECODE to evaluate the ID from the Car\u2010\u000d\u000atesian product:\u000d\u000awith cartesian as (\u000d\u000a select level id\u000d\u000a from dual\u000d\u000a connect by level <= 100\u000d\u000a )\u000d\u000a select decode(id,1,substr(strings,p1+1,p2-1)) val1,\u000d\u000a decode(id,2,substr(strings,p1+1,p2-1)) val2,\u000d\u000a decode(id,3,substr(strings,p1+1,p2-1)) val3\u000d\u000a from (\u000d\u000a select v.strings,\u000d\u000a c.id,\u000d\u000a instr(v.strings,':',1,c.id) p1,\u000d\u000a498 | Chapter 14: Odds \u2019n\u2019 Ends"," instr(v.strings,':',1,c.id+1)-instr(v.strings,':',1,c.id) p2\u000d\u000a from v,cartesian c\u000d\u000a where c.id <= (length(v.strings)-length(replace(v.strings,':')))-1\u000d\u000a )\u000d\u000a order by 1\u000d\u000a VAL1 VAL2 VAL3\u000d\u000a --------------- --------------- --------------\u000d\u000a moe\u000d\u000a petergriffin\u000d\u000a quagmire\u000d\u000a robo\u000d\u000a stewiegriffin\u000d\u000a willie\u000d\u000a lois\u000d\u000a meg\u000d\u000a mayorwest\u000d\u000a tchi\u000d\u000a brian\u000d\u000a sizlack\u000d\u000a chris\u000d\u000a cleveland\u000d\u000a flanders\u000d\u000a ken\u000d\u000aThe last step is to apply an aggregate function to the values returned by SUBSTR\u000d\u000awhile grouping by ID, to make a human-readable result set:\u000d\u000awith cartesian as (\u000d\u000aselect level id\u000d\u000a from dual\u000d\u000a connect by level <= 100\u000d\u000a)\u000d\u000aselect max(decode(id,1,substr(strings,p1+1,p2-1))) val1,\u000d\u000a max(decode(id,2,substr(strings,p1+1,p2-1))) val2,\u000d\u000a max(decode(id,3,substr(strings,p1+1,p2-1))) val3\u000d\u000a from (\u000d\u000aselect v.strings,\u000d\u000a c.id,\u000d\u000a instr(v.strings,':',1,c.id) p1,\u000d\u000a instr(v.strings,':',1,c.id+1)-instr(v.strings,':',1,c.id) p2\u000d\u000a from v,cartesian c\u000d\u000awhere c.id <= (length(v.strings)-length(replace(v.strings,':')))-1\u000d\u000a )\u000d\u000agroup by strings\u000d\u000aorder by 1\u000d\u000aVAL1 VAL2 VAL3\u000d\u000a--------------- --------------- -----------\u000d\u000amoe sizlack\u000d\u000apetergriffin meg chris\u000d\u000a14.11 Parsing Serialized Data into Rows | 499","quagmire mayorwest cleveland\u000d\u000arobo tchi ken\u000d\u000astewiegriffin lois brian\u000d\u000awillie\u000d\u000a flanders\u000d\u000a14.12 Calculating Percent Relative to Total\u000d\u000aProblem\u000d\u000aYou want to report a set of numeric values, and you want to show each value as a\u000d\u000apercentage of the whole. For example, you are on an Oracle system and you want to\u000d\u000areturn a result set that shows the breakdown of salaries by JOB so that you can deter\u2010\u000d\u000amine which JOB position costs the company the most money. You also want to\u000d\u000ainclude the number of employees per JOB to prevent the results from being mislead\u2010\u000d\u000aing. You want to produce the following report:\u000d\u000aJOB NUM_EMPS PCT_OF_ALL_SALARIES\u000d\u000a--------- ---------- -------------------\u000d\u000aCLERK 4 14\u000d\u000aANALYST 2 20\u000d\u000aMANAGER 3 28\u000d\u000aSALESMAN 4 19\u000d\u000aPRESIDENT 1 17\u000d\u000aAs you can see, if the number of employees is not included in the report, it looks as if\u000d\u000athe president position takes very little of the overall salary. Seeing that there is only\u000d\u000aone president helps put into perspective what that 17% means.\u000d\u000aSolution\u000d\u000aOnly Oracle enables a decent solution to this problem, which involves using the builtin function RATIO_TO_REPORT. To calculate percentages of the whole for other\u000d\u000adatabases, you can use division as shown in Recipe 7.11:\u000d\u000a1 select job,num_emps,sum(round(pct)) pct_of_all_salaries\u000d\u000a2 from (\u000d\u000a3 select job,\u000d\u000a4 count(*)over(partition by job) num_emps,\u000d\u000a5 ratio_to_report(sal)over()*100 pct\u000d\u000a6 from emp\u000d\u000a7 )\u000d\u000a8 group by job,num_emps\u000d\u000a500 | Chapter 14: Odds \u2019n\u2019 Ends","Discussion\u000d\u000aThe first step is to use the window function COUNT OVER to return the number of\u000d\u000aemployees per JOB. Then use RATIO_TO_REPORT to return the percentage each\u000d\u000asalary counts against the total (the value is returned in decimal):\u000d\u000aselect job,\u000d\u000a count(*)over(partition by job) num_emps,\u000d\u000a ratio_to_report(sal)over()*100 pct\u000d\u000a from emp\u000d\u000aJOB NUM_EMPS PCT\u000d\u000a--------- ---------- ----------\u000d\u000aANALYST 2 10.3359173\u000d\u000aANALYST 2 10.3359173\u000d\u000aCLERK 4 2.75624462\u000d\u000aCLERK 4 3.78983635\u000d\u000aCLERK 4 4.4788975\u000d\u000aCLERK 4 3.27304048\u000d\u000aMANAGER 3 10.2497847\u000d\u000aMANAGER 3 8.44099914\u000d\u000aMANAGER 3 9.81912145\u000d\u000aPRESIDENT 1 17.2265289\u000d\u000aSALESMAN 4 5.51248923\u000d\u000aSALESMAN 4 4.30663221\u000d\u000aSALESMAN 4 5.16795866\u000d\u000aSALESMAN 4 4.30663221\u000d\u000aThe last step is to use the aggregate function SUM to sum the values returned by\u000d\u000aRATIO_TO_REPORT. Be sure to group by JOB and NUM_EMPS. Multiply by 100 to\u000d\u000areturn a whole number that represents a percentage (e.g., to return 25 rather than\u000d\u000a0.25 for 25%):\u000d\u000aselect job,num_emps,sum(round(pct)) pct_of_all_salaries\u000d\u000a from (\u000d\u000aselect job,\u000d\u000a count(*)over(partition by job) num_emps,\u000d\u000a ratio_to_report(sal)over()*100 pct\u000d\u000a from emp\u000d\u000a )\u000d\u000a group by job,num_emps\u000d\u000aJOB NUM_EMPS PCT_OF_ALL_SALARIES\u000d\u000a--------- ---------- -------------------\u000d\u000aCLERK 4 14\u000d\u000aANALYST 2 20\u000d\u000aMANAGER 3 28\u000d\u000aSALESMAN 4 19\u000d\u000aPRESIDENT 1 17\u000d\u000a14.12 Calculating Percent Relative to Total | 501","14.13 Testing for Existence of a Value Within a Group\u000d\u000aProblem\u000d\u000aYou want to create a Boolean flag for a row depending on whether any row in its\u000d\u000agroup contains a specific value. Consider an example of a student who has taken a\u000d\u000acertain number of exams during a period of time. A student will take three exams\u000d\u000aover three months. If a student passes one of these exams, the requirement is satisfied\u000d\u000aand a flag should be returned to express that fact. If a student did not pass any of the\u000d\u000athree tests in the three-month period, then an additional flag should be returned to\u000d\u000aexpress that fact as well. Consider the following example (using Oracle syntax to\u000d\u000amake up rows for this example; minor modifications are necessary for the other ven\u2010\u000d\u000adors, making user of window functions):\u000d\u000acreate view V\u000d\u000aas\u000d\u000aselect 1 student_id,\u000d\u000a 1 test_id,\u000d\u000a 2 grade_id,\u000d\u000a 1 period_id,\u000d\u000a to_date('02/01/2020','MM/DD/YYYY') test_date,\u000d\u000a 0 pass_fail\u000d\u000a from dual union all\u000d\u000aselect 1, 2, 2, 1, to_date('03/01/2020','MM/DD/YYYY'), 1 from dual union all\u000d\u000aselect 1, 3, 2, 1, to_date('04/01/2020','MM/DD/YYYY'), 0 from dual union all\u000d\u000aselect 1, 4, 2, 2, to_date('05/01/2020','MM/DD/YYYY'), 0 from dual union all\u000d\u000aselect 1, 5, 2, 2, to_date('06/01/2020','MM/DD/YYYY'), 0 from dual union all\u000d\u000aselect 1, 6, 2, 2, to_date('07/01/2020','MM/DD/YYYY'), 0 from dual\u000d\u000aselect *\u000d\u000a from V\u000d\u000aSTUDENT_ID TEST_ID GRADE_ID PERIOD_ID TEST_DATE PASS_FAIL\u000d\u000a---------- ------- -------- --------- ----------- ---------\u000d\u000a 1 1 2 1 01-FEB-2020 0\u000d\u000a 1 2 2 1 01-MAR-2020 1\u000d\u000a 1 3 2 1 01-APR-2020 0\u000d\u000a 1 4 2 2 01-MAY-2020 0\u000d\u000a 1 5 2 2 01-JUN-2020 0\u000d\u000a 1 6 2 2 01-JUL-2020 0\u000d\u000aExamining the previous result set, you see that the student has taken six tests over\u000d\u000atwo, three-month periods. The student has passed one test (1 means \u201cpass\u201d; 0 means\u000d\u000a\u201cfail\u201d); thus, the requirement is satisfied for the entire first period. Because the student\u000d\u000adid not pass any exams during the second period (the next three months),\u000d\u000aPASS_FAIL is 0 for all three exams. You want to return a result set that highlights\u000d\u000awhether a student has passed a test for a given period. Ultimately you want to return\u000d\u000athe following result set:\u000d\u000a502 | Chapter 14: Odds \u2019n\u2019 Ends","STUDENT_ID TEST_ID GRADE_ID PERIOD_ID TEST_DATE METREQ IN_PROGRESS\u000d\u000a---------- ------- -------- --------- ----------- ------ -----------\u000d\u000a 1 1 2 1 01-FEB-2020 + 0\u000d\u000a 1 2 2 1 01-MAR-2020 + 0\u000d\u000a 1 3 2 1 01-APR-2020 + 0\u000d\u000a 1 4 2 2 01-MAY-2020 - 0\u000d\u000a 1 5 2 2 01-JUN-2020 - 0\u000d\u000a 1 6 2 2 01-JUL-2020 - 1\u000d\u000aThe values for METREQ (\u201cmet requirement\u201d) are + and \u2013, signifying the student\u000d\u000aeither has or has not satisfied the requirement of passing at least one test in a period\u000d\u000a(three-month span), respectively. The value for IN_PROGRESS should be 0 if a stu\u2010\u000d\u000adent has already passed a test in a given period. If a student has not passed a test for a\u000d\u000agiven period, then the row that has the latest exam date for that student will have a\u000d\u000avalue of 1 for IN_PROGRESS.\u000d\u000aSolution\u000d\u000aThis problem appears tricky because you have to treat rows in a group as a group and\u000d\u000anot as individuals. Consider the values for PASS_FAIL in the \u201cProblem\u201d section. If\u000d\u000ayou evaluate row by row, it appears that the value for METREQ for each row except\u000d\u000aTEST_ID 2 should be \u2013, when it\u2019s not the case. You must ensure you evaluate the\u000d\u000arows as a group. By using the window function MAX OVER, you can easily deter\u2010\u000d\u000amine whether a student passed at least one test during a particular period. Once you\u000d\u000ahave that information, the \u201cBoolean\u201d values are a simple matter of using CASE\u000d\u000aexpressions:\u000d\u000a 1 select student_id,\u000d\u000a 2 test_id,\u000d\u000a 3 grade_id,\u000d\u000a 4 period_id,\u000d\u000a 5 test_date,\u000d\u000a 6 decode( grp_p_f,1,lpad('+',6),lpad('-',6) ) metreq,\u000d\u000a 7 decode( grp_p_f,1,0,\u000d\u000a 8 decode( test_date,last_test,1,0 ) ) in_progress\u000d\u000a 9 from (\u000d\u000a10 select V.*,\u000d\u000a11 max(pass_fail)over(partition by\u000d\u000a12 student_id,grade_id,period_id) grp_p_f,\u000d\u000a13 max(test_date)over(partition by\u000d\u000a14 student_id,grade_id,period_id) last_test\u000d\u000a15 from V\u000d\u000a16 ) x\u000d\u000aDiscussion\u000d\u000aThe key to the solution is using the window function MAX OVER to return the\u000d\u000agreatest value of PASS_FAIL for each group. Because the values for PASS_FAIL are\u000d\u000a14.13 Testing for Existence of a Value Within a Group | 503","only 1 or 0, if a student passed at least one exam, then MAX OVER would return 1\u000d\u000afor the entire group. How this works is shown here:\u000d\u000aselect V.*,\u000d\u000a max(pass_fail)over(partition by\u000d\u000a student_id,grade_id,period_id) grp_pass_fail\u000d\u000a from V\u000d\u000aSTUDENT_ID TEST_ID GRADE_ID PERIOD_ID TEST_DATE PASS_FAIL GRP_PASS_FAIL\u000d\u000a---------- ------- -------- --------- ----------- --------- -------------\u000d\u000a 1 1 2 1 01-FEB-2020 0 1\u000d\u000a 1 2 2 1 01-MAR-2020 1 1\u000d\u000a 1 3 2 1 01-APR-2020 0 1\u000d\u000a 1 4 2 2 01-MAY-2020 0 0\u000d\u000a 1 5 2 2 01-JUN-2020 0 0\u000d\u000a 1 6 2 2 01-JUL-2020 0 0\u000d\u000aThe previous result set shows that the student passed at least one test during the first\u000d\u000aperiod; thus, the entire group has a value of 1 or \u201cpass.\u201d The next requirement is that\u000d\u000aif the student has not passed any tests in a period, return a value of 1 for the IN_\u000d\u000aPROGRESS flag for the latest test date in that group. You can use the window func\u2010\u000d\u000ation MAX OVER to do this as well:\u000d\u000aselect V.*,\u000d\u000a max(pass_fail)over(partition by\u000d\u000a student_id,grade_id,period_id) grp_p_f,\u000d\u000a max(test_date)over(partition by\u000d\u000a student_id,grade_id,period_id) last_test\u000d\u000a from V\u000d\u000aSTUDENT_ID TEST_ID GRADE_ID PERIOD_ID TEST_DATE PASS_FAIL GRP_P_F LAST_TEST\u000d\u000a---------- ------- -------- --------- ----------- --------- ------- -----------\u000d\u000a 1 1 2 1 01-FEB-2020 0 1 01-APR-2020\u000d\u000a 1 2 2 1 01-MAR-2020 1 1 01-APR-2020\u000d\u000a 1 3 2 1 01-APR-2020 0 1 01-APR-2020\u000d\u000a 1 4 2 2 01-MAY-2020 0 0 01-JUL-2020\u000d\u000a 1 5 2 2 01-JUN-2020 0 0 01-JUL-2020\u000d\u000a 1 6 2 2 01-JUL-2020 0 0 01-JUL-2020\u000d\u000aNow that you have determined for which period the student has passed a test and\u000d\u000awhat the latest test date for each period is, the last step is simply a matter of applying\u000d\u000asome formatting magic to make the result set look nice. The ultimate solution uses\u000d\u000aOracle\u2019s DECODE function (CASE supporters, eat your hearts out) to create the\u000d\u000aMETREQ and IN_PROGRESS columns. Use the LPAD function to right justify the\u000d\u000avalues for METREQ:\u000d\u000aselect student_id,\u000d\u000a test_id,\u000d\u000a grade_id,\u000d\u000a period_id,\u000d\u000a test_date,\u000d\u000a504 | Chapter 14: Odds \u2019n\u2019 Ends"," decode( grp_p_f,1,lpad('+',6),lpad('-',6) ) metreq,\u000d\u000a decode( grp_p_f,1,0,\u000d\u000a decode( test_date,last_test,1,0 ) ) in_progress\u000d\u000a from (\u000d\u000aselect V.*,\u000d\u000a max(pass_fail)over(partition by\u000d\u000a student_id,grade_id,period_id) grp_p_f,\u000d\u000a max(test_date)over(partition by\u000d\u000a student_id,grade_id,period_id) last_test\u000d\u000a from V\u000d\u000a ) x\u000d\u000aSTUDENT_ID TEST_ID GRADE_ID PERIOD_ID TEST_DATE METREQ IN_PROGRESS\u000d\u000a---------- ------- -------- --------- ----------- ------ -----------\u000d\u000a 1 1 2 1 01-FEB-2020 + 0\u000d\u000a 1 2 2 1 01-MAR-2020 + 0\u000d\u000a 1 3 2 1 01-APR-2020 + 0\u000d\u000a 1 4 2 2 01-MAY-2020 - 0\u000d\u000a 1 5 2 2 01-JUN-2020 - 0\u000d\u000a 1 6 2 2 01-JUL-2020 - 1\u000d\u000a14.14 Summing Up\u000d\u000aSQL is more powerful than many credit it. Throughout this book we have tried to\u000d\u000achallenge you to see more applications than are typically noted. In this chapter, we\u2019ve\u000d\u000aheaded straight for the edge cases and tried to show just how you can push SQL, both\u000d\u000awith standard features and with certain vendor-specific features.\u000d\u000a14.14 Summing Up | 505","","APPENDIX A\u000d\u000aWindow Function Refresher\u000d\u000aThe recipes in this book take full advantage of the window functions added to the\u000d\u000aISO SQL standard in 2003, as well as vendor-specific window functions. This appen\u2010\u000d\u000adix is meant to serve as a brief overview of how window functions work. Window\u000d\u000afunctions make many typically difficult tasks (difficult to solve using standard SQL,\u000d\u000athat is) quite easy. For a complete list of window functions available, full syntax, and\u000d\u000ain-depth coverage of how they work, please consult your vendor\u2019s documentation.\u000d\u000aGrouping\u000d\u000aBefore moving on to window functions, it is crucial that you understand how group\u2010\u000d\u000aing works in SQL\u2014the concept of grouping results in SQL can be difficult to master.\u000d\u000aThe problems stem from not fully understanding how the GROUP BY clause works\u000d\u000aand why certain queries return certain results when using GROUP BY.\u000d\u000aSimply stated, grouping is a way to organize like rows together. When you use\u000d\u000aGROUP BY in a query, each row in the result set is a group and represents one or\u000d\u000amore rows with the same values in one or more columns that you specify. That\u2019s the\u000d\u000agist of it.\u000d\u000aIf a group is simply a unique instance of a row that represents one or more rows with\u000d\u000athe same value for a particular column (or columns), then practical examples of\u000d\u000agroups from table EMP include all employees in department 10 (the common value\u000d\u000afor these employees that enables them to be in the same group is DEPTNO=10) or all\u000d\u000aclerks (the common value for these employees that enables them to be in the same\u000d\u000agroup is JOB=CLERK). Consider the following queries. The first shows all employees\u000d\u000ain department 10; the second query groups the employees in department 10 and\u000d\u000areturns the following information about the group: the number of rows (members) in\u000d\u000athe group, the highest salary, and the lowest salary:\u000d\u000a507","select deptno,ename\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000aDEPTNO ENAME\u000d\u000a------ ----------\u000d\u000a 10 CLARK\u000d\u000a 10 KING\u000d\u000a 10 MILLER\u000d\u000aselect deptno,\u000d\u000a count(*) as cnt,\u000d\u000a max(sal) as hi_sal,\u000d\u000a min(sal) as lo_sal\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000a group by deptno\u000d\u000aDEPTNO CNT HI_SAL LO_SAL\u000d\u000a------ ---------- ---------- ----------\u000d\u000a 10 3 5000 1300\u000d\u000aIf you were not able to group the employees in department 10 together, to get the\u000d\u000ainformation in the second query, you would have to manually inspect the rows for\u000d\u000athat department (trivial if there are only three rows, but what if there were three mil\u2010\u000d\u000alion rows?). So, why would anyone want to group? Reasons for doing so vary; perhaps\u000d\u000ayou want to see how many different groups exist or how many members (rows) are in\u000d\u000aeach group. As you can see from this simple example, grouping allows you to get\u000d\u000ainformation about many rows in a table without having to inspect them one by one.\u000d\u000aDefinition of an SQL Group\u000d\u000aIn mathematics, a group is defined, for the most part, as (G, \u2022, e), where G is a set, \u2022 is\u000d\u000aa binary operation in G, and e is a member of G. We will use this definition as the\u000d\u000afoundation for what a SQL group is. A SQL group will be defined as (G, e), where G is\u000d\u000aa result set of a single or self-contained query that uses GROUP BY, e is a member of\u000d\u000aG, and the following axioms are satisfied:\u000d\u000a\u2022 For each e in G, e is distinct and represents one or more instances of e.\u000d\u000a\u2022 For each e in G, the aggregate function COUNT returns a value > 0.\u000d\u000aThe result set is included in the definition of a SQL group to rein\u2010\u000d\u000aforce the fact that we are defining what groups are when working\u000d\u000awith queries only. Thus, it would be accurate to replace e in each\u000d\u000aaxiom with the word row because the rows in the result set are\u000d\u000atechnically the groups.\u000d\u000a508 | Appendix A: Window Function Refresher","Because these properties are fundamental to what we consider a group, it is important\u000d\u000athat we prove they are true (and we will proceed to do so through the use of some\u000d\u000aexample SQL queries).\u000d\u000aGroups are nonempty\u000d\u000aBy its very definition, a group must have at least one member (or row). If we accept\u000d\u000athis as a truth, then it can be said that a group cannot be created from an empty table.\u000d\u000aTo prove that proposition true, simply try to prove it is false. The following example\u000d\u000acreates an empty table and then attempts to create groups via three different queries\u000d\u000aagainst that empty table:\u000d\u000acreate table fruits (name varchar(10))\u000d\u000aselect name\u000d\u000a from fruits\u000d\u000a group by name\u000d\u000a(no rows selected)\u000d\u000aselect count(*) as cnt\u000d\u000a from fruits\u000d\u000a group by name\u000d\u000a(no rows selected)\u000d\u000aselect name, count(*) as cnt\u000d\u000a from fruits\u000d\u000a group by name\u000d\u000a(no rows selected)\u000d\u000aAs you can see from these queries, it is impossible to create what SQL considers a\u000d\u000agroup from an empty table.\u000d\u000aGroups are distinct\u000d\u000aNow let\u2019s prove that the groups created via queries with a GROUP BY clause are dis\u2010\u000d\u000atinct. The following example inserts five rows into table FRUITS and then creates\u000d\u000agroups from those rows:\u000d\u000ainsert into fruits values ('Oranges')\u000d\u000ainsert into fruits values ('Oranges')\u000d\u000ainsert into fruits values ('Oranges')\u000d\u000ainsert into fruits values ('Apple')\u000d\u000ainsert into fruits values ('Peach')\u000d\u000aselect *\u000d\u000a from fruits\u000d\u000aWindow Function Refresher | 509","NAME\u000d\u000a--------\u000d\u000aOranges\u000d\u000aOranges\u000d\u000aOranges\u000d\u000aApple\u000d\u000aPeach\u000d\u000aselect name\u000d\u000a from fruits\u000d\u000a group by name\u000d\u000aNAME\u000d\u000a-------\u000d\u000aApple\u000d\u000aOranges\u000d\u000aPeach\u000d\u000aselect name, count(*) as cnt\u000d\u000a from fruits\u000d\u000a group by name\u000d\u000aNAME CNT\u000d\u000a------- --------\u000d\u000aApple 1\u000d\u000aOranges 3\u000d\u000aPeach 1\u000d\u000aThe first query shows that \u201cOranges\u201d occurs three times in table FRUITS. However,\u000d\u000athe second and third queries (using GROUP BY) return only one instance of\u000d\u000a\u201cOranges.\u201d Taken together, these queries prove that the rows in the result set (e in G,\u000d\u000afrom our definition) are distinct, and each value of NAME represents one or more\u000d\u000ainstances of itself in table FRUITS.\u000d\u000aKnowing that groups are distinct is important because it means, typically, you would\u000d\u000anot use the DISTINCT keyword in your SELECT list when using a GROUP BY in\u000d\u000ayour queries.\u000d\u000aWe don\u2019t pretend GROUP BY and DISTINCT are the same. They\u000d\u000arepresent two completely different concepts. We do state that the\u000d\u000aitems listed in the GROUP BY clause will be distinct in the result\u000d\u000aset and that using DISTINCT as well as GROUP BY is redundant.\u000d\u000a510 | Appendix A: Window Function Refresher","Frege\u2019s Axiom and Russell\u2019s Paradox\u000d\u000aFor those of you who are interested, Frege\u2019s axiom of abstraction, based on Cantor\u2019s\u000d\u000asolution for defining set membership for infinite or uncountable sets, states that,\u000d\u000agiven a specific identifying property, there exists a set whose members are only those\u000d\u000aitems having that property. The source of trouble, as put by Robert Stoll, \u201cis the unre\u2010\u000d\u000astricted use of the principal of abstraction.\u201d Bertrand Russell asked Gottlob Frege to\u000d\u000aconsider a set whose members are sets and have the defining property of not being\u000d\u000amembers of themselves.\u000d\u000aAs Russell pointed out, the axiom of abstraction gives too much freedom because you\u000d\u000aare simply specifiying a condition or property to define set membership; thus, a con\u2010\u000d\u000atradiction can be found. To better explain how a contradiction can be found, he\u000d\u000adevised the \u201cBarber puzzle.\u201d The Barber puzzle states:\u000d\u000aIn a certain town there is a male barber who shaves all those men, and only those\u000d\u000amen, who do not shave themselves. If this is true, who, then, shaves the barber?\u000d\u000aFor a more concrete example, consider the set that can be described as:\u000d\u000aFor all members x in y that satisfy a specific condition (P).\u000d\u000aThe mathematical notation for this description is:\u000d\u000a{x e y | P(x)}\u000d\u000aBecause the previous set considers only those x in y that satisfy a condition (P), you\u000d\u000amay find it more intuitive to describe the set as x is a member of y if and only if x\u000d\u000asatis\u0087es a condition (P).\u000d\u000aAt this point let us define this condition P(x) as x is not a member of x:\u000d\u000a ( x e x )\u000d\u000aThe set is now defined as x is a member of y if and only if x is not a member of x:\u000d\u000a {x e y | ( x e x )}\u000d\u000aRussell\u2019s paradox may not be clear to you yet, but ask yourself this: can the previous\u000d\u000aset be a member of itself? Let\u2019s assume that x = y and look at the set again. The follow\u2010\u000d\u000aing set can be defined as y is a member of y if and only if y is not a member of y:\u000d\u000a {y e y | ( y e y )}\u000d\u000aSimply put, Russell\u2019s paradox leaves us in a position to have a set that is concurrently a\u000d\u000amember of itself and not a member of itself, which is a contradiction. Intuitive think\u2010\u000d\u000aing would lead one to believe this isn\u2019t a problem at all; indeed, how can a set be a\u000d\u000amember of itself? The set of all books, after all, is not a book. So why does this para\u2010\u000d\u000adox exist, and how can it be an issue? It becomes an issue when you consider more\u000d\u000aabstract applications of set theory. For example, a \u201cpractical\u201d application of Russell\u2019s\u000d\u000aparadox can be demonstrated by considering the set of all sets. If we allow such a\u000d\u000aWindow Function Refresher | 511","concept to exist, then by its very definition, it must be a member of itself (it is, after\u000d\u000aall, the set of all sets). What then happens when you apply the previous P(x) to the set\u000d\u000aof all sets? Simply stated, Russell\u2019s paradox would state that the set of all sets is a mem\u2010\u000d\u000aber of itself if and only if it is not a member of itself\u2014clearly a contradiction.\u000d\u000aFor those of you who are interested, Ernst Zermelo developed the axiom schema of\u000d\u000aseparation (also referred to as the axiom schema of subsets or the axiom of speci\u0087ca\u2010\u000d\u000ation) to elegantly sidestep Russell\u2019s paradox in axiomatic set theory.\u000d\u000aCOUNT is never zero\u000d\u000aThe queries and results in the preceding section also prove the final axiom that the\u000d\u000aaggregate function COUNT will never return zero when used in a query with\u000d\u000aGROUP BY on a nonempty table. It should not be surprising that you cannot return\u000d\u000aa count of zero for a group. We have already proved that a group cannot be created\u000d\u000afrom an empty table; thus, a group must have at least one row. If at least one row\u000d\u000aexists, then the count will always be at least one.\u000d\u000aRemember, we are talking about using COUNT with GROUP BY,\u000d\u000anot COUNT by itself. A query using COUNT without a GROUP\u000d\u000aBY on an empty table will, of course, return zero.\u000d\u000aParadoxes\u000d\u000aThe following quote is from Gottlob Frege in response to Bertrand Russell\u2019s discovery\u000d\u000aof a contradiction to Frege\u2019s axiom of abstraction in set theory:\u000d\u000aHardly anything more unfortunate can befall a scientific writer than to have one of the\u000d\u000afoundations of his edifice shaken after the work is finished\u2026. This was the position I\u000d\u000awas placed in by a letter of Mr. Bertrand Russell, just when the printing of this volume\u000d\u000awas nearing its completion.\u000d\u000aParadoxes many times provide scenarios that would seem to contradict established\u000d\u000atheories or ideas. In many cases these contradictions are localized and can be\u000d\u000a\u201cworked around,\u201d or they are applicable to such small test cases that they can be safely\u000d\u000aignored.\u000d\u000aYou may have guessed by now that the point to all this discussion of paradoxes is that\u000d\u000athere exists a paradox concerning our definition of an SQL group, and that paradox\u000d\u000amust be addressed. Although our focus right now is on groups, ultimately we are dis\u2010\u000d\u000acussing SQL queries. In its GROUP BY clause, a query may have a wide range of val\u2010\u000d\u000aues such as constants, expressions, or, most commonly, columns from a table. We pay\u000d\u000aa price for this flexibility, because NULL is a valid \u201cvalue\u201d in SQL. NULLs present\u000d\u000aproblems because they are effectively ignored by aggregate functions. With that said,\u000d\u000a512 | Appendix A: Window Function Refresher","if a table consists of a single row and its value is NULL, what would the aggregate\u000d\u000afunction COUNT return when used in a GROUP BY query? By our very definition,\u000d\u000awhen using GROUP BY and the aggregate function COUNT, a value >= 1 must be\u000d\u000areturned. What happens, then, in the case of values ignored by functions such as\u000d\u000aCOUNT, and what does this mean to our definition of a GROUP? Consider the fol\u2010\u000d\u000alowing example, which reveals the NULL group paradox (using the function COA\u2010\u000d\u000aLESCE when necessary for readability):\u000d\u000aselect *\u000d\u000a from fruits\u000d\u000aNAME\u000d\u000a-------\u000d\u000aOranges\u000d\u000aOranges\u000d\u000aOranges\u000d\u000aApple\u000d\u000aPeach\u000d\u000ainsert into fruits values (null)\u000d\u000ainsert into fruits values (null)\u000d\u000ainsert into fruits values (null)\u000d\u000ainsert into fruits values (null)\u000d\u000ainsert into fruits values (null)\u000d\u000aselect coalesce(name,'NULL') as name\u000d\u000a from fruits\u000d\u000aNAME\u000d\u000a--------\u000d\u000aOranges\u000d\u000aOranges\u000d\u000aOranges\u000d\u000aApple\u000d\u000aPeach\u000d\u000aNULL\u000d\u000aNULL\u000d\u000aNULL\u000d\u000aNULL\u000d\u000aNULL\u000d\u000aselect coalesce(name,'NULL') as name,\u000d\u000a count(name) as cnt\u000d\u000a from fruits\u000d\u000a group by name\u000d\u000aNAME CNT\u000d\u000a-------- ----------\u000d\u000aApple 1\u000d\u000aNULL 0\u000d\u000aWindow Function Refresher | 513","Oranges 3\u000d\u000aPeach 1\u000d\u000aIt would seem that the presence of NULL values in our table introduces a contradic\u2010\u000d\u000ation, or paradox, to our definition of a SQL group. Fortunately, this contradiction is\u000d\u000anot a real cause for concern, because the paradox has more to do with the implemen\u2010\u000d\u000atation of aggregate functions than our definition. Consider the final query in the pre\u2010\u000d\u000aceding set; a general problem statement for that query would be:\u000d\u000aCount the number of times each name occurs in table FRUITS or count the number of\u000d\u000amembers in each group.\u000d\u000aExamining the previous INSERT statements, it\u2019s clear that there are five rows with\u000d\u000aNULL values, which means there exists a NULL group with five members.\u000d\u000aWhile NULL certainly has properties that differentiate it from\u000d\u000aother values, it is nevertheless a value and can in fact be a group.\u000d\u000aHow, then, can we write the query to return a count of 5 instead of 0, thus returning\u000d\u000athe information we are looking for while conforming to our definition of a group?\u000d\u000aThe following example shows a workaround to deal with the NULL group paradox:\u000d\u000aselect coalesce(name,'NULL') as name,\u000d\u000a count(*) as cnt\u000d\u000a from fruits\u000d\u000a group by name\u000d\u000aNAME CNT\u000d\u000a--------- --------\u000d\u000aApple 1\u000d\u000aOranges 3\u000d\u000aPeach 1\u000d\u000aNULL 5\u000d\u000aThe workaround is to use COUNT(*) rather than COUNT(NAME) to avoid the\u000d\u000aNULL group paradox. Aggregate functions will ignore NULL values if any exist in the\u000d\u000acolumn passed to them. Thus, to avoid a zero when using COUNT, do not pass the\u000d\u000acolumn name; instead, pass in an asterisk (*). The * causes the COUNT function to\u000d\u000acount rows rather than the actual column values, so whether the actual values are\u000d\u000aNULL or not NULL is irrelevant.\u000d\u000aOne more paradox has to do with the axiom that each group in a result set (for each e\u000d\u000ain G) is distinct. Because of the nature of SQL result sets and tables, which are more\u000d\u000aaccurately defined as multisets or \u201cbags,\u201d not sets (because duplicate rows are\u000d\u000aallowed), it is possible to return a result set with duplicate groups. Consider the fol\u2010\u000d\u000alowing queries:\u000d\u000a514 | Appendix A: Window Function Refresher","select coalesce(name,'NULL') as name,\u000d\u000a count(*) as cnt\u000d\u000a from fruits\u000d\u000a group by name\u000d\u000a union all\u000d\u000aselect coalesce(name,'NULL') as name,\u000d\u000a count(*) as cnt\u000d\u000a from fruits\u000d\u000a group by name\u000d\u000aNAME CNT\u000d\u000a---------- ---------\u000d\u000aApple 1\u000d\u000aOranges 3\u000d\u000aPeach 1\u000d\u000aNULL 5\u000d\u000aApple 1\u000d\u000aOranges 3\u000d\u000aPeach 1\u000d\u000aNULL 5\u000d\u000aselect x.*\u000d\u000a from (\u000d\u000aselect coalesce(name,'NULL') as name,\u000d\u000a count(*) as cnt\u000d\u000a from fruits\u000d\u000a group by name\u000d\u000a ) x,\u000d\u000a (select deptno from dept) y\u000d\u000aNAME CNT\u000d\u000a---------- ----------\u000d\u000aApple 1\u000d\u000aApple 1\u000d\u000aApple 1\u000d\u000aApple 1\u000d\u000aOranges 3\u000d\u000aOranges 3\u000d\u000aOranges 3\u000d\u000aOranges 3\u000d\u000aPeach 1\u000d\u000aPeach 1\u000d\u000aPeach 1\u000d\u000aPeach 1\u000d\u000aNULL 5\u000d\u000aNULL 5\u000d\u000aNULL 5\u000d\u000aNULL 5\u000d\u000aAs you can see in these queries, the groups are in fact repeated in the final results.\u000d\u000aFortunately, this is not much to worry about because it represents only a partial\u000d\u000aWindow Function Refresher | 515","paradox. The first property of a group states that for (G, e), G is a result set from a\u000d\u000asingle or self-contained query that uses GROUP BY. Simply put, the result set from\u000d\u000aany GROUP BY query itself conforms to our definition of a group. It is only when\u000d\u000ayou combine the result sets from two GROUP BY queries to create a multiset that\u000d\u000agroups may repeat. The first query in the preceding example uses UNION ALL,\u000d\u000awhich is not a set operation but a multiset operation, and invokes GROUP BY twice,\u000d\u000aeffectively executing two queries.\u000d\u000aIf you use UNION, which is a set operation, you will not see\u000d\u000arepeating groups.\u000d\u000aThe second query in the preceding set uses a Cartesian product, which only works if\u000d\u000ayou materialize the group first and then perform the Cartesian. Thus, the GROUP BY\u000d\u000aquery when self-contained conforms to our definition. Neither of the two examples\u000d\u000atakes anything away from the definition of a SQL group. They are shown for com\u2010\u000d\u000apleteness, and so that you can be aware that almost anything is possible in SQL.\u000d\u000aRelationship Between SELECT and GROUP BY\u000d\u000aWith the concept of a group defined and proved, it is now time to move on to more\u000d\u000apractical matters concerning queries using GROUP BY. It is important to understand\u000d\u000athe relationship between the SELECT clause and the GROUP BY clause when group\u2010\u000d\u000aing in SQL. It is important to keep in mind when using aggregate functions such as\u000d\u000aCOUNT that any item in your SELECT list that is not used as an argument to an\u000d\u000aaggregate function must be part of your group. For example, if you write a SELECT\u000d\u000aclause such as this:\u000d\u000aselect deptno, count(*) as cnt\u000d\u000a from emp\u000d\u000athen you must list DEPTNO in your GROUP BY clause:\u000d\u000aselect deptno, count(*) as cnt\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000aDEPTNO CNT\u000d\u000a------- ----\u000d\u000a 10 3\u000d\u000a 20 5\u000d\u000a 30 6\u000d\u000aConstants, scalar values returned by user-defined functions, window functions, and\u000d\u000anoncorrelated scalar subqueries are exceptions to this rule. Since the SELECT clause\u000d\u000a516 | Appendix A: Window Function Refresher","is evaluated after the GROUP BY clause, these constructs are allowed in the SELECT\u000d\u000alist and do not have to (and in some cases cannot) be specified in the GROUP BY\u000d\u000aclause. For example:\u000d\u000aselect 'hello' as msg,\u000d\u000a 1 as num,\u000d\u000a deptno,\u000d\u000a (select count(*) from emp) as total,\u000d\u000a count(*) as cnt\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000aMSG NUM DEPTNO TOTAL CNT\u000d\u000a----- --- ------ ----- ---\u000d\u000ahello 1 10 14 3\u000d\u000ahello 1 20 14 5\u000d\u000ahello 1 30 14 6\u000d\u000aDon\u2019t let this query confuse you. The items in the SELECT list not listed in the\u000d\u000aGROUP BY clause do not change the value of CNT for each DEPTNO, nor do the\u000d\u000avalues for DEPTNO change. Based on the results of the preceding query, we can\u000d\u000adefine the rule about matching items in the SELECT list and the GROUP BY clause\u000d\u000awhen using aggregates a bit more precisely:\u000d\u000aItems in a SELECT list that can potentially change the group or change the value\u000d\u000areturned by an aggregate function must be included in the GROUP BY clause.\u000d\u000aThe additional items in the preceding SELECT list did not change the value of CNT\u000d\u000afor any group (each DEPTNO), nor did they change the groups themselves.\u000d\u000aNow it\u2019s fair to ask: exactly what items in a SELECT list can change a grouping or the\u000d\u000avalue returned by an aggregate function? The answer is simple: other columns from\u000d\u000athe table(s) you are selecting from. Consider the prospect of adding the JOB column\u000d\u000ato the query we\u2019ve been looking at:\u000d\u000aselect deptno, job, count(*) as cnt\u000d\u000a from emp\u000d\u000a group by deptno, job\u000d\u000aDEPTNO JOB CNT\u000d\u000a------ ---------- ----\u000d\u000a 10 CLERK 1\u000d\u000a 10 MANAGER 1\u000d\u000a 10 PRESIDENT 1\u000d\u000a 20 CLERK 2\u000d\u000a 20 ANALYST 2\u000d\u000a 20 MANAGER 1\u000d\u000a 30 CLERK 1\u000d\u000a 30 MANAGER 1\u000d\u000a 30 SALESMAN 4\u000d\u000aWindow Function Refresher | 517","By listing another column, JOB, from table EMP, we are changing the group and\u000d\u000achanging the result set. Thus, we must now include JOB in the GROUP BY clause\u000d\u000aalong with DEPTNO; otherwise, the query will fail. The inclusion of JOB in the\u000d\u000aSELECT/GROUP BY clauses changes the query from \u201cHow many employees are in\u000d\u000aeach department?\u201d to \u201cHow many different types of employees are in each depart\u2010\u000d\u000ament?\u201d Notice again that the groups are distinct; the values for DEPTNO and JOB\u000d\u000aindividually are not distinct, but the combination of the two (which is what is in the\u000d\u000aGROUP BY and SELECT list, and thus in the group) is distinct (e.g., 10 and CLERK\u000d\u000aappear only once).\u000d\u000aIf you choose not to put items other than aggregate functions in the SELECT list,\u000d\u000athen you may list any valid column you want in the GROUP BY clause. Consider the\u000d\u000afollowing two queries, which highlight this fact:\u000d\u000aselect count(*)\u000d\u000a from emp\u000d\u000a group by deptno\u000d\u000a COUNT(*)\u000d\u000a---------\u000d\u000a 3\u000d\u000a 5\u000d\u000a 6\u000d\u000aselect count(*)\u000d\u000a from emp\u000d\u000a group by deptno,job\u000d\u000a COUNT(*)\u000d\u000a----------\u000d\u000a 1\u000d\u000a 1\u000d\u000a 1\u000d\u000a 2\u000d\u000a 2\u000d\u000a 1\u000d\u000a 1\u000d\u000a 1\u000d\u000a 4\u000d\u000aIncluding items other than aggregate functions in the SELECT list is not mandatory,\u000d\u000abut often improves readability and usability of the results.\u000d\u000a518 | Appendix A: Window Function Refresher","As a rule, when using GROUP BY and aggregate functions, any\u000d\u000aitems in the SELECT list (from the table(s) in the FROM clause)\u000d\u000anot used as an argument to an aggregate function must be included\u000d\u000ain the GROUP BY clause. However, MySQL has a \u201cfeature\u201d that\u000d\u000aallows you to deviate from this rule, allowing you to place items in\u000d\u000ayour SELECT list (that are columns in the table(s) you are selecting\u000d\u000afrom) that are not used as arguments to an aggregate function and\u000d\u000athat are not present in your GROUP BY clause. We use the term\u000d\u000afeature loosely here as its use is a bug waiting to happen. As a mat\u2010\u000d\u000ater of fact, if you use MySQL and care at all about the accuracy of\u000d\u000ayour queries, we suggest you urge them to remove this, ahem,\u000d\u000a\u201cfeature.\u201d\u000d\u000aWindowing\u000d\u000aOnce you understand the concept of grouping and using aggregates in SQL, under\u2010\u000d\u000astanding window functions is easy. Window functions, like aggregate functions, per\u2010\u000d\u000aform an aggregation on a defined set (a group) of rows, but rather than returning one\u000d\u000avalue per group, window functions can return multiple values for each group. The\u000d\u000agroup of rows to perform the aggregation on is the window. DB2 actually calls such\u000d\u000afunctions online analytic processing (OLAP) functions, and Oracle calls them analytic\u000d\u000afunctions, but the ISO SQL standard calls them window functions, so that\u2019s the term\u000d\u000aused in this book.\u000d\u000aA Simple Example\u000d\u000aLet\u2019s say that you want to count the total number of employees across all departments.\u000d\u000aThe traditional method for doing that is to issue a COUNT(*) query against the\u000d\u000aentire EMP table:\u000d\u000aselect count(*) as cnt\u000d\u000a from emp\u000d\u000a CNT\u000d\u000a-----\u000d\u000a 14\u000d\u000aThis is easy enough, but often you will find yourself wanting to access such aggregate\u000d\u000adata from rows that do not represent an aggregation, or that represent a different\u000d\u000aaggregation. Window functions make light work of such problems. For example, the\u000d\u000afollowing query shows how you can use a window function to access aggregate data\u000d\u000a(the total count of employees) from detail rows (one per employee):\u000d\u000aWindow Function Refresher | 519","select ename,\u000d\u000a deptno,\u000d\u000a count(*) over() as cnt\u000d\u000a from emp\u000d\u000a order by 2\u000d\u000aENAME DEPTNO CNT\u000d\u000a---------- ------ ------\u000d\u000aCLARK 10 14\u000d\u000aKING 10 14\u000d\u000aMILLER 10 14\u000d\u000aSMITH 20 14\u000d\u000aADAMS 20 14\u000d\u000aFORD 20 14\u000d\u000aSCOTT 20 14\u000d\u000aJONES 20 14\u000d\u000aALLEN 30 14\u000d\u000aBLAKE 30 14\u000d\u000aMARTIN 30 14\u000d\u000aJAMES 30 14\u000d\u000aTURNER 30 14\u000d\u000aWARD 30 14\u000d\u000aThe window function invocation in this example is COUNT(*) OVER(). The pres\u2010\u000d\u000aence of the OVER keyword indicates that the invocation of COUNT will be treated as\u000d\u000aa window function, not as an aggregate function. In general, the SQL standard allows\u000d\u000afor all aggregate functions to also be window functions, and the keyword OVER is\u000d\u000ahow the language distinguishes between the two uses.\u000d\u000aSo, what did the window function COUNT(*) OVER () do exactly? For every row\u000d\u000abeing returned in the query, it returned the count of all the rows in the table. As the\u000d\u000aempty parentheses suggest, the OVER keyword accepts additional clauses to affect the\u000d\u000arange of rows that a given window function considers. Absent any such clauses, the\u000d\u000awindow function looks at all rows in the result set, which is why you see the value 14\u000d\u000arepeated in each row of output.\u000d\u000aHopefully you are beginning to see the great utility of window functions, which is\u000d\u000athat they allow you to work with multiple levels of aggregation in one row. As you\u000d\u000acontinue through this appendix, you\u2019ll begin to see even more just how incredibly\u000d\u000auseful that ability can be.\u000d\u000aOrder of Evaluation\u000d\u000aBefore digging deeper into the OVER clause, it is important to note that window\u000d\u000afunctions are performed as the last step in SQL processing prior to the ORDER BY\u000d\u000aclause. As an example of how window functions are processed last, let\u2019s take the query\u000d\u000afrom the preceding section and use a WHERE clause to filter out employees from\u000d\u000aDEPTNO 20 and 30:\u000d\u000a520 | Appendix A: Window Function Refresher","select ename,\u000d\u000a deptno,\u000d\u000a count(*) over() as cnt\u000d\u000a from emp\u000d\u000a where deptno = 10\u000d\u000a order by 2\u000d\u000aENAME DEPTNO CNT\u000d\u000a---------- ------ ------\u000d\u000aCLARK 10 3\u000d\u000aKING 10 3\u000d\u000aMILLER 10 3\u000d\u000aThe value for CNT for each row is no longer 14, it is now 3. In this example, it is the\u000d\u000aWHERE clause that restricts the result set to three rows; hence, the window function\u000d\u000awill count only three rows (there are only three rows available to the window func\u2010\u000d\u000ation by the time processing reaches the SELECT portion of the query). From this\u000d\u000aexample you can see that window functions perform their computations after clauses\u000d\u000asuch as WHERE and GROUP BY are evaluated.\u000d\u000aPartitions\u000d\u000aUse the PARTITION BY clause to define a partition or group of rows to perform an\u000d\u000aaggregation over. As we\u2019ve seen already, if you use empty parentheses, then the entire\u000d\u000aresult set is the partition that a window function aggregation will be computed over.\u000d\u000aYou can think of the PARTITION BY clause as a \u201cmoving GROUP BY\u201d because\u000d\u000aunlike a traditional GROUP BY, a group created by PARTITION BY is not distinct in\u000d\u000aa result set. You can use PARTITION BY to compute an aggregation over a defined\u000d\u000agroup of rows (resetting when a new group is encountered), and rather than having\u000d\u000aone group represent all instances of that value in the table, each value (each member\u000d\u000ain each group) is returned. Consider the following query:\u000d\u000aselect ename,\u000d\u000a deptno,\u000d\u000a count(*) over(partition by deptno) as cnt\u000d\u000a from emp\u000d\u000a order by 2\u000d\u000aENAME DEPTNO CNT\u000d\u000a---------- ------ ------\u000d\u000aCLARK 10 3\u000d\u000aKING 10 3\u000d\u000aMILLER 10 3\u000d\u000aSMITH 20 5\u000d\u000aADAMS 20 5\u000d\u000aFORD 20 5\u000d\u000aSCOTT 20 5\u000d\u000aJONES 20 5\u000d\u000aWindow Function Refresher | 521","ALLEN 30 6\u000d\u000aBLAKE 30 6\u000d\u000aMARTIN 30 6\u000d\u000aJAMES 30 6\u000d\u000aTURNER 30 6\u000d\u000aWARD 30 6\u000d\u000aThis query still returns 14 rows, but now the COUNT is performed for each depart\u2010\u000d\u000ament as a result of the PARTITION BY DEPTNO clause. Each employee in the same\u000d\u000adepartment (in the same partition) will have the same value for CNT, because the\u000d\u000aaggregation will not reset (recompute) until a new department is encountered. Also\u000d\u000anote that you are returning information about each group, along with the members of\u000d\u000aeach group. You can think of the preceding query as a more efficient version of the\u000d\u000afollowing:\u000d\u000aselect e.ename,\u000d\u000a e.deptno,\u000d\u000a (select count(*) from emp d\u000d\u000a where e.deptno=d.deptno) as cnt\u000d\u000a from emp e\u000d\u000a order by 2\u000d\u000aENAME DEPTNO CNT\u000d\u000a---------- ------ ------\u000d\u000aCLARK 10 3\u000d\u000aKING 10 3\u000d\u000aMILLER 10 3\u000d\u000aSMITH 20 5\u000d\u000aADAMS 20 5\u000d\u000aFORD 20 5\u000d\u000aSCOTT 20 5\u000d\u000aJONES 20 5\u000d\u000aALLEN 30 6\u000d\u000aBLAKE 30 6\u000d\u000aMARTIN 30 6\u000d\u000aJAMES 30 6\u000d\u000aTURNER 30 6\u000d\u000aWARD 30 6\u000d\u000aAdditionally, what\u2019s nice about the PARTITION BY clause is that it performs its com\u2010\u000d\u000aputations independently of other window functions, partitioning by different col\u2010\u000d\u000aumns in the same SELECT statement. Consider the following query, which returns\u000d\u000aeach employee, their department, the number of employees in their respective depart\u2010\u000d\u000ament, their job, and the number of employees with the same job:\u000d\u000aselect ename,\u000d\u000a deptno,\u000d\u000a count(*) over(partition by deptno) as dept_cnt,\u000d\u000a job,\u000d\u000a count(*) over(partition by job) as job_cnt\u000d\u000a522 | Appendix A: Window Function Refresher"," from emp\u000d\u000a order by 2\u000d\u000aENAME DEPTNO DEPT_CNT JOB JOB_CNT\u000d\u000a---------- ------ -------- --------- -------\u000d\u000aMILLER 10 3 CLERK 4\u000d\u000aCLARK 10 3 MANAGER 3\u000d\u000aKING 10 3 PRESIDENT 1\u000d\u000aSCOTT 20 5 ANALYST 2\u000d\u000aFORD 20 5 ANALYST 2\u000d\u000aSMITH 20 5 CLERK 4\u000d\u000aJONES 20 5 MANAGER 3\u000d\u000aADAMS 20 5 CLERK 4\u000d\u000aJAMES 30 6 CLERK 4\u000d\u000aMARTIN 30 6 SALESMAN 4\u000d\u000aTURNER 30 6 SALESMAN 4\u000d\u000aWARD 30 6 SALESMAN 4\u000d\u000aALLEN 30 6 SALESMAN 4\u000d\u000aBLAKE 30 6 MANAGER 3\u000d\u000aIn this result set, you can see that employees in the same department have the same\u000d\u000avalue for DEPT_CNT, and that employees who have the same job position have the\u000d\u000asame value for JOB_CNT.\u000d\u000aBy now it should be clear that the PARTITION BY clause works like a GROUP BY\u000d\u000aclause, but it does so without being affected by the other items in the SELECT clause\u000d\u000aand without requiring you to write a GROUP BY clause.\u000d\u000aEffect of NULLs\u000d\u000aLike the GROUP BY clause, the PARTITION BY clause lumps all the NULLs into one\u000d\u000agroup or partition. Thus, the effect from NULLs when using PARTITION BY is simi\u2010\u000d\u000alar to that from using GROUP BY. The following query uses a window function to\u000d\u000acount the number of employees with each distinct commission (returning \u20131 in place\u000d\u000aof NULL for readability):\u000d\u000aselect coalesce(comm,-1) as comm,\u000d\u000a count(*)over(partition by comm) as cnt\u000d\u000a from emp\u000d\u000a COMM CNT\u000d\u000a------ ----------\u000d\u000a 0 1\u000d\u000a 300 1\u000d\u000a 500 1\u000d\u000a 1400 1\u000d\u000a -1 10\u000d\u000a -1 10\u000d\u000a -1 10\u000d\u000a -1 10\u000d\u000a -1 10\u000d\u000aWindow Function Refresher | 523"," -1 10\u000d\u000a -1 10\u000d\u000a -1 10\u000d\u000a -1 10\u000d\u000a -1 10\u000d\u000aBecause COUNT(*) is used, the function counts rows. You can see that there are 10\u000d\u000aemployees having NULL commissions. Use COMM instead of *, however, and you\u000d\u000aget quite different results:\u000d\u000aselect coalesce(comm,-1) as comm,\u000d\u000a count(comm)over(partition by comm) as cnt\u000d\u000a from emp\u000d\u000aCOMM CNT\u000d\u000a---- ----------\u000d\u000a 0 1\u000d\u000a 300 1\u000d\u000a 500 1\u000d\u000a1400 1\u000d\u000a -1 0\u000d\u000a -1 0\u000d\u000a -1 0\u000d\u000a -1 0\u000d\u000a -1 0\u000d\u000a -1 0\u000d\u000a -1 0\u000d\u000a -1 0\u000d\u000a -1 0\u000d\u000a -1 0\u000d\u000aThis query uses COUNT(COMM), which means that only the non-NULL values in\u000d\u000athe COMM column are counted. There is one employee with a commission of 0, one\u000d\u000aemployee with a commission of 300, and so forth. But notice the counts for those\u000d\u000awith NULL commissions! Those counts are 0. Why? Because aggregate functions\u000d\u000aignore NULL values, or more accurately, aggregate functions count only non-NULL\u000d\u000avalues.\u000d\u000aWhen using COUNT, consider whether you want to include\u000d\u000aNULLs. Use COUNT(column) to avoid counting NULLs. Use\u000d\u000aCOUNT(*) if you do want to include NULLs (since you are no\u000d\u000alonger counting actual column values, you are counting rows).\u000d\u000aWhen Order Matters\u000d\u000aSometimes the order in which rows are treated by a window function is material to\u000d\u000athe results that you want to obtain from a query. For this reason, window function\u000d\u000asyntax includes an ORDER BY subclause that you can place within an OVER clause.\u000d\u000aUse the ORDER BY clause to specify how the rows are ordered with a partition\u000d\u000a524 | Appendix A: Window Function Refresher","(remember, \u201cpartition\u201d in the absence of a PARTITION BY clause means the entire\u000d\u000aresult set).\u000d\u000aSome window functions require you to impose order on the parti\u2010\u000d\u000ations of rows being affected. Thus, for some window functions, an\u000d\u000aORDER BY clause is mandatory. At the time of this writing, SQL\u000d\u000aServer does not allow ORDER BY in the OVER clause when used\u000d\u000awith aggregate window functions. SQL Server does permit ORDER\u000d\u000aBY in the OVER clause when used with window ranking functions.\u000d\u000aWhen you use an ORDER BY clause in the OVER clause of a window function, you\u000d\u000aare specifying two things:\u000d\u000a\u2022 How the rows in the partition are ordered\u000d\u000a\u2022 What rows are included in the computation\u000d\u000aConsider the following query, which sums and computes a running total of salaries\u000d\u000afor employees in DEPTNO 10:\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a hiredate,\u000d\u000a sal,\u000d\u000a sum(sal)over(partition by deptno) as total1,\u000d\u000a sum(sal)over() as total2,\u000d\u000a sum(sal)over(order by hiredate) as running_total\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000aDEPTNO ENAME HIREDATE SAL TOTAL1 TOTAL2 RUNNING_TOTAL\u000d\u000a------ ------ ----------- ----- ------ ------ -------------\u000d\u000a 10 CLARK 09-JUN-1981 2450 8750 8750 2450\u000d\u000a 10 KING 17-NOV-1981 5000 8750 8750 7450\u000d\u000a 10 MILLER 23-JAN-1982 1300 8750 8750 8750\u000d\u000aJust to keep you on your toes, I\u2019ve included a sum with empty\u000d\u000aparentheses. Notice how TOTAL1 and TOTAL2 have the same val\u2010\u000d\u000aues. Why? Once again, the order in which window functions are\u000d\u000aevaluated answers the question. The WHERE clause filters the\u000d\u000aresult set such that only salaries from DEPTNO 10 are considered\u000d\u000afor summation. In this case, there is only one partition\u2014the entire\u000d\u000aresult set, which consists of only salaries from DEPTNO 10. Thus\u000d\u000aTOTAL1, and TOTAL2 are the same.\u000d\u000aLooking at the values returned by column SAL, you can easily see where the values\u000d\u000afor RUNNING_TOTAL come from. You can eyeball the values and add them\u000d\u000aWindow Function Refresher | 525","yourself to compute the running total. But more importantly, why did including an\u000d\u000aORDER BY in the OVER clause create a running total in the first place? The reason\u000d\u000ais, when you use ORDER BY in the OVER clause, you are specifying a default \u201cmov\u2010\u000d\u000aing\u201d or \u201csliding\u201d window within the partition even though you don\u2019t see it. The\u000d\u000aORDER BY HIREDATE clause terminates summation at the HIREDATE in the cur\u2010\u000d\u000arent row.\u000d\u000aThe following query is the same as the previous one, but uses the RANGE\u000d\u000aBETWEEN clause (which you\u2019ll learn more about later) to explicitly specify the\u000d\u000adefault behavior that results from ORDER BY HIREDATE:\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a hiredate,\u000d\u000a sal,\u000d\u000a sum(sal)over(partition by deptno) as total1,\u000d\u000a sum(sal)over() as total2,\u000d\u000a sum(sal)over(order by hiredate\u000d\u000a range between unbounded preceding\u000d\u000a and current row) as running_total\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000aDEPTNO ENAME HIREDATE SAL TOTAL1 TOTAL2 RUNNING_TOTAL\u000d\u000a------ ------ ----------- ----- ------ ------ -------------\u000d\u000a 10 CLARK 09-JUN-1981 2450 8750 8750 2450\u000d\u000a 10 KING 17-NOV-1981 5000 8750 8750 7450\u000d\u000a 10 MILLER 23-JAN-1982 1300 8750 8750 8750\u000d\u000aThe RANGE BETWEEN clause that you see in this query is termed the framing clause\u000d\u000aby ANSI, and we\u2019ll use that term here. Now, it should be easy to see why specifying an\u000d\u000aORDER BY in the OVER clause created a running total; we\u2019ve (by default) told the\u000d\u000aquery to sum all rows starting from the current row and include all prior rows\u000d\u000a(\u201cprior\u201d as defined in the ORDER BY, in this case ordering the rows by HIREDATE).\u000d\u000aThe Framing Clause\u000d\u000aLet\u2019s apply the framing clause from the preceding query to the result set, starting with\u000d\u000athe first employee hired, who is named CLARK:\u000d\u000a1. Starting with CLARK\u2019s salary, 2450, and including all employees hired before\u000d\u000aCLARK, compute a sum. Since CLARK was the first employee hired in DEPTNO\u000d\u000a10, the sum is simply CLARK\u2019s salary, 2450, which is the first value returned by\u000d\u000aRUNNING_TOTAL.\u000d\u000a2. Let\u2019s move to the next employee based on HIREDATE, named KING, and apply\u000d\u000athe framing clause once again. Compute a sum on SAL starting with the current\u000d\u000arow, 5000 (KING\u2019s salary), and include all prior rows (all employees hired before\u000d\u000a526 | Appendix A: Window Function Refresher","KING). CLARK is the only one hired before KING, so the sum is 5000 + 2450,\u000d\u000awhich is 7450, the second value returned by RUNNING_TOTAL.\u000d\u000a3. Moving on to MILLER, the last employee in the partition based on HIREDATE,\u000d\u000alet\u2019s one more time apply the framing clause. Compute a sum on SAL starting\u000d\u000awith the current row, 1300 (MILLER\u2019s salary), and include all prior rows (all\u000d\u000aemployees hired before MILLER). CLARK and KING were both hired before\u000d\u000aMILLER, and thus their salaries are included in MILLER\u2019s RUNNING_TOTAL:\u000d\u000a2450 + 5000 + 1300 is 8750, which is the value for RUNNING_TOTAL for\u000d\u000aMILLER.\u000d\u000aAs you can see, it is really the framing clause that produces the running total. The\u000d\u000aORDER BY defines the order of evaluation and happens to also imply a default\u000d\u000aframing.\u000d\u000aIn general, the framing clause allows you to define different \u201csubwindows\u201d of data to\u000d\u000ainclude in your computations. There are many ways to specify such subwindows.\u000d\u000aConsider the following query:\u000d\u000aselect deptno,\u000d\u000a ename,\u000d\u000a sal,\u000d\u000a sum(sal)over(order by hiredate\u000d\u000a range between unbounded preceding\u000d\u000a and current row) as run_total1,\u000d\u000a sum(sal)over(order by hiredate\u000d\u000a rows between 1 preceding\u000d\u000a and current row) as run_total2,\u000d\u000a sum(sal)over(order by hiredate\u000d\u000a range between current row\u000d\u000a and unbounded following) as run_total3,\u000d\u000a sum(sal)over(order by hiredate\u000d\u000a rows between current row\u000d\u000a and 1 following) as run_total4\u000d\u000a from emp\u000d\u000a where deptno=10\u000d\u000aDEPTNO ENAME SAL RUN_TOTAL1 RUN_TOTAL2 RUN_TOTAL3 RUN_TOTAL4\u000d\u000a------ ------ ----- ---------- ---------- ---------- ----------\u000d\u000a 10 CLARK 2450 2450 2450 8750 7450\u000d\u000a 10 KING 5000 7450 7450 6300 6300\u000d\u000a 10 MILLER 1300 8750 6300 1300 1300\u000d\u000aDon\u2019t be intimidated here; this query is not as bad as it looks. You\u2019ve already seen\u000d\u000aRUN_TOTAL1 and the effects of the framing clause UNBOUNDED PRECEDING\u000d\u000aAND CURRENT ROW. Here\u2019s a quick description of what\u2019s happening in the other\u000d\u000aexamples:\u000d\u000aWindow Function Refresher | 527","RUN_TOTAL2\u000d\u000aRather than the keyword RANGE, this framing clause specifies ROWS, which\u000d\u000ameans the frame, or window, is going to be constructed by counting some num\u2010\u000d\u000aber of rows. The 1 PRECEDING means that the frame will begin with the row\u000d\u000aimmediately preceding the current row. The range continues through the CURRENT ROW. So what you get in RUN_TOTAL2 is the sum of the current\u000d\u000aemployee\u2019s salary and that of the preceding employee, based on HIREDATE.\u000d\u000a[[sqlckbk-APP-A-NOTE-11]]\u000d\u000aIt so happens that RUN_TOTAL1 and RUN_TOTAL2 are the\u000d\u000asame for both CLARK and KING. Why? Think about which\u000d\u000avalues are being summed for each of those employees, for each\u000d\u000aof the two window functions. Think carefully, and you\u2019ll get\u000d\u000athe answer.\u000d\u000aRUN_TOTAL3\u000d\u000aThe window function for RUN_TOTAL3 works just the opposite of that for\u000d\u000aRUN_TOTAL1; rather than starting with the current row and including all prior\u000d\u000arows in the summation, summation begins with the current row and includes all\u000d\u000asubsequent rows in the summation.\u000d\u000aRUN_TOTAL4\u000d\u000aThis is the inverse of RUN_TOTAL2; rather than starting from the current row\u000d\u000aand including one prior row in the summation, start with the current row and\u000d\u000ainclude one subsequent row in the summation.\u000d\u000aIf you can understand what\u2019s been explained thus far, you will have\u000d\u000ano problem with any of the recipes in this book. If you\u2019re not catch\u2010\u000d\u000aing on, though, try practicing with your own examples and your\u000d\u000aown data. It\u2019s usually easier to learn by coding new features rather\u000d\u000athan just reading about them.\u000d\u000aA Framing Finale\u000d\u000aAs a final example of the effect of the framing clause on query output, consider the\u000d\u000afollowing query:\u000d\u000aselect ename,\u000d\u000a sal,\u000d\u000a min(sal)over(order by sal) min1,\u000d\u000a max(sal)over(order by sal) max1,\u000d\u000a min(sal)over(order by sal\u000d\u000a range between unbounded preceding\u000d\u000a and unbounded following) min2,\u000d\u000a max(sal)over(order by sal\u000d\u000a528 | Appendix A: Window Function Refresher"," range between unbounded preceding\u000d\u000a and unbounded following) max2,\u000d\u000a min(sal)over(order by sal\u000d\u000a range between current row\u000d\u000a and current row) min3,\u000d\u000a max(sal)over(order by sal\u000d\u000a range between current row\u000d\u000a and current row) max3,\u000d\u000a max(sal)over(order by sal\u000d\u000a rows between 3 preceding\u000d\u000a and 3 following) max4\u000d\u000a from emp\u000d\u000aENAME SAL MIN1 MAX1 MIN2 MAX2 MIN3 MAX3 MAX4\u000d\u000a------ ----- ------ ------ ------ ------ ------ ------ ------\u000d\u000aSMITH 800 800 800 800 5000 800 800 1250\u000d\u000aJAMES 950 800 950 800 5000 950 950 1250\u000d\u000aADAMS 1100 800 1100 800 5000 1100 1100 1300\u000d\u000aWARD 1250 800 1250 800 5000 1250 1250 1500\u000d\u000aMARTIN 1250 800 1250 800 5000 1250 1250 1600\u000d\u000aMILLER 1300 800 1300 800 5000 1300 1300 2450\u000d\u000aTURNER 1500 800 1500 800 5000 1500 1500 2850\u000d\u000aALLEN 1600 800 1600 800 5000 1600 1600 2975\u000d\u000aCLARK 2450 800 2450 800 5000 2450 2450 3000\u000d\u000aBLAKE 2850 800 2850 800 5000 2850 2850 3000\u000d\u000aJONES 2975 800 2975 800 5000 2975 2975 5000\u000d\u000aSCOTT 3000 800 3000 800 5000 3000 3000 5000\u000d\u000aFORD 3000 800 3000 800 5000 3000 3000 5000\u000d\u000aKING 5000 800 5000 800 5000 5000 5000 5000\u000d\u000aOK, let\u2019s break this query down:\u000d\u000aMIN1\u000d\u000aThe window function generating this column does not specify a framing clause,\u000d\u000aso the default framing clause of UNBOUNDED PRECEDING AND CURRENT\u000d\u000aROW kicks in. Why is MIN1 800 for all rows? It\u2019s because the lowest salary\u000d\u000acomes first (ORDER BY SAL), and it remains the lowest, or minimum, salary\u000d\u000aforever after.\u000d\u000aMAX1\u000d\u000aThe values for MAX1 are much different from those for MIN1. Why? The\u000d\u000aanswer (again) is the default framing clause UNBOUNDED PRECEDING AND\u000d\u000aCURRENT ROW. In conjunction with ORDER BY SAL, this framing clause\u000d\u000aensures that the maximum salary will also correspond to that of the current row.\u000d\u000aConsider the first row, for SMITH. When evaluating SMITH\u2019s salary and all prior\u000d\u000asalaries, MAX1 for SMITH is SMITH\u2019s salary, because there are no prior salaries.\u000d\u000aMoving on to the next row, JAMES, when comparing JAMES\u2019s salary to all prior\u000d\u000asalaries, in this case comparing to the salary of SMITH, JAMES\u2019s salary is the\u000d\u000aWindow Function Refresher | 529","higher of the two, and thus it is the maximum. If you apply this logic to all rows,\u000d\u000ayou will see that the value of MAX1 for each row is the current employee\u2019s salary.\u000d\u000aMIN2 and MAX2\u000d\u000aThe framing clause given for these is UNBOUNDED PRECEDING AND\u000d\u000aUNBOUNDED FOLLOWING, which is the same as specifying empty parenthe\u2010\u000d\u000ases. Thus, all rows in the result set are considered when computing MIN and\u000d\u000aMAX. As you might expect, the MIN and MAX values for the entire result set are\u000d\u000aconstant, and thus the value of these columns is constant as well.\u000d\u000aMIN3 and MAX3\u000d\u000aThe framing clause for these is CURRENT ROW AND CURRENT ROW, which\u000d\u000asimply means use only the current employee\u2019s salary when looking for the MIN\u000d\u000aand MAX salary. Thus, both MIN3 and MAX3 are the same as SAL for each row.\u000d\u000aThat was easy, wasn\u2019t it?\u000d\u000aMAX4\u000d\u000aThe framing clause defined for MAX4 is 3 PRECEDING AND 3 FOLLOWING,\u000d\u000awhich means, for every row, consider the three rows prior and the three rows\u000d\u000aafter the current row, as well as the current row itself. This particular invocation\u000d\u000aof MAX(SAL) will return from those rows the highest salary value.\u000d\u000aIf you look at the value of MAX4 for employee MARTIN, you can see how the\u000d\u000aframing clause is applied. MARTIN\u2019s salary is 1250, and the three employee salar\u2010\u000d\u000aies prior to MARTIN\u2019s are WARD\u2019s (1250), ADAMS\u2019s (1100) and JAMES\u2019s (950).\u000d\u000aThe three employee salaries after MARTIN\u2019s are MILLER\u2019s (1300), TURNER\u2019s\u000d\u000a(1500), and ALLEN\u2019s (1600). Out of all those salaries, including MARTIN\u2019s, the\u000d\u000ahighest is ALLEN\u2019s, and thus the value of MAX4 for MARTIN is 1600.\u000d\u000aReadability + Performance = Power\u000d\u000aAs you can see, window functions are extremely powerful as they allow you to write\u000d\u000aqueries that contain both detailed and aggregate information. Using window func\u2010\u000d\u000ations allows you to write smaller, more efficient queries as compared to using multi\u2010\u000d\u000aple self-join and/or scalar subqueries. Consider the following query, which easily\u000d\u000aanswers all of the following questions: \u201cWhat is the number of employees in each\u000d\u000adepartment? How many different types of employees are in each department (e.g.,\u000d\u000ahow many clerks are in department 10)? How many total employees are in table\u000d\u000aEMP?\u201d\u000d\u000aselect deptno,\u000d\u000a job,\u000d\u000a count(*) over (partition by deptno) as emp_cnt,\u000d\u000a count(job) over (partition by deptno,job) as job_cnt,\u000d\u000a count(*) over () as total\u000d\u000a from emp\u000d\u000a530 | Appendix A: Window Function Refresher","DEPTNO JOB EMP_CNT JOB_CNT TOTAL\u000d\u000a------ --------- ---------- ---------- ----------\u000d\u000a 10 CLERK 3 1 14\u000d\u000a 10 MANAGER 3 1 14\u000d\u000a 10 PRESIDENT 3 1 14\u000d\u000a 20 ANALYST 5 2 14\u000d\u000a 20 ANALYST 5 2 14\u000d\u000a 20 CLERK 5 2 14\u000d\u000a 20 CLERK 5 2 14\u000d\u000a 20 MANAGER 5 1 14\u000d\u000a 30 CLERK 6 1 14\u000d\u000a 30 MANAGER 6 1 14\u000d\u000a 30 SALESMAN 6 4 14\u000d\u000a 30 SALESMAN 6 4 14\u000d\u000a 30 SALESMAN 6 4 14\u000d\u000a 30 SALESMAN 6 4 14\u000d\u000aReturning the same result set without using window functions would require a bit\u000d\u000amore work:\u000d\u000aselect a.deptno, a.job,\u000d\u000a (select count(*) from emp b\u000d\u000a where b.deptno = a.deptno) as emp_cnt,\u000d\u000a (select count(*) from emp b\u000d\u000a where b.deptno = a.deptno and b.job = a.job) as job_cnt,\u000d\u000a (select count(*) from emp) as total\u000d\u000a from emp a\u000d\u000a order by 1,2\u000d\u000aDEPTNO JOB EMP_CNT JOB_CNT TOTAL\u000d\u000a------ --------- ---------- ---------- ----------\u000d\u000a 10 CLERK 3 1 14\u000d\u000a 10 MANAGER 3 1 14\u000d\u000a 10 PRESIDENT 3 1 14\u000d\u000a 20 ANALYST 5 2 14\u000d\u000a 20 ANALYST 5 2 14\u000d\u000a 20 CLERK 5 2 14\u000d\u000a 20 CLERK 5 2 14\u000d\u000a 20 MANAGER 5 1 14\u000d\u000a 30 CLERK 6 1 14\u000d\u000a 30 MANAGER 6 1 14\u000d\u000a 30 SALESMAN 6 4 14\u000d\u000a 30 SALESMAN 6 4 14\u000d\u000a 30 SALESMAN 6 4 14\u000d\u000a 30 SALESMAN 6 4 14\u000d\u000aThe nonwindow solution is obviously not difficult to write, yet it certainly is not as\u000d\u000aclean or efficient (you won\u2019t see performance differences with a 14-row table, but try\u000d\u000athese queries with, say, a 1,000- or 10,000-row table, and then you\u2019ll see the benefit of\u000d\u000ausing window functions over multiple self-joins and scalar subqueries).\u000d\u000aWindow Function Refresher | 531","Providing a Base\u000d\u000aBesides readability and performance, window functions are useful for providing a\u000d\u000a\u201cbase\u201d for more complex \u201creport-style\u201d queries. For example, consider the following\u000d\u000a\u201creport-style\u201d query that uses window functions in an inline view and then aggregates\u000d\u000athe results in an outer query. Using window functions allows you to return detailed as\u000d\u000awell as aggregate data, which is useful for reports. The following query uses window\u000d\u000afunctions to find counts using different partitions. Because the aggregation is applied\u000d\u000ato multiple rows, the inline view returns all rows from EMP, which the outer CASE\u000d\u000aexpressions can use to transpose and create a formatted report:\u000d\u000aselect deptno,\u000d\u000a emp_cnt as dept_total,\u000d\u000a total,\u000d\u000a max(case when job = 'CLERK'\u000d\u000a then job_cnt else 0 end) as clerks,\u000d\u000a max(case when job = 'MANAGER'\u000d\u000a then job_cnt else 0 end) as mgrs,\u000d\u000a max(case when job = 'PRESIDENT'\u000d\u000a then job_cnt else 0 end) as prez,\u000d\u000a max(case when job = 'ANALYST'\u000d\u000a then job_cnt else 0 end) as anals,\u000d\u000a max(case when job = 'SALESMAN'\u000d\u000a then job_cnt else 0 end) as smen\u000d\u000a from (\u000d\u000aselect deptno,\u000d\u000a job,\u000d\u000a count(*) over (partition by deptno) as emp_cnt,\u000d\u000a count(job) over (partition by deptno,job) as job_cnt,\u000d\u000a count(*) over () as total \u000d\u000a from emp\u000d\u000a ) x\u000d\u000a group by deptno, emp_cnt, total\u000d\u000aDEPTNO DEPT_TOTAL TOTAL CLERKS MGRS PREZ ANALS SMEN\u000d\u000a------ ---------- ----- ------ ---- ---- ----- ----\u000d\u000a 10 3 14 1 1 1 0 0\u000d\u000a 20 5 14 2 1 0 2 0\u000d\u000a 30 6 14 1 1 0 0 4\u000d\u000aThe previous query returns each department, the total number of employees in each\u000d\u000adepartment, the total number of employees in table EMP, and a breakdown of the\u000d\u000anumber of different job types in each department. All this is done in one query,\u000d\u000awithout additional joins or temp tables!\u000d\u000aAs a final example of how easily multiple questions can be answered using window\u000d\u000afunctions, consider the following query:\u000d\u000a532 | Appendix A: Window Function Refresher","select ename as name,\u000d\u000a sal,\u000d\u000a max(sal)over(partition by deptno) as hiDpt,\u000d\u000a min(sal)over(partition by deptno) as loDpt,\u000d\u000a max(sal)over(partition by job) as hiJob,\u000d\u000a min(sal)over(partition by job) as loJob,\u000d\u000a max(sal)over() as hi,\u000d\u000a min(sal)over() as lo,\u000d\u000a sum(sal)over(partition by deptno\u000d\u000a order by sal,empno) as dptRT,\u000d\u000a sum(sal)over(partition by deptno) as dptSum,\u000d\u000a sum(sal)over() as ttl\u000d\u000a from emp\u000d\u000a order by deptno,dptRT\u000d\u000aNAME SAL HIDPT LODPT HIJOB LOJOB HI LO DPTRT DPTSUM TTL\u000d\u000a------ ----- ----- ----- ----- ----- ----- ---- ------ ------ ------\u000d\u000aMILLER 1300 5000 1300 1300 800 5000 800 1300 8750 29025\u000d\u000aCLARK 2450 5000 1300 2975 2450 5000 800 3750 8750 29025\u000d\u000aKING 5000 5000 1300 5000 5000 5000 800 8750 8750 29025\u000d\u000aSMITH 800 3000 800 1300 800 5000 800 800 10875 29025\u000d\u000aADAMS 1100 3000 800 1300 800 5000 800 1900 10875 29025\u000d\u000aJONES 2975 3000 800 2975 2450 5000 800 4875 10875 29025\u000d\u000aSCOTT 3000 3000 800 3000 3000 5000 800 7875 10875 29025\u000d\u000aFORD 3000 3000 800 3000 3000 5000 800 10875 10875 29025\u000d\u000aJAMES 950 2850 950 1300 800 5000 800 950 9400 29025\u000d\u000aWARD 1250 2850 950 1600 1250 5000 800 2200 9400 29025\u000d\u000aMARTIN 1250 2850 950 1600 1250 5000 800 3450 9400 29025\u000d\u000aTURNER 1500 2850 950 1600 1250 5000 800 4950 9400 29025\u000d\u000aALLEN 1600 2850 950 1600 1250 5000 800 6550 9400 29025\u000d\u000aBLAKE 2850 2850 950 2975 2450 5000 800 9400 9400 29025\u000d\u000aThis query answers the following questions easily, efficiently, and readably (and\u000d\u000awithout additional joins to EMP!). Simply match the employee and their salary with\u000d\u000athe different rows in the result set to determine:\u000d\u000a\u2022 Who makes the highest salary of all employees (HI)\u000d\u000a\u2022 Who makes the lowest salary of all employees (LO)\u000d\u000a\u2022 Who makes the highest salary in the department (HIDPT)\u000d\u000a\u2022 Who makes the lowest salary in the department (LODPT)\u000d\u000a\u2022 Who makes the highest salary in their job (HIJOB)\u000d\u000a\u2022 Who makes the lowest salary in their job (LOJOB)\u000d\u000a\u2022 What is the sum of all salaries (TTL)\u000d\u000a\u2022 What is the sum of salaries per department (DPTSUM)\u000d\u000a\u2022 What is the running total of all salaries per department (DPTRT)\u000d\u000aWindow Function Refresher | 533","","APPENDIX B\u000d\u000aCommon Table Expressions\u000d\u000aMany of the queries presented in this cookbook go beyond what is possible using\u000d\u000atables as they are typically available in a database, especially in relation to aggregate\u000d\u000afunctions and window functions. Therefore, for some queries, you need to make a\u000d\u000aderived table\u2014either a subquery or a common table expression (CTE).\u000d\u000aSubqueries\u000d\u000aArguably the simplest way to create a virtual table that allows you to run queries on\u000d\u000awindow functions or aggregate functions is a subquery. All that\u2019s required here is to\u000d\u000awrite the query that you need within parentheses and then to write a second query\u000d\u000athat uses it. The following table illustrates the use of subqueries with a simple double\u000d\u000aaggregate\u2014you want to find not just the counts of employees in each job, but then\u000d\u000aidentify the highest number, but you can\u2019t nest aggregate functions directly in a stan\u2010\u000d\u000adard query.\u000d\u000aOne pitfall is that some vendors require you to give the subquery table and alias, but\u000d\u000aothers do not. The following example was written in MySQL, which does require an\u000d\u000aalias. The alias here is HEAD_COUNT_TAB after the closing parenthesis.\u000d\u000aOthers that require an alias are PostgreSQL and SQL Server, while Oracle does not:\u000d\u000aselect max(HeadCount) as HighestJobHeadCount from\u000d\u000a(select job,count(empno) as HeadCount\u000d\u000afrom emp\u000d\u000agroup by job) head_count_tab\u000d\u000a535","Common Table Expressions\u000d\u000aCTEs were intended to overcome some of the limits of subqueries, and may be most\u000d\u000awell known for allowing recursive queries to be used within SQL. In fact, enablng\u000d\u000arecursion within SQL was the main inspiration for CTEs.\u000d\u000aThis example achieves the same result as the subquery we saw earlier\u2014it finds a dou\u2010\u000d\u000able aggregate:\u000d\u000awith head_count_tab (job,HeadCount) as\u000d\u000a(select job,count(empno)\u000d\u000afrom emp\u000d\u000agroup by job)\u000d\u000aselect max(HeadCount) as HighestJobHeadCount\u000d\u000afrom head_count_tab\u000d\u000aAlthough this query solves a simple problem, it illustrates the essential features of a\u000d\u000aCTE. We introduce the derived table using the WITH clause, specifying the column\u000d\u000aheadings in the parentheses, and use parentheses around the derived table\u2019s query\u000d\u000aitself. If we want to add more derived tables, we can add more as long as we separate\u000d\u000aeach one with a comma and provide its name before its query (the reverse of how\u000d\u000aaliasing usually works in SQL).\u000d\u000aBecause the inner queries are presented before the outer query, in many circumstan\u2010\u000d\u000aces they may also be considered more readable\u2014they make it easier to study each\u000d\u000alogical element of the query separately in order to understand the logical flow. Of\u000d\u000acourse, as with all things in coding, this will vary according to circumstances, and\u000d\u000asometimes the subquery will be more readable.\u000d\u000aConsidering that recursion is the key reason for CTEs to exist, the best way to\u000d\u000ademonstrate their capability is through a recursive query.\u000d\u000aThe query that follows calculates the first 20 numbers in the Fibonacci sequence\u000d\u000ausing a recursive CTE. Note that in the first part of the anchor query, we can initialize\u000d\u000athe values in the first row of the virtual table:\u000d\u000awith recursive workingTable ( fibNum, NextNumber, index1)\u000d\u000aas\u000d\u000a(select 0,1,1\u000d\u000aunion all\u000d\u000aselect fibNum+nextNumber,fibNUm,index1+1\u000d\u000afrom anchor\u000d\u000awhere index1<20)\u000d\u000aselect fibNum from workingTable as fib\u000d\u000a536 | Appendix B: Common Table Expressions","The Fibonacci sequence finds the next number by adding the current and previous\u000d\u000anumbers; you could also use LAG to achieve this result. However, in this case we\u2019ve\u000d\u000amade a pseudo-LAG by using two columns to account for the current number and\u000d\u000athe previous. Note the keyword RECURSIVE, which is mandatory in MySQL, Oracle,\u000d\u000aand PostgreSQL but not in SQL Server or DB2. In this query, the index1 column is\u000d\u000alargely redundant in the sense of not being used for the Fibonacci calculation.\u000d\u000aInstead, we have included it to make it simpler to set the number of rows returned via\u000d\u000athe WHERE clause. In a recursive CTE, the WHERE clause becomes crucial, as\u000d\u000awithout it the query would not terminate (although in this specific case, if you try\u000d\u000adeleting it, you are likely to find that your database throws an overflow error when\u000d\u000athe numbers become too large for the data type).\u000d\u000aAt the simple end of the spectrum, there\u2019s not a lot of difference between a subquery\u000d\u000aand CTE in terms of usability. Both allow for nesting or writing more complicated\u000d\u000aqueries that refer to other derived tables. However, once you start nesting many sub\u2010\u000d\u000aqueries, readability is lessened because the meaning of different variables is hidden in\u000d\u000asuccessive query layers. In contrast, because a CTE arranges each element vertically, it\u000d\u000ais easier to understand the meaning of each element.\u000d\u000aSumming Up\u000d\u000aThe use of derived tables dramatically extends the range of SQL. Both subqueries and\u000d\u000aCTES are used many times throughout the book, so it is important to understand\u000d\u000ahow they work, especially as they each have a particular syntax that you need to mas\u2010\u000d\u000ater to ensure success. The recursive CTE, which is now available in the vendor offer\u2010\u000d\u000aings in this book, is one of the biggest extensions to have occurred within SQL, allow\u2010\u000d\u000aing for many extra possibilities.\u000d\u000aCommon Table Expressions | 537","","Index\u000d\u000aSymbols\u000d\u000a% (modulus) function (SQL Server), 288\u000d\u000a% (wildcard) operator, 13\u000d\u000a* character in SELECT statements, 1\u000d\u000a+ (concatenation) operator (SQL Server), 7, 307\u000d\u000a_ (underscore) operator, 13\u000d\u000a|| (concatenation) function (DB2/Oracle/Post\u2010\u000d\u000agreSQL), 7, 306\u000d\u000aA\u000d\u000aabstraction, axiom of, 511\u000d\u000aADDDATE function (MySQL), 247, 262, 292,\u000d\u000a299\u000d\u000aADD_MONTHS function (Oracle), 282, 285,\u000d\u000a298\u000d\u000aaggregate functions\u000d\u000amultiple tables and, 52-59\u000d\u000aNULL values and, 190, 512\u000d\u000aWHERE clause, referencing in, 5\u000d\u000aaliases\u000d\u000afor CASE expression, 8\u000d\u000ainline views, 495\u000d\u000areferencing aliased columns, 5\u000d\u000aalphabetizing strings, 141-146\u000d\u000aalphanumeric strings\u000d\u000aconverting to numbers, 193-195\u000d\u000adetermining whether a string is alphanu\u2010\u000d\u000americ, 116-120\u000d\u000amixed, 472-473\u000d\u000asorting mixed, 18-21\u000d\u000aanti-joins, 31\u000d\u000aAS keyword, 4\u000d\u000aasterisk (*) character in SELECT statements, 1\u000d\u000aasterisk (*) character with COUNT function,\u000d\u000a175, 177\u000d\u000aaverages, computing, 169-171\u000d\u000aAVG function, 169-171\u000d\u000aaxiom of abstraction, 511\u000d\u000aaxiom of specification, 512\u000d\u000aaxiom schema of separation, 512\u000d\u000aaxiom schema of subsets, 512\u000d\u000aB\u000d\u000aBarber Puzzle, 511\u000d\u000aBenford's law, 201-203\u000d\u000abinary, converting whole numbers to, 474-477\u000d\u000aC\u000d\u000acalendars, creating, 268-280\u000d\u000aCartesian products, 51, 106\u000d\u000aCASE expression, 8, 12, 23, 28, 188, 196\u000d\u000aCAST function (SQL Server), 293\u000d\u000aCEIL function (DB2/MySQL/Oracle/Post\u2010\u000d\u000agreSQL), 388\u000d\u000aCEILING function (SQL Server), 388, 417\u000d\u000aCOALESCE function, 12, 64, 170, 190, 246, 319\u000d\u000acolumns\u000d\u000aadding headers to double pivoted result sets,\u000d\u000a481-491\u000d\u000aconcatenating, 6\u000d\u000anaming, 4\u000d\u000aretrieving a subset of columns from a table,\u000d\u000a3\u000d\u000aretrieving all rows and columns from a\u000d\u000atable, 1\u000d\u000acommon table expressions (CTEs), xiii, 536\u000d\u000a539","composite subqueries, converting scalar subqu\u2010\u000d\u000aeries to (Oracle), 493-495\u000d\u000aCONCAT function (MySQL), 7, 121, 307\u000d\u000aconcatenation\u000d\u000acolumn values, 6\u000d\u000aoperator (+) (SQL Server), 7, 307\u000d\u000aoperator (||) (DB2/Oracle/PostgreSQL), 7,\u000d\u000a306\u000d\u000aCONCAT_WS function (MySQL), 121, 124\u000d\u000aconditional logic in SELECT statements, 7\u000d\u000aCONNECT BY clause (Oracle), 269, 295\u000d\u000ain hierarchical structures, 446, 450\u000d\u000aWITH clause and, 360\u000d\u000aCONNECT_BY_ISLEAF function (Oracle),\u000d\u000a451, 455\u000d\u000aCONNECT_BY_ROOT function (Oracle), 451,\u000d\u000a455\u000d\u000aconstraints, listing, 95\u000d\u000acorrelated subquery, 39\u000d\u000aCOUNT function, 88, 175-178, 512\u000d\u000aCOUNT OVER window function, 420\u000d\u000acount star, 177\u000d\u000acreate table as select (CTAS), 72\u000d\u000aCREATE TABLE command, 71\u000d\u000aCREATE TABLE \u2026 LIKE command (DB2), 72\u000d\u000across-tab reports\u000d\u000acreating (SQL Server), 459-461\u000d\u000aunpivoting (SQL Server), 461-463\u000d\u000aCTAS (create table as select), 72\u000d\u000aCTEs (common table expressions), xiii, 536\u000d\u000aCUBE extension, 401, 406\u000d\u000aCUME_DIST function, 186\u000d\u000aCURRENT_DATE function (DB2/MySQL/\u000d\u000aPostgreSQL), 267, 362\u000d\u000aD\u000d\u000adata dependent keys, sorting on, 27\u000d\u000adata dictionary views (Oracle), 102\u000d\u000aDATE function (DB2), 289\u000d\u000adate manipulation, 239-311\u000d\u000acomparing records using specific parts of a\u000d\u000adate, 302-305\u000d\u000acreating a calendar, 268-280\u000d\u000adetermining all dates for a particular week\u2010\u000d\u000aday throughout a year, 255-260\u000d\u000adetermining quarter start/end dates for a,\u000d\u000a286-293\u000d\u000adetermining the date of first/last occur\u2010\u000d\u000arences of specific weekday in month,\u000d\u000a261-268\u000d\u000adetermining the first/last days of a month,\u000d\u000a252-254\u000d\u000adetermining the number of days in a year,\u000d\u000a246-249, 470\u000d\u000adetermining whether a year is a leap year,\u000d\u000a240-246\u000d\u000aextracting units of time from date, 249-252\u000d\u000afilling in missing dates, 293-301\u000d\u000aidentifying overlapping date ranges,\u000d\u000a305-310\u000d\u000alisting quarter/end dates for the year,\u000d\u000a281-286\u000d\u000asearching on specific units of time, 301-302\u000d\u000aDATEADD function (SQL Server), 247, 253\u000d\u000aDATEDIFF function (MySQL/SQL Server), 247\u000d\u000aDATENAME function (SQL Server), 302, 304\u000d\u000aDATEPART function (SQL Server), 249, 251,\u000d\u000a260, 283, 286\u000d\u000adates, ORDER BY clause and (DB2), 422\u000d\u000aDATE_FORMAT function (MySQL), 251, 303\u000d\u000aDATE_TRUNC function (PostgreSQL), 243,\u000d\u000a247, 253\u000d\u000aDAY function (DB2), 246, 250, 252\u000d\u000aDAY function (MySQL), 246, 253\u000d\u000aDAY function (SQL Server), 246, 253\u000d\u000aDAYNAME function (DB2/MySQL/SQL\u000d\u000aServer), 301\u000d\u000aDAYOFWEEK function (DB2/MYSQL), 267,\u000d\u000a303\u000d\u000aDAYOFYEAR function (DB2/MySQL/SQL\u000d\u000aServer), 246-248, 297, 299-301\u000d\u000aDAYS function (DB2), 246\u000d\u000aDECODE function (Oracle), 504\u000d\u000aDEFAULT keyword, 69\u000d\u000aDEFAULT VALUES clause (PostgreSQL/SQL\u000d\u000aServer), 69\u000d\u000aDELETE command, 81, 83\u000d\u000adeleting records\u000d\u000aall, 83\u000d\u000aduplicate, 85-87\u000d\u000awith NULLs (PostgreSQL/MySQL), 374\u000d\u000awith NULLs (DB2/Oracle/SQL Server), 373\u000d\u000areferenced from another table, 87-88\u000d\u000areferencing nonexistent records from\u000d\u000aanother table, 85\u000d\u000areferential integrity violations, 85\u000d\u000a540 | Index","single, 84\u000d\u000aspecific, 83\u000d\u000adelimited data, converting to IN-list, 136-141\u000d\u000adelimited lists, creating, 132-135\u000d\u000aDENSE_RANK function (DB2/Oracle/SQL\u000d\u000aServer), 343, 355, 357\u000d\u000aDENSE_RANK OVER window function (DB2/\u000d\u000aOracle/SQL Server), 343, 350, 478\u000d\u000aDENSE_RANK window function, 183\u000d\u000aDEPT table structure, xv\u000d\u000aDICTIONARY view, 102\u000d\u000aDISTINCT keyword\u000d\u000aalternatives to, 31, 351\u000d\u000aSELECT list and, 17, 352, 510\u000d\u000auses for, 36, 54, 343\u000d\u000adouble aggregate, 535\u000d\u000aduplicates\u000d\u000adeleting, 85-87\u000d\u000asuppressing, 351-353\u000d\u000adynamic SQL, creating, 100-102\u000d\u000aE\u000d\u000aEMP table structure, xv\u000d\u000aequi-join operations, 31, 40\u000d\u000aEXCEPT function, 35, 45, 48\u000d\u000aEXTRACT function (PostgreSQL/MySQL), 327\u000d\u000aextreme values, finding, 344\u000d\u000aF\u000d\u000aFETCH FIRST clause (DB2), 8\u000d\u000aFibonacci sequence, 536\u000d\u000aforecasts, generating simple, 359-367\u000d\u000aforeign keys, listing, 97-100\u000d\u000aframing clause, 483\u000d\u000aFrege's axiom, 511\u000d\u000aFrege, Gottlob, 511\u000d\u000aFULL OUTER JOIN command, 62\u000d\u000aG\u000d\u000aGENERATE_SERIES function (PostgreSQL)\u000d\u000aparameters, 332\u000d\u000auses, 241, 244, 270, 331\u000d\u000aGETDATE function (SQL Server), 362\u000d\u000aGROUP BY clause, 353, 507\u000d\u000aGROUP BY queries, returning other columns\u000d\u000ain, 394-396\u000d\u000agrouping, 507-519\u000d\u000aCOUNT function and, 175\u000d\u000adefined, 508-512\u000d\u000aSELECT clause and, 173, 516-519\u000d\u000aSUM function and, 173\u000d\u000atesting for existence of a value within a\u000d\u000agroup, 502-504\u000d\u000aby time units, 416-419\u000d\u000aGROUPING function (DB2/Oracle/SQL\u000d\u000aServer), 398, 406, 432\u000d\u000aGROUPING SETS extension (DB2/Oracle),\u000d\u000a406-408\u000d\u000aGROUP_CONCAT function, 133, 143, 145\u000d\u000aH\u000d\u000ahierarchical queries, 435-458\u000d\u000acreating hierarchical view of a table,\u000d\u000a444-448\u000d\u000adetermining which rows are leaf/branch/\u000d\u000aroot nodes, 450-458\u000d\u000aexpressing a child-parent-grandparent rela\u2010\u000d\u000ationship, 440-444\u000d\u000aexpressing a parent-child relationship,\u000d\u000a436-439\u000d\u000afinding all child rows for given parent row,\u000d\u000a449\u000d\u000ahistograms\u000d\u000ahorizontal, 390-391\u000d\u000avertical, 392-393\u000d\u000aHOUR function (DB2), 250\u000d\u000aI\u000d\u000aIF-ELSE operations, 7\u000d\u000aimplicit type conversion, 20\u000d\u000aIN-lists, converting delimited data into,\u000d\u000a136-141\u000d\u000aindexes, listing, 94\u000d\u000ainformation schema (MySQL/PostgreSQL/SQL\u000d\u000aServer), 91\u000d\u000ainline views\u000d\u000anaming, 495\u000d\u000areferencing aliased columns with, 5\u000d\u000ainner joins, 31, 340\u000d\u000aINSERT ALL statement (Oracle), 73\u000d\u000aINSERT FIRST statement (Oracle), 73\u000d\u000aINSERT statement, 68, 70\u000d\u000ainserting into a column, 70\u000d\u000ainserting records\u000d\u000ablocking, 74\u000d\u000acopying rows from one table to another, 70\u000d\u000awith default values, 68-70\u000d\u000aIndex | 541","into multiple tables, 72-74\u000d\u000anew records, 68\u000d\u000awith NULL values, 70\u000d\u000aINSTR function, 140, 155, 159\u000d\u000aINSTR function (Oracle), 468\u000d\u000aintegrity, deleting records violating, 85\u000d\u000aINTERSECT operation, 33-34\u000d\u000aISNUMERIC function, 150\u000d\u000aITERATE command (Oracle), 331\u000d\u000aITERATION_NUMBER function (Oracle), 332\u000d\u000aJ\u000d\u000aJOIN clause, 33\u000d\u000ajoins\u000d\u000aabout, 31\u000d\u000aaggregates and, 52-57\u000d\u000aanti-, 31\u000d\u000aequi-, 31, 40\u000d\u000ainner, 31, 340\u000d\u000ascalar subqueries and, 43\u000d\u000aselecting columns, 34\u000d\u000aself-, 307, 342\u000d\u000aK\u000d\u000aKEEP extension (Oracle), 183, 184, 357\u000d\u000akeys\u000d\u000adata dependent, 27\u000d\u000aforeign, 97-100\u000d\u000apreserving, 80\u000d\u000aknight values, 353-358\u000d\u000aKyte, Tom, 475\u000d\u000aL\u000d\u000aLAG OVER window function (Oracle),\u000d\u000a316-325, 348-349, 383\u000d\u000aLAG window function, 182\u000d\u000aLAST function (Oracle), 355, 357\u000d\u000aLAST_DAY function (MySQL/Oracle), 240,\u000d\u000a241, 252, 253, 266\u000d\u000aLEAD OVER window function (Oracle)\u000d\u000adefault behavior, 321\u000d\u000aduplicates and, 319\u000d\u000aoptions, 321, 346, 349\u000d\u000aself-joins and, 308-310, 314, 317\u000d\u000auses, 315, 347, 348\u000d\u000aleap years, 240-246\u000d\u000aLEN function, 126\u000d\u000aLENGTH function, 109, 126\u000d\u000aLIKE operator, 13\u000d\u000aLIMIT clause (MySQL/PostgreSQL), 8, 10\u000d\u000aLIST_AGG function, 133\u000d\u000alogarithms, 180\u000d\u000aloop functionality limits, in SQL, 105\u000d\u000aLPAD function (Oracle/PostgreSQL/MySQL),\u000d\u000a390\u000d\u000aLTRIM function (Oracle), 444\u000d\u000aM\u000d\u000amatrices, creating sparse, 414\u000d\u000aMAX function, 171, 183, 324\u000d\u000aMAX OVER window function, 344, 349\u000d\u000amaximum values, finding, 171-173\u000d\u000amedian absolute deviation, finding outliers\u000d\u000awith, 197-201\u000d\u000aMEDIAN function (Oracle), 186\u000d\u000amedians, calculating, 185-187\u000d\u000aMERGE statement, 67, 82\u000d\u000amerging records, 81-83\u000d\u000ametadata queries, 91-103\u000d\u000adescribing data dictionary views in an Ora\u2010\u000d\u000acle database, 102\u000d\u000alisting a table's columns, 93\u000d\u000alisting constraints on a table, 95\u000d\u000alisting foreign keys without corresponding\u000d\u000aindexes, 97-100\u000d\u000alisting indexed columns for a table, 94\u000d\u000alisting tables in a schema, 91\u000d\u000ausing SQL to generate SQL, 100-102\u000d\u000aMIN function, 171, 324\u000d\u000aMIN OVER window function (DB2/\u000d\u000aOracle/SQL Server), 328, 344, 349\u000d\u000aminimum values, finding, 171-173\u000d\u000aMINUS operation, 35, 36, 45, 48\u000d\u000aMINUTE function (DB2), 250\u000d\u000aMODEL clause (Oracle), 331, 463-467, 474-477\u000d\u000amodes, calculating, 182-185\u000d\u000amodifying records\u000d\u000achanging row data, 75\u000d\u000acopying rows from one table to another, 70\u000d\u000amodifying values in a table, 75\u000d\u000ausing queries for new values, 80\u000d\u000awith values from another table, 78-81\u000d\u000awhen corresponding rows exist, 77\u000d\u000amodulus (%) function (SQL Server), 288\u000d\u000aMONTH function (DB2/MySQL), 242, 250,\u000d\u000a268\u000d\u000a542 | Index","MONTHNAME function (DB2/MySQL), 301,\u000d\u000a303\u000d\u000amultiple tables, inserting data into, 72-74\u000d\u000amultiple tables, retrieving data from, 29-65\u000d\u000aadding joins to a query without interfering\u000d\u000awith other joins, 42-44\u000d\u000aCartesian products and, 51\u000d\u000acombining related rows, 31-33\u000d\u000acomparing, 44-51\u000d\u000afinding rows in common between two\u000d\u000atables, 33\u000d\u000ajoins when aggregates are used, 52-57\u000d\u000anonmatching rows, 40\u000d\u000aNULLs in operations/comparisons, 64\u000d\u000aouter joins when using aggregates, 57-59\u000d\u000aretrieving rows from one table that do not\u000d\u000acorrespond to rows in another, 40\u000d\u000aretrieving values from one table that do not\u000d\u000aexist in another, 34-40\u000d\u000areturning missing data from multiple tables,\u000d\u000a60-63\u000d\u000astacking one rowset atop another, 29-31\u000d\u000aN\u000d\u000an-1 rule, 52\u000d\u000anames, extracting initials from, 120-124\u000d\u000anew records, inserting, 68\u000d\u000aNEWID function, 11\u000d\u000aNEXT_DAY function (Oracle), 265-266\u000d\u000aNOT EXISTS, 85\u000d\u000aNOT IN operator, 36\u000d\u000aNROWS function (DB2/SQL Server), 362\u000d\u000aNTILE window function (Oracle/SQL Server),\u000d\u000a389\u000d\u000aNULL paradox, 512\u000d\u000aNULLs\u000d\u000aaggregate functions and, 190\u000d\u000aAVG function and, 170\u000d\u000acomparisons to, 439\u000d\u000aCOUNT function and, 177\u000d\u000afinding null values, 11\u000d\u000ainserting records with, 70\u000d\u000aMIN/MAX functions and, 172\u000d\u000aNOT IN operator and, 36\u000d\u000aOR operations and, 36\u000d\u000aoverriding a default value with, 70\u000d\u000aremoving (DB2/Oracle/SQL Server), 373\u000d\u000aremoving (PostgreSQL/MySQL), 374\u000d\u000asorting and, 21-27\u000d\u000aSUM function and, 174, 176\u000d\u000atransforming into real values, 12\u000d\u000awindow functions and, 523\u000d\u000aNULLS FIRST extension, 25\u000d\u000aNULLS LAST extension, 25\u000d\u000anumbers queries, 169-203\u000d\u000aaggregating nullable columns, 190\u000d\u000aaverages, 169-171\u000d\u000aaverages without high/low values, 191-193\u000d\u000acalculating a median, 185-187\u000d\u000acalculating a mode, 182-185\u000d\u000achanging values in a running total, 196-197\u000d\u000aconverting alphanumeric strings into num\u2010\u000d\u000abers, 193-195\u000d\u000aconverting whole to binary (Oracle),\u000d\u000a474-477\u000d\u000acounting rows in a table, 175-177\u000d\u000acounting values in a column, 177\u000d\u000adetermining the percentage of a total,\u000d\u000a187-190\u000d\u000afinding anomalies using Benford's law,\u000d\u000a201-203\u000d\u000afinding outliers using the median absolute\u000d\u000adeviation, 197-201\u000d\u000afinding the min/max value in a column,\u000d\u000a171-173\u000d\u000agenerating a running product, 179\u000d\u000agenerating a running total, 178\u000d\u000apercentage relative to total, 500-501\u000d\u000asmoothing a series of values, 181\u000d\u000asubtotals for all combinations, 400-410\u000d\u000asubtotals, simple, 397-400\u000d\u000asumming values in a column, 173-175\u000d\u000aO\u000d\u000aORDER BY clause, 10, 15, 17, 178, 422\u000d\u000a(see also sorting query results)\u000d\u000aouter joins\u000d\u000aOR logic in, 341\u000d\u000aOracle syntax, 43, 295\u000d\u000awhen using aggregates, 57-59\u000d\u000aoutliers, median absolute deviation for finding,\u000d\u000a197-201\u000d\u000aOVER keyword, 26\u000d\u000aP\u000d\u000aPARTITION BY clause, 521-523\u000d\u000apatterns, searches for matching, 13\u000d\u000apercent (%) operator, 13\u000d\u000aIndex | 543","percentage calculations, 187-190, 500-501\u000d\u000aPERCENTILE_CONT function, 185-187, 198\u000d\u000aPIVOT operator (SQL Server), 459-461\u000d\u000apivot tables, xvi\u000d\u000apivoting\u000d\u000aabout, 370\u000d\u000ainter-row calculations, 384-386\u000d\u000aMODEL clause (Oracle), 463-467\u000d\u000amultiple rows, results into, 372-377\u000d\u000aone row, results into, 369-371\u000d\u000aranked result sets, 477-481\u000d\u000areverse, 377-378\u000d\u000asubtotals, result sets with, 429-434\u000d\u000aPRIOR keyword (Oracle), 443\u000d\u000aQ\u000d\u000aQUARTER function (DB2/MySQL), 285\u000d\u000aquotes, embedding within string literals, 108\u000d\u000aR\u000d\u000aRAND function, 10\u000d\u000aRANDOM function, 11\u000d\u000arandom records, retrieving, 10\u000d\u000aranges, 313-333\u000d\u000afilling in missing values, 326-329\u000d\u000afinding differences between rows in same\u000d\u000agroup/partition, 317-323\u000d\u000agenerating consecutive numeric values,\u000d\u000a330-333\u000d\u000alocating range of consecutive values,\u000d\u000a313-316\u000d\u000alocating the beginning/end of a range of\u000d\u000aconsecutive values, 323-326\u000d\u000aRANK OVER window function, 350\u000d\u000aRATIO_TO_REPORT function (Oracle), 501\u000d\u000areciprocal rows, searching for, 341-343\u000d\u000arecords\u000d\u000amerging, 81-83\u000d\u000asorting (see sorting query results)\u000d\u000aRECURSIVE keyword, 537\u000d\u000areferential integrity, deleting records violating,\u000d\u000a85\u000d\u000aREGEXP_REPLACE function, 166\u000d\u000aREPEAT function, 121\u000d\u000aREPEAT function (DB2), 390\u000d\u000aREPLACE function, 20, 105\u000d\u000a(see also strings)\u000d\u000aREPLICATE function (SQL Server), 390\u000d\u000areports, queries for creating, 369-434\u000d\u000acalculating simple subtotals, 397-400\u000d\u000acalculating subtotals for all possible expres\u2010\u000d\u000asion combinations, 400-410\u000d\u000acreating a predefined number of buckets,\u000d\u000a388\u000d\u000acreating a sparse matrix, 414\u000d\u000acreating buckets of data, of a fixed size,\u000d\u000a386-388\u000d\u000acreating horizontal histograms, 390-391\u000d\u000acreating vertical histograms, 392-393\u000d\u000agrouping rows by units of time, 416-419\u000d\u000aidentifying rows that are not subtotals,\u000d\u000a410-412\u000d\u000aperforming aggregations over a moving\u000d\u000arange of values, 422-429\u000d\u000aperforming aggregations over different\u000d\u000agroups/partitions simultaneously,\u000d\u000a420-421\u000d\u000apivoting a result set into multiple rows,\u000d\u000a372-377\u000d\u000apivoting a result set into one row, 369-371\u000d\u000apivoting a result set to facilitate inter-row\u000d\u000acalculations, 384-386\u000d\u000apivoting a result set with subtotals, 429-434\u000d\u000areturning non-GROUP BY columns,\u000d\u000a394-396\u000d\u000areverse pivoting a result set, 377-378\u000d\u000areverse pivoting a result set into one col\u2010\u000d\u000aumn, 379-381\u000d\u000asuppressing repeating values from a result\u000d\u000aset, 382-384\u000d\u000ausing case expressions to flag rows, 412-414\u000d\u000aresult set, transposing (Oracle), 463-467\u000d\u000aretrieving records, 1-14\u000d\u000aconcatenating column values, 6\u000d\u000afinding null values, 11\u000d\u000afinding rows that satisfy multiple condi\u2010\u000d\u000ations, 2\u000d\u000alimiting the number of rows returned, 8-10\u000d\u000aproviding meaningful names for columns, 4\u000d\u000areferencing an aliased column in the\u000d\u000aWHERE clause, 5\u000d\u000afor reports (see reports, queries for creating)\u000d\u000aretrieving a subset of columns from a table,\u000d\u000a3\u000d\u000aretrieving a subset of rows from a table, 2\u000d\u000aretrieving all rows and columns from a\u000d\u000atable, 1\u000d\u000areturning n random records from a table, 10\u000d\u000a544 | Index","searching for patterns, 13\u000d\u000atransforming nulls into real values, 12\u000d\u000ausing conditional logic in a SELECT state\u2010\u000d\u000ament, 7\u000d\u000areverse pivoting result sets, 377-378\u000d\u000arobust statistics, 193\u000d\u000aROLLUP extension of GROUP BY (DB2/\u000d\u000aOracle), 397, 410, 430\u000d\u000arow generation, dynamic, 330\u000d\u000aROWNUM function (Oracle), 9, 285, 337\u000d\u000arows\u000d\u000acopying from one table to another, 70\u000d\u000afinding rows that satisfy multiple condi\u2010\u000d\u000ations, 2\u000d\u000alimiting the number of rows returned, 8-10\u000d\u000aparsing serialized data into, 495-499\u000d\u000aretrieving a subset of rows from a table, 2\u000d\u000aretrieving all rows and columns from a\u000d\u000atable, 1\u000d\u000aROW_NUMBER function (Oracle), 135\u000d\u000aROW_NUMBER function (SQL Server), 144\u000d\u000aROW_NUMBER OVER window function\u000d\u000a(DB2/Oracle/SQL Server)\u000d\u000aORDER BY clause and, 352\u000d\u000auniqueness of result, 336\u000d\u000auses, 284, 336-339, 351, 373\u000d\u000aRPAD function, 122, 480\u000d\u000aRTRIM function (Oracle/PostgreSQL), 301\u000d\u000aRULES subclause (Oracle), 465\u000d\u000arunning products, 179\u000d\u000arunning totals, 178, 196-197\u000d\u000aRussell's Paradox, 511\u000d\u000aRussell, Bertrand, 511\u000d\u000aS\u000d\u000ascalar subqueries\u000d\u000aconverting to composite (Oracle), 493-495\u000d\u000ajoins and, 43\u000d\u000areferencing in WHERE clause, 10\u000d\u000ascripts, generating, 100-102\u000d\u000asearching, 335-367\u000d\u000adetermining which rows are reciprocals,\u000d\u000a341-343\u000d\u000afinding knight values, 353-358\u000d\u000afinding records with highest/lowest values,\u000d\u000a344\u000d\u000agenerating simple forecasts, 359-367\u000d\u000aincorporating OR logic when using outer\u000d\u000ajoins, 339-341\u000d\u000ainvestigating future rows, 345-347\u000d\u000apaginating through a result set, 335-337\u000d\u000apatterns, 13\u000d\u000aranking results, 350\u000d\u000aselecting top n records, 343\u000d\u000ashifting row values, 347-349\u000d\u000askipping n rows from a table, 338\u000d\u000asuppressing duplicates, 351-353\u000d\u000aSECOND function (DB2), 250\u000d\u000aSELECT function, 108\u000d\u000aSELECT statements, 1\u000d\u000a(see also retrieving records)\u000d\u000a* character in, 1\u000d\u000aconditional logic in, 7\u000d\u000aDISTINCT keyword and, 17, 352, 510\u000d\u000aGROUP BY and, 173, 516-519\u000d\u000apartial, xvi\u000d\u000aself-joins\u000d\u000aalternatives to, 308, 314, 324\u000d\u000auses, 307, 342\u000d\u000aseparation, axiom schema of, 512\u000d\u000aserialized data, parsing into rows, 495-499\u000d\u000aSET differences, 45\u000d\u000aSHOW INDEX command, 94, 99\u000d\u000aSIGN function (MySQL/PostgreSQL), 266\u000d\u000asorting query results, 15-28\u000d\u000aon data-dependent key, 27\u000d\u000amixed alphanumeric data, 18-21\u000d\u000aby multiple fields, 16\u000d\u000aNULLS and, 21-27\u000d\u000areturning in a specified order, 15-16\u000d\u000aby substrings, 17\u000d\u000aSOUNDEX function, 163\u000d\u000aspecification, axiom of, 512\u000d\u000aSPLIT_PART function, 137, 141, 155, 161\u000d\u000astar (*) character in SELECT statements, 1\u000d\u000aSTART WITH clause (Oracle), 447, 449\u000d\u000aStoll, Robert, 511\u000d\u000astrings, 105-167\u000d\u000aalphabetizing, 141-146\u000d\u000aalphanumeric, sorting mixed, 18-21\u000d\u000acomparing strings by sound, 162-164\u000d\u000aconverting alphanumeric strings to num\u2010\u000d\u000abers, 193-195\u000d\u000aconverting delimited data into a multivalued\u000d\u000aIN-list, 136-141\u000d\u000acounting the occurrences of a character in a\u000d\u000astring, 109\u000d\u000aIndex | 545","creating a delimited list from table rows,\u000d\u000a132-135\u000d\u000adetermining whether alphanumeric,\u000d\u000a116-120\u000d\u000aembedding quotes within string literals, 108\u000d\u000aextracting elements from unfixed locations,\u000d\u000a467-470\u000d\u000aextracting initials from a name, 120-124\u000d\u000aextracting the nth delimited substring,\u000d\u000a153-160\u000d\u000afinding text not matching a pattern, 164-167\u000d\u000aidentifying strings that can be treated as\u000d\u000anumbers, 147-153\u000d\u000amixed alphanumeric, 472-473\u000d\u000aordering by a number in a string, 126-132\u000d\u000aordering by parts of a string, 125-126\u000d\u000aparsing an IP address, 160-162\u000d\u000aparsing into rows, 495-499\u000d\u000aremoving unwanted characters from,\u000d\u000a110-112\u000d\u000aseparating numeric and character data,\u000d\u000a112-116\u000d\u000atraversing, 106-108\u000d\u000awalking a string, 106-108\u000d\u000aSTRING_AGG function, 134, 143, 155\u000d\u000aSTRING_SPLIT function, 155, 158\u000d\u000aSTR_TO_DATE function (MySQL), 292\u000d\u000asubqueries, 493-495, 535\u000d\u000asubsets, axiom schema of, 512\u000d\u000aSUBSTR function (DB2/MySQL/Oracle/Post\u2010\u000d\u000agreSQL), 18, 124, 126, 140, 144, 146, 155,\u000d\u000a159\u000d\u000aSUBSTRING function (MySQL), 121\u000d\u000aSUBSTRING function (SQL Server), 18, 126,\u000d\u000a144, 288, 292\u000d\u000asubstrings\u000d\u000aextracting the nth delimited substring,\u000d\u000a153-160\u000d\u000asorting query results by, 17\u000d\u000aSUBSTRING_INDEX function (MySQL), 121,\u000d\u000a124, 139, 161\u000d\u000asubtotals\u000d\u000acalculating for all combinations, 400-410\u000d\u000acalculating simple, 397-400\u000d\u000apivoting result set with, 429-434\u000d\u000aSUM function, 174, 176\u000d\u000aSUM OVER window function (DB2/\u000d\u000aOracle/SQL Server), 55, 59, 178, 180, 188,\u000d\u000a196\u000d\u000asumming column values, 173-175\u000d\u000aSYS_CONNECT_BY_PATH function (Oracle),\u000d\u000a133, 135, 143, 145, 441, 444, 457\u000d\u000aT\u000d\u000atables, creating with same columns as\u000d\u000aexisting table, 71\u000d\u000atime, grouping rows by, 416-419\u000d\u000aTOP keyword (SQL Server), 9\u000d\u000aTO_BASE function (Oracle), 475\u000d\u000aTO_CHAR function (Oracle/PostgreSQL), 244,\u000d\u000a245, 250, 255, 259\u000d\u000aTO_NUMBER function (Oracle/PostgreSQL),\u000d\u000a250\u000d\u000aTRANSLATE function, 20, 105\u000d\u000a(see also strings)\u000d\u000atransposing result sets (Oracle), 463-467\u000d\u000atrimmed mean, 191, 193\u000d\u000aTRUNC function (Oracle), 248, 252, 285\u000d\u000aTRUNCATE command, 83\u000d\u000aU\u000d\u000aunderscore (_) operator, 13\u000d\u000aUNION ALL operation, 29-31, 46, 48-51, 73,\u000d\u000a516\u000d\u000aUNION operation, 30, 48\u000d\u000aUNPIVOT operator (SQL Server), 461-463\u000d\u000aUPDATE statement, 76-83\u000d\u000aV\u000d\u000aVALUE function, 11\u000d\u000aW\u000d\u000aWHERE clause\u000d\u000adetermining whether a string is alphanu\u2010\u000d\u000americ, 120\u000d\u000afinding rows that satisfy multiple condi\u2010\u000d\u000ations, 2\u000d\u000aRECURSIVE with, 537\u000d\u000areferencing an aliased column in, 5\u000d\u000aretrieving a subset of rows from a table, 2\u000d\u000aROWNUM with, 9\u000d\u000awhole numbers, converting to binary, 474-477\u000d\u000awildcard (%) operator, 13\u000d\u000awindow functions, xiii, 507-533\u000d\u000aadvantages, 396, 481, 530-531\u000d\u000aNULLs and, 523\u000d\u000apartitions, 521-523\u000d\u000a546 | Index","platforms supporting, 422, 483\u000d\u000areferencing in WHERE clause, 5\u000d\u000areports and, 532-533\u000d\u000atiming of, 315, 421\u000d\u000aWITH clause (DB2/SQL Server), 440, 445, 450\u000d\u000aWITH clause (SQL Server), 272\u000d\u000aWITH ROLLUP (SQL Server/MySQL), 397\u000d\u000aY\u000d\u000aYEAR function (DB2/MySQL/SQL Server),\u000d\u000a250, 326\u000d\u000aYoung, Kay, 354\u000d\u000aZ\u000d\u000aZermelo, Ernst, 512\u000d\u000aIndex | 547","About the Authors\u000d\u000aAnthony Molinaro is a data scientist at Johnson & Johnson. In his current role he is a\u000d\u000amanager in the Observational Health Data Analytics group within Janssen R&D. His\u000d\u000aprimary areas of research are nonparametric methods, time-series analysis, and largescale database characterization and transformation. He is a member of the open sci\u2010\u000d\u000aence OHDSI community. Anthony holds a BA in mathematics and an MA in applied\u000d\u000amathematics & statistics from CUNY Hunter College. He resides in New York with\u000d\u000ahis wife Georgia and his two daughters, Kiki and Connie.\u000d\u000aRobert de Graaf graduated as an engineer and worked in the manufacturing industry\u000d\u000aafter completing his studies. While working as an engineer, Robert discovered the\u000d\u000apower of statistics for solving real-world problems, and completed a master\u2019s degree\u000d\u000ain statistics in time to benefit from the data science boom. He has worked for Right\u2010\u000d\u000aShip as their senior data scientist since 2013, and is the author of Managing Your Data\u000d\u000aScience Projects (Apress).\u000d\u000aColophon\u000d\u000aThe animal on the cover of SQL Cookbook is a starred agama or roughtail rock agama\u000d\u000a(Stellagama stellio). These lizards can be found in Egypt, Turkey, Greece, and other\u000d\u000acountries surrounding the Mediterranean Sea, and are often present in rocky moun\u2010\u000d\u000atainous and coastal regions with arid or semi-arid climates. Starred agamas are diur\u2010\u000d\u000anal and can often be found on rocks, trees, buildings, and other habitats that allow for\u000d\u000aclimbing and hiding.\u000d\u000aStarred agamas lay anywhere from 3 to 12 eggs per clutch, and they grow to about\u000d\u000a30\u201335 cm in length. This species is characterized by strong legs and\u2014like many other\u000d\u000aagamids\u2014the ability to change color depending on their mood or the surrounding\u000d\u000atemperature. Both males and females typically have gray or brown bodies with color\u2010\u000d\u000aful spots along their back and sides. Unlike other lizards, agamids such as the starred\u000d\u000aagama cannot regenerate their tails if they lose them.\u000d\u000aThough they can be skittish, starred agamas are not usually aggressive toward\u000d\u000ahumans and become quite tame if handled from a young age. They are commonly\u000d\u000akept as pets, and can be fed a combination of insects and various leafy greens. Small\u000d\u000agroups of agamas can be housed together if the terrarium is large enough, but males\u000d\u000aneed to be kept separate from one another to prevent fighting.\u000d\u000aThe IUCN does not list the starred agama as a species of concern, and its population\u000d\u000ais stable. Many of the animals on O\u2019Reilly covers are endangered; all of them are\u000d\u000aimportant to the world.","The cover illustration is by Karen Montgomery, based on a black and white engrav\u2010\u000d\u000aing, loose plate, source unknown. The cover fonts are Gilroy Semibold and Guardian\u000d\u000aSans. The text font is Adobe Minion Pro; the heading font is Adobe Myriad Con\u2010\u000d\u000adensed; and the code font is Dalton Maag\u2019s Ubuntu Mono."]